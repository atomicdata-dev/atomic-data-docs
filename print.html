<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Atomic Data Docs</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for the Atomic Data standard.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="atomic-data-overview.html"><strong aria-hidden="true">1.</strong> Atomic Data Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="motivation.html"><strong aria-hidden="true">1.1.</strong> Motivation</a></li><li class="chapter-item expanded "><a href="when-to-use.html"><strong aria-hidden="true">1.2.</strong> When (not) to use it</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Specification (core)</li><li class="chapter-item expanded "><a href="core/concepts.html"><strong aria-hidden="true">2.</strong> What is Atomic Data?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core/serialization.html"><strong aria-hidden="true">2.1.</strong> Serialization</a></li><li class="chapter-item expanded "><a href="core/json-ad.html"><strong aria-hidden="true">2.2.</strong> JSON-AD</a></li><li class="chapter-item expanded "><a href="core/querying.html"><strong aria-hidden="true">2.3.</strong> Querying</a></li><li class="chapter-item expanded "><a href="core/paths.html"><strong aria-hidden="true">2.4.</strong> Paths</a></li></ol></li><li class="chapter-item expanded "><a href="schema/intro.html"><strong aria-hidden="true">3.</strong> Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="schema/classes.html"><strong aria-hidden="true">3.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="schema/datatypes.html"><strong aria-hidden="true">3.2.</strong> Datatypes</a></li><li class="chapter-item expanded "><a href="schema/translations.html"><strong aria-hidden="true">3.3.</strong> Translations</a></li><li class="chapter-item expanded "><a href="schema/faq.html"><strong aria-hidden="true">3.4.</strong> FAQ</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Specification (extended)</li><li class="chapter-item expanded "><a href="extended.html"><strong aria-hidden="true">4.</strong> Atomic Data Extended</a></li><li class="chapter-item expanded "><a href="agents.html"><strong aria-hidden="true">5.</strong> Agents</a></li><li class="chapter-item expanded "><a href="hierarchy.html"><strong aria-hidden="true">6.</strong> Hierarchy and authorization</a></li><li class="chapter-item expanded "><a href="authentication.html"><strong aria-hidden="true">7.</strong> Authentication</a></li><li class="chapter-item expanded "><a href="invitations.html"><strong aria-hidden="true">8.</strong> Invitations and sharing</a></li><li class="chapter-item expanded "><a href="commits/intro.html"><strong aria-hidden="true">9.</strong> Commits (writing data)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commits/concepts.html"><strong aria-hidden="true">9.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="commits/compare.html"><strong aria-hidden="true">9.2.</strong> Compared to</a></li></ol></li><li class="chapter-item expanded "><a href="websockets.html"><strong aria-hidden="true">10.</strong> WebSockets</a></li><li class="chapter-item expanded "><a href="endpoints.html"><strong aria-hidden="true">11.</strong> Endpoints</a></li><li class="chapter-item expanded "><a href="schema/collections.html"><strong aria-hidden="true">12.</strong> Collections, filtering, sorting</a></li><li class="chapter-item expanded "><a href="files.html"><strong aria-hidden="true">13.</strong> Uploading and downloading files</a></li><li class="chapter-item expanded affix "><li class="part-title">Using Atomic Data</li><li class="chapter-item expanded "><a href="interoperability/intro.html"><strong aria-hidden="true">14.</strong> Interoperability and comparisons</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="interoperability/upgrade.html"><strong aria-hidden="true">14.1.</strong> Making your existing project compatible</a></li><li class="chapter-item expanded "><a href="interoperability/rdf.html"><strong aria-hidden="true">14.2.</strong> RDF</a></li><li class="chapter-item expanded "><a href="interoperability/solid.html"><strong aria-hidden="true">14.3.</strong> Solid</a></li><li class="chapter-item expanded "><a href="interoperability/json.html"><strong aria-hidden="true">14.4.</strong> JSON</a></li><li class="chapter-item expanded "><a href="interoperability/ipfs.html"><strong aria-hidden="true">14.5.</strong> IPFS</a></li><li class="chapter-item expanded "><a href="interoperability/sql.html"><strong aria-hidden="true">14.6.</strong> SQL</a></li><li class="chapter-item expanded "><a href="interoperability/graph-database.html"><strong aria-hidden="true">14.7.</strong> Graph Databases</a></li></ol></li><li class="chapter-item expanded "><a href="usecases/intro.html"><strong aria-hidden="true">15.</strong> Potential use cases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usecases/personal-data-store.html"><strong aria-hidden="true">15.1.</strong> Personal Data Store</a></li><li class="chapter-item expanded "><a href="usecases/e-commerce.html"><strong aria-hidden="true">15.2.</strong> E-commerce &amp; marketplaces</a></li><li class="chapter-item expanded "><a href="usecases/surveys.html"><strong aria-hidden="true">15.3.</strong> Surveys</a></li><li class="chapter-item expanded "><a href="usecases/verifiable-credentials.html"><strong aria-hidden="true">15.4.</strong> Verifiable Credentials</a></li><li class="chapter-item expanded "><a href="usecases/food-labels.html"><strong aria-hidden="true">15.5.</strong> Food labels</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">16.</strong> Software and libraries</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="acknowledgements.html">Acknowledgements</a></li><li class="chapter-item expanded affix "><a href="newsletter.html">Newsletter</a></li><li class="chapter-item expanded affix "><a href="get-involved.html">Get involved</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Atomic Data Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ontola/atomic-data" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="assets/atomic_data_logo_stroke.svg" alt="# Atomic Data Docs - Overview" /></p>
<p><strong>Atomic Data is a modular specification for sharing, modifying and modeling graph data. It combines the ease of use of JSON, the connectivity of RDF (linked data) and the reliability of type-safety.</strong></p>
<p><img src="assets/venn.svg" alt="Venn diagram showing Atomic Data is the combination of JSON, RDF and Type-Safety" /></p>
<p>Atomic Data uses links to connect pieces of data, and therefore makes it easier to connect datasets to each other - even when these datasets exist on separate machines.</p>
<p>Atomic Data is especially suitable for knowledge graphs, distributed datasets, semantic data, p2p applications, decentralized apps and linked open data.
It is designed to be highly extensible, easy to use, and to make the process of domain specific standardization as simple as possible.</p>
<p>Atomic Data is <a href="https://ontola.io/what-is-linked-data/">Linked Data</a>, as it is a <a href="interoperability/rdf.html">strict subset of RDF</a>.
It is type-safe (you know if something is a <code>string</code>, <code>number</code>, <code>date</code>, <code>URL</code>, etc.) and extensible through <a href="schema/intro.html">Atomic Schema</a>, which means that you can re-use or define your own Classes, Properties and Datatypes.</p>
<p>The default serialization format for Atomic Data is <a href="core/json-ad.html">JSON-AD</a>, which is simply JSON where each key is a URL of an Atomic Property.
These Properties are responsible for setting the <code>datatype</code> (to ensure type-safety) and setting <code>shortnames</code> (which help to keep names short, for example in JSON serialization) and <code>descriptions</code> (which provide semantic explanations of what a property should be used for).</p>
<h2 id="atomic-data-extended"><a class="header" href="#atomic-data-extended">Atomic Data Extended</a></h2>
<p>Atomic Data Extended is a set of extra modules (on top of Atomic Data Core) that deal with data that changes over time, authentication, and authorization.</p>
<ul>
<li><a href="commits/intro.html">Commits</a> communicate state changes. These Commits are signed using cryptographic keys, which ensures that every change can be audited. Commits are also used to construct a history of versions.</li>
<li><a href="agents.html">Agents</a> are Users that enable <a href="authentication.html">authentication</a>. They are Resources with their own Public and Private keys, which they use to identify themselves.</li>
<li><a href="schema/collections.html">Collections</a>: querying, filetering, sorting and pagination.</li>
<li><a href="core/paths.html">Paths</a>: traverse graphs.</li>
<li><a href="hierarchy.html">Hierarchies</a> used for authorization and keeping data organized. Similar to folder structures on filesystems.</li>
<li><a href="invitations.html">Invites</a>: create new users and provide them with rights.</li>
<li><a href="websockets.html">WebSockets</a>: real-time updates.</li>
<li><a href="endpoints.html">Endpoints</a>: provide machine-readable descriptions of web services.</li>
<li><a href="files.html">Files</a>: upload, download and metadata for files.</li>
</ul>
<h2 id="get-started"><a class="header" href="#get-started">Get Started</a></h2>
<p>If you want to read more about how Atomic Data works - read on.
If you'd rather play and discover for yourself, play with the existing open source <a href="tooling.html">tooling</a>:</p>
<ul>
<li>Browser app <a href="https://github.com/joepio/atomic-data-browser">atomic-data-browser</a> (<a href="https://atomicdata.dev">demo on atomicdata.dev</a>)</li>
<li>Build a react app using <a href="https://github.com/joepio/atomic-data-ts">typescript &amp; react libraries</a>. Start with the <a href="https://codesandbox.io/s/atomic-data-react-template-4y9qu?file=/src/MyResource.tsx">react template on codesandbox</a></li>
<li>Host your own <a href="https://github.com/joepio/atomic">atomic-server</a> (powers <a href="https://atomicdata.dev">atomicdata.dev</a>, run with <code>docker run -p 80:80 -p 443:443 -v atomic-storage:/atomic-storage joepmeneer/atomic-server</code>)</li>
<li>Discover the command line tool: <a href="https://github.com/joepio/atomic">atomic-cli</a> (<code>cargo install atomic-cli</code>)</li>
<li>Use the Rust library: <a href="https://github.com/joepio/atomic">atomic-lib</a></li>
</ul>
<p>Make sure to <a href="https://discord.gg/a72Rv2P">join our Discord</a> if you'd like to discuss Atomic Data with others.</p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>Keep in mind that none of the Atomic Data project has reached a v1, which means that breaking changes can happen.</p>
<h2 id="reading-these-docs"><a class="header" href="#reading-these-docs">Reading these docs</a></h2>
<p>This is written mostly as a book, so reading it in the order of the Table of Contents will probably give you the best experience.
That being said, feel free to jump around - links are often used to refer to earlier discussed concepts.
If you encounter any issues while reading, please leave an <a href="https://github.com/ontola/atomic-data/issues">issue on Github</a>.
Use the arrows on the side / bottom to go to the next page.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="atomic-data-overview.html">Atomic Data Overview</a>
<ul>
<li><a href="motivation.html">Motivation</a></li>
<li><a href="when-to-use.html">When (not) to use it</a></li>
</ul>
</li>
</ul>
<h1 id="specification-core"><a class="header" href="#specification-core">Specification (core)</a></h1>
<ul>
<li><a href="core/concepts.html">What is Atomic Data?</a>
<ul>
<li><a href="core/serialization.html">Serialization</a></li>
<li><a href="core/json-ad.html">JSON-AD</a></li>
<li><a href="core/querying.html">Querying</a></li>
<li><a href="core/paths.html">Paths</a></li>
</ul>
</li>
<li><a href="schema/intro.html">Schema</a>
<ul>
<li><a href="schema/classes.html">Classes</a></li>
<li><a href="schema/datatypes.html">Datatypes</a></li>
<li><a href="schema/translations.html">Translations</a></li>
<li><a href="schema/faq.html">FAQ</a></li>
</ul>
</li>
</ul>
<h1 id="specification-extended"><a class="header" href="#specification-extended">Specification (extended)</a></h1>
<ul>
<li><a href="extended.html">Atomic Data Extended</a></li>
<li><a href="agents.html">Agents</a></li>
<li><a href="hierarchy.html">Hierarchy and authorization</a></li>
<li><a href="authentication.html">Authentication</a></li>
<li><a href="invitations.html">Invitations and sharing</a></li>
<li><a href="commits/intro.html">Commits (writing data)</a>
<ul>
<li><a href="commits/concepts.html">Concepts</a></li>
<li><a href="commits/compare.html">Compared to</a></li>
</ul>
</li>
<li><a href="websockets.html">WebSockets</a></li>
<li><a href="endpoints.html">Endpoints</a></li>
<li><a href="schema/collections.html">Collections, filtering, sorting</a></li>
<li><a href="files.html">Uploading and downloading files</a></li>
</ul>
<h1 id="using-atomic-data"><a class="header" href="#using-atomic-data">Using Atomic Data</a></h1>
<ul>
<li><a href="interoperability/intro.html">Interoperability and comparisons</a>
<ul>
<li><a href="interoperability/upgrade.html">Making your existing project compatible</a></li>
<li><a href="interoperability/rdf.html">RDF</a></li>
<li><a href="interoperability/solid.html">Solid</a></li>
<li><a href="interoperability/json.html">JSON</a></li>
<li><a href="interoperability/ipfs.html">IPFS</a></li>
<li><a href="interoperability/sql.html">SQL</a></li>
<li><a href="interoperability/graph-database.html">Graph Databases</a></li>
</ul>
</li>
<li><a href="usecases/intro.html">Potential use cases</a>
<ul>
<li><a href="usecases/personal-data-store.html">Personal Data Store</a></li>
<li><a href="usecases/e-commerce.html">E-commerce &amp; marketplaces</a></li>
<li><a href="usecases/surveys.html">Surveys</a></li>
<li><a href="usecases/verifiable-credentials.html">Verifiable Credentials</a></li>
<li><a href="usecases/food-labels.html">Food labels</a></li>
</ul>
</li>
<li><a href="tooling.html"><strong>Software and libraries</strong></a></li>
</ul>
<hr />
<p><a href="acknowledgements.html">Acknowledgements</a>
<a href="newsletter.html">Newsletter</a>
<a href="get-involved.html">Get involved</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motivation-why-atomic-data"><a class="header" href="#motivation-why-atomic-data">Motivation: Why Atomic Data?</a></h1>
<!-- ## Ending the mapping problem

Every time a developer builds an app, they have to define their data model.
Almost every new app has a `User` with a `name` and an `e-mail` field, and so on. -->
<h2 id="give-people-more-control-over-their-data"><a class="header" href="#give-people-more-control-over-their-data">Give people more control over their data</a></h2>
<p>The world wide web was designed by Tim Berners-Lee to be a decentralized network of servers that help people share information.
As I'm writing this, it is exactly 30 years ago that the first website has launched.
Unfortunately, the web today is not the decentralized network it was supposed to be.
A handful of large tech companies are in control of how the internet is evolving, and where and how our data is being stored.
The various services that companies like Google and Microsoft offer (often for free) integrate really well with their other services, but are mostly designed to <em>lock you in</em>.
Vendor lock-in means that it is often difficult to take your information from one app to another.
This limits innovation, and limits users to decide how they want to interact with their data.
Companies often have incentives that are not fully aligned with what users want.
For example, Facebook sorts your newsfeed not to make you satisfied, but to make you spend as much time looking at ads.
They don't want you to be able to control your own newsfeed.
Even companies like Apple, that don't have an ad-revenue model, still have a reason to (and very much do) lock you in.
To make things even worse, even open-source projects made by volunteers often don't work well together.
That's not because of bad intentions, that's because it is <em>hard</em> to make things interoperable.</p>
<p>If we want to change this, we need open tech that works really well together.
And if we want that, we need to <em>standardize</em>.
The existing standards are well-suited for documents and webpages, but not for structured personal data.
If we want to have that, we need to standardize the <em>read-write web</em>, which includes standardizing how items are changed, how their types are checked, how we query lists, and more.
I want all people to have a (virtual) private server that contains their own data, that they control.
This <a href="usecases/personal-data-store.html">Personal Data Store</a> could very well be an old smartphone with a broken screen that is always on, running next to your router.</p>
<p>Atomic Data is designed to be a standard that achieves this.
But we need more than a standard to get adoption - we need implementations.
That's why I've been working on a server, various libraries, a GUI and <a href="tooling.html">more</a> - all MIT licensed.
If Atomic Data will be successful, there will likely be other, better implementations.</p>
<h2 id="linked-data-is-awesome-but-it-is-too-difficult-for-developers-in-its-current-form"><a class="header" href="#linked-data-is-awesome-but-it-is-too-difficult-for-developers-in-its-current-form">Linked data is awesome, but it is too difficult for developers in its current form</a></h2>
<p><a href="https://ontola.io/what-is-linked-data/">Linked data</a> (RDF / the semantic web) enables us to use the web as a large, decentralized graph database.
Using links everywhere in data has amazing merits: links remove ambiguity, they enable exploration, they enable connected datasets.
But the existing specs are too difficult to use, and that is harming adoption.</p>
<p>At my company <a href="https://ontola.io/">Ontola</a>, we've been working with linked data quite intensely for the last couple of years.
We went all-in on RDF, and challenged ourselves to create software that communicates exclusively using it.
That has been an inspiring, but at times also a frustrating journey.
While building our e-democracy platform <a href="https://argu.co/">Argu.co</a>, we had to <a href="https://ontola.io/blog/full-stack-linked-data/">solve many RDF related problems</a>.
How to properly model data in RDF? How to deal with <a href="https://ontola.io/blog/ordered-data-in-rdf/">sequences</a>? How to communicate state changes? Which <a href="https://ontola.io/blog/rdf-serialization-formats/">serialization format</a> to use? How to convert <a href="https://ontola.io/blog/rdf-solid-react-tutorial-link/">RDF to HTML, and build a front-end</a>?
We tackled some of these problems by having a tight grip on the data that we create (e.g. we know the type of data, because we control the resources), and another part is creating new protocols, formats, tools, and libraries.
But it took a long time, and it was hard.
It's been almost 15 years since the <a href="https://www.w3.org/DesignIssues/LinkedData.html">introduction of linked data</a>, and its adoption has been slow.
We know that some of its merits are undeniable, and we truly want the semantic web to succeed.
I believe the lack of growth partially has to do with a lack of tooling, but also with some problems that lie in the RDF data model.</p>
<p>Atomic Data aims to take the best parts from RDF, and learn from the past to make a more developer-friendly, performant and reliable data model to achieve a truly linked web.
Read more about <a href="interoperability/rdf.html">how Atomic Data relates to RDF, and why these changes have been made</a>.</p>
<h2 id="make-it-easier-for-developers-to-build-really-good-interoperable-apps"><a class="header" href="#make-it-easier-for-developers-to-build-really-good-interoperable-apps">Make it easier for developers to build really good, interoperable apps</a></h2>
<p>Every time a developer builds an application, they have to figure a lot of things out.
How to design the API, how to implement forms, how to deal with authentication, authorization, versioning, search...
By having a more complete, strict standard, Atomic Data aims to decrease this burden.
<a href="schema/intro.html">Atomic Schema</a> enables developers to easily share their datamodels, and re-use those from others.
<a href="commits/intro.html">Atomic Commits</a> helps developers to deal with versioning, history, undo and audit logs.
<a href="hierarchy.html">Atomic Hierarchies</a> provides an intuitive model for authorization and access control.
And finally, the <a href="tooling.html">existing</a> open source libraries, server, GUI and templates help developers to have these features without writing them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="when-not-to-use-atomic-data"><a class="header" href="#when-not-to-use-atomic-data">When (not) to use Atomic Data</a></h1>
<h2 id="when-should-you-use-atomic-data"><a class="header" href="#when-should-you-use-atomic-data">When should you use Atomic Data</a></h2>
<ul>
<li><strong>Flexible schemas</strong>. When dealing with structured wikis or semantic data, various instances of things will have different attributes. Atomic Data allows <em>any</em> kind of property on <em>any</em> resource.</li>
<li><strong>Open data</strong>. Atomic Data is a bit harder to create than plain JSON, for example, but it is easier to re-use and understand. It's use of URLs for properties makes data self-documenting.</li>
<li><strong>High interoperability requirements</strong>. When multiple groups of people have to use the same schema, Atomic Data provides easy ways to constrain and validate the data and ensure type safety.</li>
<li><strong>Connected / decentralized data</strong>. With Atomic Data, you use URLs to point to things on other computers. This makes it possible to connect datasets very explicitly, without creating copies. Very useful for decentralized social networks, for example.</li>
<li><strong>Auditability &amp; Versioning</strong>. Using Atomic Commits, we can store all changes to data as transactions that can be replayed. This creates a complete audit log and history.</li>
<li><strong>JSON or RDF as Output</strong>. Atomic Data serializes to idiomatic, clean JSON as well as various RDF formats (Turtle / JSON-LD / n-triples / RDF/XML).</li>
</ul>
<h2 id="when-not-to-use-atomic-data-1"><a class="header" href="#when-not-to-use-atomic-data-1">When not to use Atomic Data</a></h2>
<ul>
<li><strong>Internal use only</strong>. If you're not sharing structured data, Atomic Data will probably only make things harder for you.</li>
<li><strong>Big Data</strong>. If you're dealing with TeraBytes of data, you probably don't want to use Atomic Data. The added cost of schema validation and the lack of distributed / large scale persistence tooling makes it not the right choice.</li>
<li><strong>Video / Audio / 3D</strong>. These should have unique, optimized binary representations and have very strict, static schemas. The advantages of atomic / linked data do little to improve this, unless it's just for metadata.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-atomic-data"><a class="header" href="#what-is-atomic-data">What is Atomic Data?</a></h1>
<h2 id="atomic-data-core"><a class="header" href="#atomic-data-core">Atomic Data Core</a></h2>
<p>Atomic Data is a modular specification for sharing information on the web.
Since Atomic Data is a <em>modular</em> specification, you can mostly take what you want to use, and ignore the rest.
The <em>Core</em> part, however, is the <em>only required</em> part of the specification, as all others depend on it.</p>
<p>Atomic Data Core can be used to express any type of information, including personal data, vocabularies, metadata, documents, files and more.
It's designed to be easily serializable to both JSON and linked data formats.
It is a <em>typed</em> data model, which means that every value must be validated by their datatype.</p>
<h2 id="design-goals"><a class="header" href="#design-goals">Design goals</a></h2>
<ul>
<li><strong>Browsable</strong>: Data should explicitly link to other pieces of data, and these links should be followable.</li>
<li><strong>Semantic</strong>: Every data Atom and relation has a clear semantic meaning.</li>
<li><strong>Interoperable</strong>: Plays nice with other data formats (e.g. JSON, XML, and all RDF formats).</li>
<li><strong>Open</strong>: Free to use, open source, no strings attached.</li>
<li><strong>Clear Ownership</strong>: The data shows who (or which domain) is in control of the data, so new versions of the data can easily be retrieved.</li>
<li><strong>Mergeable</strong>: Any two sets of Atoms can be merged into a single graph without any merge conflicts / name collisions.</li>
<li><strong>Extensible</strong>: Anyone can define their own data types and create Atoms with it.</li>
<li><strong>ORM-friendly</strong>: Navigate a <em>decentralized</em> graph by using <code>dot.syntax</code>, similar to how you navigate a JSON object in javascript.</li>
<li><strong>Type-safe</strong>: All valid Atomic data has an unambiguous, static datatype.</li>
</ul>
<h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<h2 id="resource"><a class="header" href="#resource">Resource</a></h2>
<p>A <em>Resource</em> is a bunch of information about a thing, referenced by a single link (the Subject).
Formally, it is a set of Atoms (i.e. a Graph) that share a Subject URL.
You can think of a Resource as a single row in a spreadsheet or database.
In practice, Resources can be anything - a Person, a Blogpost, a Todo item.
A Resource consists of at least one Atom, so it always has some Property and some Value.
A Property can only occur once in every Resource.</p>
<h2 id="atom-or-atomic-triple"><a class="header" href="#atom-or-atomic-triple">Atom (or Atomic Triple)</a></h2>
<p>Every Resource is composed of <em>Atoms</em>.
The Atom is the smallest possible piece of <em>meaningful</em> data / information (hence the name).
You can think of an Atom as a single cell in a spreadsheet or database.
An Atom consists of three fields:</p>
<ul>
<li><strong><a href="core/concepts.html#subject-field">Subject</a></strong>: the Thing that the atom is providing information about.</li>
<li><strong><a href="core/concepts.html#property-field">Property</a></strong>: the property of the Thing that the atom is about (will always be a URL to a <a href="core/../schema/classes.html#property">Property</a>).</li>
<li><strong><a href="core/concepts.html#value-field">Value</a></strong>: the new piece of information about the Atom.</li>
</ul>
<p>If you're familiar with RDF, you'll notice similarities.
An Atom is comparable with an RDF Triple / Statement (<a href="core/../interoperability/rdf.html">although there are important differences</a>).</p>
<p>Let's turn this sentence into Atoms:</p>
<p><code>Arnold Peters, who's born on the 20th of Januari 1991, has a best friend named Britta Smalls.</code></p>
<table><thead><tr><th>Subject</th><th>Property</th><th>Value</th></tr></thead><tbody>
<tr><td>Arnold</td><td>last name</td><td>Peters</td></tr>
<tr><td>Arnold</td><td>birthdate</td><td>1991-01-20</td></tr>
<tr><td>Arnold</td><td>best friend</td><td>Britta</td></tr>
<tr><td>Britta</td><td>last name</td><td>Smalls</td></tr>
</tbody></table>
<p>The table above shows human readable strings, but in Atomic Data, we use links (URLs) wherever we can.
That's because links are awesome.
Links <strong>remove ambiguity</strong> (we know exactly which person or property we mean), they are <strong>resolvable</strong> (we can click on them), and they are <strong>machine readable</strong> (machines can fetch links to do useful things with them).
So the table from above, will more closely resemble this one:</p>
<table><thead><tr><th>Subject</th><th>Property</th><th>Value</th></tr></thead><tbody>
<tr><td>https://example.com/arnold</td><td>https://example.com/properties/lastname</td><td>Peters</td></tr>
<tr><td>https://example.com/arnold</td><td>https://example.com/properties/birthDate</td><td>1991-01-20</td></tr>
<tr><td>https://example.com/arnold</td><td>https://example.com/properties/bestFriend</td><td>https://example.com/britta</td></tr>
<tr><td>https://example.com/britta</td><td>https://example.com/properties/lastname</td><td>Smalls</td></tr>
</tbody></table>
<p>The standard serialization format for Atomic Data is JSON-AD, which looks like this:</p>
<pre><code class="language-json">[{
  &quot;@id&quot;: &quot;https://example.com/arnold&quot;,
  &quot;https://example.com/properties/lastname&quot;: &quot;Peters&quot;,
  &quot;https://example.com/properties/birthDate&quot;: &quot;1991-01-20&quot;,
  &quot;https://example.com/properties/bestFriend&quot;: &quot;https://example.com/britta&quot;,
},{
  &quot;@id&quot;: &quot;https://example.com/britta&quot;,
  &quot;https://example.com/properties/lastname&quot;: &quot;Smalls&quot;,
}]
</code></pre>
<p>The <code>@id</code> field denotes the Subject of each Resource, which is also the URL that should point to where the resource can be found.</p>
<p>In the JSON-AD example above, we have:</p>
<ul>
<li>two <strong>Resources</strong>, describing two different <strong>Subjects</strong>: <code>https://example.com/arnold</code> and <code>https://example.com/britta</code>.</li>
<li>three different <strong>Properties</strong> (<code>https://example.com/properties/lastname</code>, <code>https://example.com/properties/birthDate</code>, and <code>https://example.com/properties/bestFriend</code>)</li>
<li>four <strong>Values</strong> (<code>Peters</code>, <code>1991-01-20</code>, <code>https://example.com/britta</code> and <code>Smalls</code>)</li>
<li>four <strong>Atoms</strong> - every row is one Atom.</li>
</ul>
<p>All Subjects and Properties are Atomic URLs: they are links that point to more Atomic Data.
One of the Values is a URL, too, but we also have values like <code>Arnold</code> and <code>1991-01-20</code>.
Values can have different <em>Datatypes</em>
In most other data formats, the datatypes are limited and are visually distinct.
JSON, for example, has <code>array</code>, <code>object</code>, <code>string</code>, <code>number</code> and <code>boolean</code>.
In Atomic Data, however, datatypes are defined somewhere else, and are extendible.
To find the Datatype of an Atom, you fetch the Property, and that Property will have a Datatype.
For example, the <code>https://example.com/properties/bornAt</code> Property requires an ISO Date string, and the <code>https://example.com/properties/firstName</code> Property requires a regular string.
This might seem a little tedious and weird at first, but is has some nice advantages!
Their Datatypes are defined in the Properties.</p>
<h2 id="subject-field"><a class="header" href="#subject-field">Subject field</a></h2>
<p>The Subject field is the first part of an Atom.
It is the identifier that the rest of the Atom is providing information about.
The Subject field is a URL that points to the Resource.
The creator of the Subject MUST make sure that it resolves.
In other words: following / downloading the Subject link will provide you with all the Atoms about the Subject (see <a href="core/querying.html">Querying Atomic Data</a>.
This also means that the creator of a Resource must make sure that it is available at its URL - probably by hosting the data, or by using some service that hosts it.
In JSON-AD, the Subject is denoted by <code>@id</code>.</p>
<h2 id="property-field"><a class="header" href="#property-field">Property field</a></h2>
<p>The Property field is the second part of an Atom.
It is a URL that points to an Atomic <a href="core/../schema/classes.html#Property">Property</a>.
For example <code>https://example.com/createdAt</code> or <code>https://example.com/firstName</code>.</p>
<!-- Making this a requirement is what makes Atomic Data typed and semantic -->
<p>The Property field MUST be a URL, and that URL MUST resolve to an Atomic Property, which contains information about the Datatype.</p>
<h2 id="value-field"><a class="header" href="#value-field">Value field</a></h2>
<p>The Value field is the third part of an Atom.
In RDF, this is called an <code>object</code>.
Contrary to the Subject and Property values, the Value can be of any datatype.
This includes URLs, strings, integers, dates and more.</p>
<h2 id="graph"><a class="header" href="#graph">Graph</a></h2>
<p>A Graph is a collection of Atoms.
A Graph can describe various subjects, and may or may not be related.
Graphs can have several characteristics (Schema Complete, Valid, Closed)</p>
<p>In mathematial graph terminology, a graph consists of <em>nodes</em> and <em>edges</em>.
The Atomic Data model is a so called <em>directed graph</em>, which means that relationships are by default one-way.
In Atomic Data, every node is a <code>Resource</code>, and every edge is a <code>Property</code>.</p>
<h2 id="nested-resource"><a class="header" href="#nested-resource">Nested Resource</a></h2>
<p>A Nested Resource only exists inside of another resource.
It does not have its own subject.</p>
<p>In the next chapter, we'll explore how Atomic Data is serialized.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialization-of-atomic-data"><a class="header" href="#serialization-of-atomic-data">Serialization of Atomic Data</a></h1>
<p>Atomic Data is not necessarily bound to a single serialization format.
It's fundamentally a data model, and that's an important distinction to make.
It can be serialized in different ways, but there is only one required: <code>JSON-AD</code>.</p>
<h2 id="json-ad"><a class="header" href="#json-ad">JSON-AD</a></h2>
<p><a href="core/json-ad.html"><code>JSON-AD</code></a> (more about that on the next page) is specifically designed to be a simple, complete and performant format for Atomic Data.</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://atomicdata.dev/properties/description&quot;,
  &quot;https://atomicdata.dev/properties/datatype&quot;: &quot;https://atomicdata.dev/datatypes/markdown&quot;,
  &quot;https://atomicdata.dev/properties/description&quot;: &quot;A textual description of something. When making a description, make sure that the first few words tell the most important part. Give examples. Since the text supports markdown, you're free to use links and more.&quot;,
  &quot;https://atomicdata.dev/properties/isA&quot;: [
    &quot;https://atomicdata.dev/classes/Property&quot;
  ],
  &quot;https://atomicdata.dev/properties/parent&quot;: &quot;https://atomicdata.dev/properties&quot;,
  &quot;https://atomicdata.dev/properties/shortname&quot;: &quot;description&quot;
}
</code></pre>
<p><a href="core/json-ad.html">Read more about JSON-AD</a></p>
<h2 id="json-simple"><a class="header" href="#json-simple">JSON (simple)</a></h2>
<p>Atomic Data is designed to be serializable to clean, simple <a href="core/../interoperability/json.html">JSON</a>, for usage in (client) apps that don't need to know the full URLs of properties.</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://atomicdata.dev/properties/description&quot;,
  &quot;datatype&quot;: &quot;https://atomicdata.dev/datatypes/markdown&quot;,
  &quot;description&quot;: &quot;A textual description of something. When making a description, make sure that the first few words tell the most important part. Give examples. Since the text supports markdown, you're free to use links and more.&quot;,
  &quot;is-a&quot;: [
    &quot;https://atomicdata.dev/classes/Property&quot;
  ],
  &quot;parent&quot;: &quot;https://atomicdata.dev/properties&quot;,
  &quot;shortname&quot;: &quot;description&quot;
}
</code></pre>
<p><a href="core/json-ad.html">Read more about JSON and Atomic Data</a></p>
<h2 id="rdf-serialization-formats"><a class="header" href="#rdf-serialization-formats">RDF serialization formats</a></h2>
<p>Since Atomic Data is a strict subset of RDF, RDF serialization formats can be used to communicate and store Atomic Data, such as N-Triples, Turtle, HexTuples, JSON-LD and <a href="https://ontola.io/blog/rdf-serialization-formats/">other RDF serialization formats</a>.
However, not all valid RDF is valid Atomic Data.
Atomic Data is more strict.
Read more about serializing Atomic Data to RDF in the <a href="core/../interoperability/rdf.html">RDF interoperability section</a>.</p>
<p>JSON-LD:</p>
<pre><code class="language-json">{
  &quot;@context&quot;: {
    &quot;datatype&quot;: {
      &quot;@id&quot;: &quot;https://atomicdata.dev/properties/datatype&quot;,
      &quot;@type&quot;: &quot;@id&quot;
    },
    &quot;description&quot;: &quot;https://atomicdata.dev/properties/description&quot;,
    &quot;is-a&quot;: {
      &quot;@container&quot;: &quot;@list&quot;,
      &quot;@id&quot;: &quot;https://atomicdata.dev/properties/isA&quot;
    },
    &quot;parent&quot;: {
      &quot;@id&quot;: &quot;https://atomicdata.dev/properties/parent&quot;,
      &quot;@type&quot;: &quot;@id&quot;
    },
    &quot;shortname&quot;: &quot;https://atomicdata.dev/properties/shortname&quot;
  },
  &quot;@id&quot;: &quot;https://atomicdata.dev/properties/description&quot;,
  &quot;datatype&quot;: &quot;https://atomicdata.dev/datatypes/markdown&quot;,
  &quot;description&quot;: &quot;A textual description of something. When making a description, make sure that the first few words tell the most important part. Give examples. Since the text supports markdown, you're free to use links and more.&quot;,
  &quot;is-a&quot;: [
    &quot;https://atomicdata.dev/classes/Property&quot;
  ],
  &quot;parent&quot;: &quot;https://atomicdata.dev/properties&quot;,
  &quot;shortname&quot;: &quot;description&quot;
}
</code></pre>
<p>Turtle / N-Triples:</p>
<pre><code class="language-turtle">&lt;https://atomicdata.dev/properties/description&gt; &lt;https://atomicdata.dev/properties/datatype&gt; &lt;https://atomicdata.dev/datatypes/markdown&gt; .
&lt;https://atomicdata.dev/properties/description&gt; &lt;https://atomicdata.dev/properties/parent&gt; &lt;https://atomicdata.dev/properties&gt; .
&lt;https://atomicdata.dev/properties/description&gt; &lt;https://atomicdata.dev/properties/shortname&gt; &quot;description&quot;^^&lt;https://atomicdata.dev/datatypes/slug&gt; .
&lt;https://atomicdata.dev/properties/description&gt; &lt;https://atomicdata.dev/properties/isA&gt; &quot;https://atomicdata.dev/classes/Property&quot;^^&lt;https://atomicdata.dev/datatypes/resourceArray&gt; .
&lt;https://atomicdata.dev/properties/description&gt; &lt;https://atomicdata.dev/properties/description&gt; &quot;A textual description of something. When making a description, make sure that the first few words tell the most important part. Give examples. Since the text supports markdown, you're free to use links and more.&quot;^^&lt;https://atomicdata.dev/datatypes/markdown&gt; .
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-ad-the-atomic-data-serialization-format"><a class="header" href="#json-ad-the-atomic-data-serialization-format">JSON-AD: The Atomic Data serialization format</a></h1>
<p>Although you can use various serialization formats for Atomic Data, <code>JSON-AD</code> is the <em>default</em> and <em>only required</em> serialization format.
It is what the current <a href="https://github.com/joepio/atomic">Rust</a> and <a href="https://github.com/joepio/atomic-data-browser">Typescript / React</a> implementations use to communicate.
It is designed to feel familiar to developers and to be easy and performant to parse and serialize.
It is inspired by <a href="https://json-ld.org/">JSON-LD</a>.</p>
<p>It uses <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">JSON</a>, but has some additional constraints:</p>
<ul>
<li>Every single Object is a <code>Resource</code>.</li>
<li>Every Key is a <a href="https://atomicdata.dev/classes/Property"><code>Property</code></a> URL. Other keys are invalid. Each Property URL must resolve to an online Atomic Data Property.</li>
<li>The <code>@id</code> field is special: it defines the <code>Subject</code> of the <code>Resource</code>. If you send an HTTP GET request there with an <code>content-type: application/ad+json</code> header, you should get the full JSON-AD resource.</li>
<li>JSON arrays are mapped to <a href="https://atomicdata.dev/datatypes/resourceArray">Resource Arrays</a></li>
<li>Numbers can be <a href="https://atomicdata.dev/datatypes/integer">Integers</a>, <a href="https://atomicdata.dev/datatypes/timestamp">Timestamps</a> or <a href="https://atomicdata.dev/datatypes/float">Floats</a>.</li>
<li>JSON booleans map to <a href="https://atomicdata.dev/datatypes/boolean">Booleans</a>.</li>
<li>JSON strings can be many datatypes, including <a href="https://atomicdata.dev/datatypes/string">String</a>, <a href="https://atomicdata.dev/datatypes/markdown">Markdown</a>, <a href="https://atomicdata.dev/datatypes/date">Date</a> or other.</li>
<li>Nested JSON Objects are Nested Resources. A Nested Resource can either be <em>Anonymous</em> (without an <code>@id</code> subject) or a Named Nested Resource (with an <code>@id</code> subject). Everywhere a Subject URL can be used as a value (i.e. all properties with the datatype <a href="https://atomicdata.dev/datatypes/atomicURL">atomicURL</a>), a Nested Resource can be used instead. This also means that an item in an <code>ResourceArray</code> can be a Nested Resource.</li>
<li>The root data structure must either be a Named Resource (with an <code>@id</code>), or an Array containing Named Resources. When you want to describe multiple Resources in one JSON-AD document, use an array as the root item.</li>
</ul>
<p>Let's look at an example JSON-AD Resource:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://atomicdata.dev/properties/description&quot;,
  &quot;https://atomicdata.dev/properties/datatype&quot;: &quot;https://atomicdata.dev/datatypes/markdown&quot;,
  &quot;https://atomicdata.dev/properties/description&quot;: &quot;A textual description of something. When making a description, make sure that the first few words tell the most important part. Give examples. Since the text supports markdown, you're free to use links and more.&quot;,
  &quot;https://atomicdata.dev/properties/isA&quot;: [
    &quot;https://atomicdata.dev/classes/Property&quot;
  ],
  &quot;https://atomicdata.dev/properties/shortname&quot;: &quot;description&quot;
}
</code></pre>
<p>The mime type (for HTTP content negotiation) is <code>application/ad+json</code> (<a href="https://github.com/ontola/atomic-data-docs/issues/60">registration ongoing</a>).</p>
<h2 id="nested-anonymous-and-named-resources"><a class="header" href="#nested-anonymous-and-named-resources">Nested, Anonymous and Named resources</a></h2>
<p>In JSON-AD, a Resource can be respresented in multiple ways:</p>
<ul>
<li><strong>Subject</strong>: A URL string, such as <code>https://atomicdata.dev/classes/Class</code>.</li>
<li><strong>Named Resource</strong>: A JSON Object with an <code>@id</code> field containing the Subject.</li>
<li><strong>Anonymous Nested Resource</strong> A JSON Object without an <code>@id</code> field. This is only possible if it is a Nested Resource, which means that it has a parent Resource.</li>
</ul>
<p>Note that this is also valid for <code>ResourceArrays</code>, which usually only contain Subjects, but are allowed to contain Nested Resources.</p>
<p>In the following JSON-AD example, the <code>address</code> is a nested resource:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/arnold&quot;,
  &quot;https://example.com/properties/address&quot;: {
    &quot;https://example.com/properties/firstLine&quot;: &quot;Longstreet 22&quot;,
    &quot;https://example.com/properties/city&quot;: &quot;Watertown&quot;,
    &quot;https://example.com/properties/country&quot;: &quot;the Netherlands&quot;,
  }
}
</code></pre>
<p>Nested Resources can be <em>named</em> or <em>anonymous</em>. An <em>Anonymous Nested Resource</em> does not have it's own <code>@id</code> field.
It <em>does</em> have its own unique <a href="core/./paths.html">path</a>, which can be used as its identifier.
The <code>path</code> of the anonymous resource in the example above is <code>https://example.com/arnold https://example.com/properties/address</code>.</p>
<h2 id="json-ad-parsers-serializers-and-other-libraries"><a class="header" href="#json-ad-parsers-serializers-and-other-libraries">JSON-AD Parsers, serializers and other libraries</a></h2>
<ul>
<li><strong>Typescript / Javacript</strong>: <a href="https://www.npmjs.com/package/@tomic/lib">@tomic/lib</a> JSON-AD parser + in-memory store. Works with <a href="https://www.npmjs.com/package/@tomic/lib">@tomic/react</a> for rendering Atomic Data in React.</li>
<li><strong>Rust</strong>: <a href="https://crates.io/crates/atomic_lib">atomic_lib</a> has a JSON-AD parser / serializer (and does a lot more).</li>
</ul>
<h2 id="canonicalized-json-ad"><a class="header" href="#canonicalized-json-ad">Canonicalized JSON-AD</a></h2>
<p>When you need deterministic serialization of Atomic Data (e.g. when calculating a cryptographic hash or signature, used in Atomic Commits), you can use the following procedure:</p>
<ol>
<li>Serialize your Resource to JSON-AD</li>
<li>Do not include empty objects, empty arrays or null values.</li>
<li>All keys are sorted alphabetically (lexicographically) - both in the root object, as in any nested objects.</li>
<li>The JSON-AD is minified: no newlines, no spaces.</li>
</ol>
<p>The last two steps of this process is more formally defined by the JSON Canonicalization Scheme (JCS, <a href="https://tools.ietf.org/html/rfc8785">rfc8785</a>).</p>
<h2 id="interoperability-with-json-and-json-ld"><a class="header" href="#interoperability-with-json-and-json-ld">Interoperability with JSON and JSON-LD</a></h2>
<p><a href="core/../interoperability/json.html">Read more about this subject</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="querying-atomic-data"><a class="header" href="#querying-atomic-data">Querying Atomic Data</a></h1>
<p>There are multiple ways of getting Atomic Data into some system:</p>
<ul>
<li><a href="core/querying.html#subject-fetching-http"><strong>Subject Fetching</strong></a> requests a single subject right from its source</li>
<li><a href="core/../schema/collections.html"><strong>Atomic Collections</strong></a> can filter, sort and paginate resources</li>
<li><a href="core/paths.html"><strong>Atomic Paths</strong></a> is a simple way to traverse Atomic Graphs and target specific values</li>
<li><a href="core/querying.html#triple-pattern-fragments"><strong>Triple Pattern Fragments</strong></a> allows querying for specific (combinations of) Subject, Property and Value.</li>
<li><a href="core/querying.html#SPARQL"><strong>SPARQL</strong></a> is a powerful Query language for traversing linked data graphs</li>
</ul>
<h2 id="subject-fetching-http"><a class="header" href="#subject-fetching-http">Subject fetching (HTTP)</a></h2>
<p>The simplest way of getting Atomic Data when the Subject is an HTTP URL, is by sending a GET request to the subject URL.
Set the <code>Content-Type</code> header to an Atomic Data compatible mime type, such as <code>application/ad+json</code>.</p>
<pre><code class="language-HTTP">GET https://atomicdata.dev/test HTTP/1.1
Content-Type: application/ad+json
</code></pre>
<p>The server SHOULD respond with all the Atoms of which the requested URL is the subject:</p>
<pre><code class="language-HTTP">HTTP/1.1 200 OK
Content-Type: application/ad+json
Connection: Closed

{
  &quot;@id&quot;: &quot;https://atomicdata.dev/test&quot;,
  &quot;https://atomicdata.dev/properties/shortname&quot;: &quot;1611489928&quot;
}
</code></pre>
<p>The server MAY also include other resources, if they are deemed relevant.</p>
<h2 id="atomic-collections"><a class="header" href="#atomic-collections">Atomic Collections</a></h2>
<p>Collections are Resources that provide simple query options, such as filtering by Property or Value, and sorting.
They also paginate resources.
Under the hood, Collections are powered by Triple Pattern Fragments.
Use query parameters to traverse pages, filter, or sort.</p>
<p><a href="core/../schema/collections.html">Read more about Collections</a></p>
<h2 id="atomic-paths"><a class="header" href="#atomic-paths">Atomic Paths</a></h2>
<p>An Atomic Path is a string that consist of one or more URLs, which when traversed point to an item.</p>
<p><a href="core/paths.html">Read more about Atomic Paths</a></p>
<h2 id="triple-pattern-fragments"><a class="header" href="#triple-pattern-fragments">Triple Pattern Fragments</a></h2>
<p><a href="https://linkeddatafragments.org/specification/triple-pattern-fragments/">Triple Pattern Fragments</a> (TPF) is an interface for querying RDF.
It works great for Atomic Data as well.</p>
<p>An HTTP implementation of a TPF endpoint might accept a GET request to a URL such as this:</p>
<p><code>http://example.org/tpf?subject={subject}&amp;property={property}&amp;value={value}</code></p>
<p>Make sure to URL encode the <code>subject</code>, <code>property</code>, <code>value</code> strings.</p>
<p>For example, let's search for all Atoms where the value is <code>test</code>.</p>
<pre><code class="language-HTTP">GET https://atomicdata.dev/tpf?value=0 HTTP/1.1
Content-Type: text/turtle
</code></pre>
<p>This is the HTTP response:</p>
<pre><code class="language-HTTP">HTTP/1.1 200 OK
Content-Type: text/turtle
Connection: Closed

&lt;https://atomicdata.dev/agents&gt; &lt;https://atomicdata.dev/properties/collection/currentPage&gt; &quot;0&quot;^^&lt;https://atomicdata.dev/datatypes/integer&gt; .
</code></pre>
<h2 id="sparql"><a class="header" href="#sparql">SPARQL</a></h2>
<p><a href="https://www.w3.org/TR/rdf-sparql-query/">SPARQL</a> is a powerful RDF query language.
Since all Atomic Data is also valid RDF, it should be possible to query Atomic Data using SPARQL.
None of the exsisting implementations support a SPARQL endpoint, though.</p>
<ul>
<li>Convert / serialize Atomic Data to RDF (for example by using the <code>/tpf</code> endpoint and an <code>accept</code> header: <code>curl -i -H &quot;Accept: text/turtle&quot; &quot;https://atomicdata.dev/tpf&quot;</code>)</li>
<li>Load it into a SPARQL engine of your choice</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-paths-1"><a class="header" href="#atomic-paths-1">Atomic Paths</a></h1>
<p>An Atomic Path is a string that consists of at least one URL, followed by one or more URLs or Shortnames.
Every single value in an Atomic Resource can be targeted through such a Path.
They can be used as identifiers for specific Values.</p>
<p>The simplest path, is the URL of a resource, which represents the entire Resource with all its properties.
If you want to target a specific atom, you can use an Atomic Path with a second URL.
This second URL can be replaced by a Shortname, if the Resource is an instance of a class which has properties with that Shortname (sounds more complicated than it is).</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Let's start with this simple Resource:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/john&quot;,
  &quot;https://example.com/lastName&quot;: &quot;McLovin&quot;,
}
</code></pre>
<p>Then the following Path targets the <code>McLovin</code> value:</p>
<p><code>https://example.com/john https://example.com/lastName</code> =&gt; <code>McLovin</code></p>
<p>Instead of using the full URL of the <code>lastName</code> Property, we can use its <a href="https://atomicdata.dev/properties/shortname">shortname</a>:</p>
<p><code>https://example.com/john lastname</code> =&gt; <code>McLovin</code></p>
<p>We can also traverse relationships between resources:</p>
<pre><code class="language-json">[{
  &quot;@id&quot;: &quot;https://example.com/john&quot;,
  &quot;https://example.com/lastName&quot;: &quot;McLovin&quot;,
  &quot;https://example.com/employer&quot;: &quot;https://example.com/XCorp&quot;,
},{
  &quot;@id&quot;: &quot;https://example.com/XCorp&quot;,
  &quot;https://example.com/description&quot;: &quot;The greatest company!&quot;,
}]
</code></pre>
<p><code>https://example.com/john employer description</code> =&gt; <code>The greatest company!</code></p>
<p>In the example above, the XCorp subject exists and is the source of the <code>The greatest company!</code> value.
We can use this path as a unique identifier for the description of John's current employer.
Note that the data for the description of that employer does not have to be in John's control for this path to work - it can live on a totally different server.
However, in Atomic Data it's also possible to include this description in the resource of John as a <em>Nested Resource</em>.</p>
<h2 id="nested-resources"><a class="header" href="#nested-resources">Nested Resources</a></h2>
<p>All Atomic Data Resources that we've discussed so far have an explicit URL as a subject.
Unfortunately, creating unique and resolvable URLs can be a bother, and sometimes not necessary.
If you've worked with RDF, this is what Blank Nodes are used for.
In Atomic Data, we have something similar: <em>Nested Resources</em>.</p>
<p>Let's use a Nested Resource in the example from the previous section:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/john&quot;,
  &quot;https://example.com/lastName&quot;: &quot;McLovin&quot;,
  &quot;https://example.com/employer&quot;: {
    &quot;https://example.com/description&quot;: &quot;The greatest company!&quot;,
  }
}
</code></pre>
<p>Now the <code>employer</code> is simply a nested Object.
Note that it no longer has its own <code>@id</code>.
However, we can still identify this Nested Resource using its Path.</p>
<p>The Subject of the nested resource is its path: <code>https://example.com/john https://example.com/employer</code>, including the spacebar.</p>
<p>Note that the path from before still resolves:</p>
<p><code>https://example.com/john employer description</code> =&gt; <code>The greatest company!</code></p>
<h2 id="traversing-arrays"><a class="header" href="#traversing-arrays">Traversing Arrays</a></h2>
<p>We can also navigate Arrays using paths.</p>
<p>For example:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/john&quot;,
  &quot;hasShoes&quot;: [
    {
      &quot;https://example.com/name&quot;: &quot;Mr. Boot&quot;,
    },
    {
      &quot;https://example.com/name&quot;: &quot;Sunny Sandals&quot;,
    }
  ]
}
</code></pre>
<p>The Path of <code>Mr. Boot</code> is:</p>
<pre><code>https://example.com/john hasShoes 0 name
</code></pre>
<p>You can target an item in an array by using a number to indicate its position, starting with 0.</p>
<p>Notice how the Resource with the <code>name: Mr. Boot</code> does not have an explicit <code>@id</code>, but it <em>does</em> have a Path.
This means that we still have a unique, globally resolvable identifier - yay!</p>
<h2 id="try-for-yourself"><a class="header" href="#try-for-yourself">Try for yourself</a></h2>
<p>Install the <a href="https://github.com/joepio/atomic/blob/master/cli/README.md"><code>atomic-cli</code></a> software and run <code>atomic-cli get https://atomicdata.dev/classes/Class description</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-schema"><a class="header" href="#atomic-schema">Atomic Schema</a></h1>
<p>Atomic Schema is the proposed standard for specifying classes, properties and datatypes in Atomic Data.
You can compare it to UML diagrams, or what XSD is for XML.
Atomic Schema deals with validating and constraining the shape of data.
It is designed for checking if all the required properties are present, and whether the values conform to the datatype requirements (e.g. <code>datetime</code>, or <code>URL</code>).</p>
<p>This section will define various Classes, Properties and Datatypes (discussed in <a href="schema/../core/concepts.html">Atomic Core: Concepts</a>).</p>
<h2 id="design-goals-1"><a class="header" href="#design-goals-1">Design Goals</a></h2>
<ul>
<li><strong>Decentralized</strong>: Classes and Properties can be defined in external systems, and are resolved using web protocols such as HTTP.</li>
<li><strong>Typed</strong>: Every Atom of data has a clear datatype. Validated data should be highly predictable.</li>
<li><strong>IDE-friendly</strong>: Although Atomic Schema uses many URLs, users / developers should not have to type full URLs. The schema uses shortnames as aliases.</li>
<li><strong>Self-documenting</strong>: When seeing a piece of data, simply following links will explain you how the data model is to be understood. This removes the need for (most of) existing API documentation.</li>
<li><strong>Extensible</strong>: Anybody can create their own Datatypes, Properties and Classes.</li>
<li><strong>Accessible</strong>: Support for languages, easily translatable. Useful for humans and machines.</li>
<li><strong>Atomic</strong>: All the design goals of Atomic Data itself also apply here. Atomic Schema is defined using Atomic Data.</li>
</ul>
<h2 id="in-short"><a class="header" href="#in-short">In short</a></h2>
<p>In short, Atomic Schema works like this:</p>
<p>The Property <em>field</em> in an Atom, or the <em>key</em> in a JSON-AD object, links to a <strong>Property <em>Resource</em></strong>.
It is important that the URL to the Property Resource resolves, as others can re-use it and check its datatype.
This Property does three things:</p>
<ol>
<li>it links to a <strong>Datatype</strong> which indicates which Value is acceptable.</li>
<li>it has a <strong>description</strong> which tells you what the property means, what the relationship between the Subject and the Value means.</li>
<li>it provides a <strong>Shortname</strong>, which is sometimes used as an alternative to the full URL of the Property.</li>
</ol>
<p><strong>DataTypes</strong> define the shape of the Value, e.g. a Number (<code>124</code>) or Boolean (<code>true</code>).</p>
<p><strong>Classes</strong> are a special kind of Resource that describe an abstract class of things (such as &quot;Person&quot; or &quot;Blog&quot;).
Classes can <em>recommend</em> or <em>require</em> a set of Properties.
They behave as Models, similar to <code>struts</code> in C or <code>interfaces</code> in Typescript.
A Resource <em>could</em> have one or more classes, which <em>could</em> provide information about which Properties are expected or required.</p>
<p><strong>example:</strong></p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://atomicdata.dev/classes/Agent&quot;,
  &quot;https://atomicdata.dev/properties/description&quot;: &quot;An Agent is a user that can create or modify data. It has two keys: a private and a public one. The private key should be kept secret. The public key is used to verify signatures (on [Commits](https://atomicdata.dev/classes/Commit)) set by the of the Agent.&quot;,
  &quot;https://atomicdata.dev/properties/isA&quot;: [
    &quot;https://atomicdata.dev/classes/Class&quot;
  ],
  &quot;https://atomicdata.dev/properties/recommends&quot;: [
    &quot;https://atomicdata.dev/properties/name&quot;,
    &quot;https://atomicdata.dev/properties/description&quot;
  ],
  &quot;https://atomicdata.dev/properties/requires&quot;: [
    &quot;https://atomicdata.dev/properties/publicKey&quot;
  ],
  &quot;https://atomicdata.dev/properties/shortname&quot;: &quot;agent&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-schema-classes"><a class="header" href="#atomic-schema-classes">Atomic Schema: Classes</a></h1>
<p>The following Classes are some of the most fundamental concepts in Atomic Data, as they make data validation possible.</p>
<p>Click the URLs of the classes to read the most actual data, and discover their properties!</p>
<h2 id="property"><a class="header" href="#property">Property</a></h2>
<p><em>URL: <a href="https://atomicdata.dev/classes/Property"><code>https://atomicdata.dev/classes/Property</code></a></em></p>
<p>The Property class.
The thing that the Property field should link to.
A Property is an abstract type of Resource that describes the relation between a Subject and a Value.
A Property provides some semantic information about the relationship (in its <code>description</code>), it provides a shorthand (the <code>shortname</code>) and it links to a Datatype.</p>
<p>Properties of a Property instance:</p>
<ul>
<li><a href="https://atomicdata.dev/properties/shortname"><code>shortname</code></a> - (required, Slug) the shortname for the property, used in ORM-style dot syntax (<code>thing.property.anotherproperty</code>).</li>
<li><a href="https://atomicdata.dev/properties/description"><code>description</code></a> - (optional, AtomicURL, TranslationBox) the semantic meaning of the.</li>
<li><a href="https://atomicdata.dev/properties/datatype"><code>datatype</code></a> - (required, AtomicURL, Datatype) a URL to an Atomic Datatype, which defines what the datatype should be of the Value in an Atom where the Property is the</li>
<li><a href="https://atomicdata.dev/properties/classtype"><code>classtype</code></a> - (optional, AtomicURL, Class) if the <code>datatype</code> is an Atomic URL, the <code>classtype</code> defines which class(es?) is (are?) acceptable.</li>
</ul>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://atomicdata.dev/properties/description&quot;,
  &quot;https://atomicdata.dev/properties/datatype&quot;: &quot;https://atomicdata.dev/datatypes/markdown&quot;,
  &quot;https://atomicdata.dev/properties/description&quot;: &quot;A textual description of something. When making a description, make sure that the first few words tell the most important part. Give examples. Since the text supports markdown, you're free to use links and more.&quot;,
  &quot;https://atomicdata.dev/properties/isA&quot;: [
    &quot;https://atomicdata.dev/classes/Property&quot;
  ],
  &quot;https://atomicdata.dev/properties/shortname&quot;: &quot;description&quot;
}
</code></pre>
<p>Visit https://atomicdata.dev/collections/property for a list of example Properties.</p>
<h2 id="datatype"><a class="header" href="#datatype">Datatype</a></h2>
<p><em>URL: <a href="https://atomicdata.dev/classes/Datatype"><code>https://atomicdata.dev/classes/Datatype</code></a></em></p>
<p>A Datatype specifies how a <code>Value</code> value should be interpreted.
Datatypes are concepts such as <code>boolean</code>, <code>string</code>, <code>integer</code>.
Since DataTypes can be linked to, you dan define your own.
However, using non-standard datatypes limits how many applications will know what to do with the data.</p>
<p>Properties:</p>
<ul>
<li><code>description</code> - (required, AtomicURL, TranslationBox) how the datatype functions.</li>
<li><code>stringSerialization</code> - (required, AtomicURL, TranslationBox) how the datatype should be parsed / serialized as an UTF-8 string</li>
<li><code>stringExample</code> - (required, string) an example <code>stringSerialization</code> that should be parsed correctly</li>
<li><code>binarySerialization</code> - (optional, AtomicURL, TranslationBox) how the datatype should be parsed / serialized as a byte array.</li>
<li><code>binaryExample</code> - (optional, string) an example <code>binarySerialization</code> that should be parsed correctly. Should have the same contents as the stringExample. Required if binarySerialization is present on the DataType.</li>
</ul>
<p>Visit https://atomicdata.dev/collections/datatype for a list of example Datatypes.</p>
<h2 id="class"><a class="header" href="#class">Class</a></h2>
<p><em>URL: <a href="https://atomicdata.dev/classes/Class"><code>https://atomicdata.dev/classes/Class</code></a></em></p>
<p>A Class is an abstract type of Resource, such as <code>Person</code>.
It is convention to use an Uppercase in its URI.
Note that in Atomic Data, a Resource can have several Classes - not just a single one.
If you need to set more complex constraints to your Classes (e.g. maximum string length, Properties that depend on each other), check out <a href="https://www.w3.org/TR/shacl/">SHACL</a>.</p>
<p>Properties:</p>
<ul>
<li><code>shortname</code> - (required, Slug) a short string shorthand.</li>
<li><code>description</code> - (required, AtomicURL, TranslationBox) human readable explanation of what the Class represents.</li>
<li><code>requires</code> - (optional, ResourceArray, Property) a list of Properties that are required. If absent, none are required. These SHOULD have unique shortnames.</li>
<li><code>recommends</code> - (optional, ResourceArray, Property) a list of Properties that are recommended. These SHOULD have unique shortnames.</li>
</ul>
<!-- - `deprecatedProperties` - (optional, ResourceArray, Property) - a list of Properties that should no longer be used. -->
<!-- Maybe remove this next one? -->
<!-- - `disallowedProperties` - (optional, ResourceArray) a list of Properties that are not allowed.  If absent, all are allowed. -->
<!-- What are the consequences of this? How to deal with this field if there are more classes in aSSubject? -->
<!-- - `allowedProperties` - (optional, ResourceArray) a list of Properties that are allowed. If absent, none are required. -->
<p>A resource indicates it is an <em>instance</em> of that class by adding a <code>https://atomicdata.dev/properties/isA</code> Atom.</p>
<p>Example:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://atomicdata.dev/classes/Class&quot;,
  &quot;https://atomicdata.dev/properties/description&quot;: &quot;A Class describes an abstract concept, such as 'Person' or 'Blogpost'. It describes the data shape of data and explains what the thing represents. It is convention to use Uppercase in its URL. Note that in Atomic Data, a Resource can have several Classes - not just a single one.&quot;,
  &quot;https://atomicdata.dev/properties/isA&quot;: [
    &quot;https://atomicdata.dev/classes/Class&quot;
  ],
  &quot;https://atomicdata.dev/properties/recommends&quot;: [
    &quot;https://atomicdata.dev/properties/recommends&quot;,
    &quot;https://atomicdata.dev/properties/requires&quot;
  ],
  &quot;https://atomicdata.dev/properties/requires&quot;: [
    &quot;https://atomicdata.dev/properties/shortname&quot;,
    &quot;https://atomicdata.dev/properties/description&quot;
  ],
  &quot;https://atomicdata.dev/properties/shortname&quot;: &quot;class&quot;
}
</code></pre>
<p>Visit https://atomicdata.dev/collections/class for the a list of example Classes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-schema-datatypes"><a class="header" href="#atomic-schema-datatypes">Atomic Schema: Datatypes</a></h1>
<p>The Atomic Datatypes consist of some of the most commonly used <a href="schema/classes.html#Datatype">Datatypes</a>.</p>
<p><em>Note: Please visit <a href="https://atomicdata.dev/datatypes">https://atomicdata.dev/datatypes</a> for the latest list of official Datatypes.</em></p>
<h2 id="slug"><a class="header" href="#slug">Slug</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/slug</code></em></p>
<p>A string with a limited set of allowed characters, used in IDE / Text editor context.
Only letters, numbers and dashes are allowed.</p>
<p>Regex: <code>^[a-z0-9]+(?:-[a-z0-9]+)*$</code></p>
<h2 id="atomic-url"><a class="header" href="#atomic-url">Atomic URL</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/atomicURL</code></em></p>
<p>A URL that should resolve to an <a href="schema/../core/concepts.html#Resource">Atomic Resource</a>.</p>
<h2 id="uri"><a class="header" href="#uri">URI</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/URI</code></em></p>
<p>A Uniform Resource Identifier, preferably a URL (i.e. an URI that can be fetched).
Could be HTTP, HTTPS, or any other type of schema.</p>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/string</code></em></p>
<p>UTF-8 String, no max character count.
Newlines use backslash escaped <code>\n</code> characters.
Should not contain language specific data, use a <a href="schema/translations.html">TranslationBox</a> instead.</p>
<p>e.g. <code>String time! \n Second line!</code></p>
<h2 id="markdown"><a class="header" href="#markdown">Markdown</a></h2>
<p><em>URL: <code>https://https://atomicdata.dev/datatypes/markdown</code></em></p>
<p>A markdown string, using the <a href="https://commonmark.org/">CommonMark syntax</a>.
UTF-8 formatted, no max character count, newlines are <code>\n</code>.</p>
<p>e.g.</p>
<pre><code class="language-md"># Heading

Paragraph with [link](https://example.com).
</code></pre>
<h2 id="integer"><a class="header" href="#integer">Integer</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/integer</code></em></p>
<p>Signed Integer, max 64 bit.
Max value: <a href="https://en.wikipedia.org/wiki/9,223,372,036,854,775,807"><code>9223372036854775807</code></a></p>
<p>e.g. <code>-420</code></p>
<h2 id="float"><a class="header" href="#float">Float</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/float</code></em></p>
<p>Number with a comma.
Max value: <a href="https://en.wikipedia.org/wiki/9,223,372,036,854,775,807"><code>9223372036854775807</code></a></p>
<p>e.g. <code>-420</code></p>
<h2 id="boolean"><a class="header" href="#boolean">Boolean</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/boolean</code></em></p>
<p>True or false, one or zero.</p>
<p><strong>String serialization</strong></p>
<p><code>true</code> or <code>false</code>.</p>
<p><strong>Binary serialization</strong></p>
<p>Use a single bit one boolean.</p>
<p>1 for <code>true</code>, or 0 for <code>false</code>.</p>
<h2 id="date"><a class="header" href="#date">Date</a></h2>
<p>ISO date <em>without time</em>.
YYYY-MM-DD.</p>
<p>e.g. <code>1991-01-20</code></p>
<h2 id="timestamp"><a class="header" href="#timestamp">Timestamp</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/timestamp</code></em></p>
<p>Similar to <a href="https://www.unixtimestamp.com/">Unix Timestamp</a>.
Milliseconds since midnight UTC 1970 jan 01 (aka the <a href="https://en.wikipedia.org/wiki/Unix_time">Unix Epoch</a>).
Use this for most DateTime fields.
Signed 64 bit integer (instead of 32 bit in Unix systems).</p>
<p>e.g. <code>1596798919</code> (= 07 Aug 2020 11:15:19)</p>
<h2 id="resourcearray"><a class="header" href="#resourcearray">ResourceArray</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/resourceArray</code></em></p>
<p>Sequential, ordered list of Atomic URIs.
Serialized as a JSON array with strings.
Note that other types of arrays are not included in this spec, but can be perfectly valid.
(<a href="schema/">discussion</a>)</p>
<ul>
<li>e.g. <code>[&quot;https://example.com/1&quot;, &quot;https://example.com/1&quot;]</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-translations"><a class="header" href="#atomic-translations">Atomic Translations</a></h1>
<p><em>Status: design / concept stage</em></p>
<p>Dealing with translations can be hard.
(<a href="https://github.com/ontola/atomic-data/issues/6">See discussion on this subject here.</a>)</p>
<h2 id="translationbox"><a class="header" href="#translationbox">TranslationBox</a></h2>
<p><em>URL: <code>https://atomicdata.dev/classes/TranslationBox</code> (does not resolve yet)</em></p>
<p>A TranslationBox is a collection of translated strings, uses to provide multiple translations.
It has a long list of optional properties, each corresponding to some language.
Each possible language Property uses the following URL template: <code>https://atomicdata.dev/languages/{langguageTag}</code>.
Use a <a href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">BCP 47</a> language tag, e.g. <code>nl</code> or <code>en-US</code>.</p>
<p>For example:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/john&quot;,
  &quot;https://example.com/properties/lifestory&quot;: {
    &quot;https://atomicdata.dev/languages/en&quot;: &quot;Well, John was born and later he died.&quot;,
    &quot;https://atomicdata.dev/languages/nl&quot;: &quot;Tsja, John werd geboren en stierf later.&quot;
  },
}
</code></pre>
<p>Every single property used for Translation strings are instances of the Translation class.</p>
<p>A translation string uses the <a href="https://atomicdata.dev/datatypes/markdown">MDString</a> datatype, which means it allows Markdown syntax.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-schema-faq"><a class="header" href="#atomic-schema-faq">Atomic Schema FAQ</a></h1>
<h2 id="how-do-i-create-a-property-that-supports-multiple-datatypes"><a class="header" href="#how-do-i-create-a-property-that-supports-multiple-datatypes">How do I create a Property that supports multiple Datatypes?</a></h2>
<p>A property only has one single Datatype.
However, feel free to create a new kind of Datatype that, in turn, refers to other Datatypes.
Perhaps Generics, or Option like types should be part of the Atomic Base Datatypes.</p>
<h2 id="do-you-have-an-enum-datatype"><a class="header" href="#do-you-have-an-enum-datatype">Do you have an <code>enum</code> datatype?</a></h2>
<p>In Atomic Data, <code>enum</code> is not a datatype, but it's a constraint that can be added to properties that have.
You can set <a href="https://atomicdata.dev/properties/allowsOnly"><code>allows-only</code></a> on a Property, and use that to limit which values are allowed.</p>
<h2 id="how-should-a-client-deal-with-shortname-collisions"><a class="header" href="#how-should-a-client-deal-with-shortname-collisions">How should a client deal with Shortname collisions?</a></h2>
<p>Atomic Data guarantees Subject-Property uniqueness, which means that Valid Resources are guaranteed to have only one of each Property.
Properties offer Shortnames, which are short strings.
These strings should be unique inside Classes, but these are not guaranteed to be unique inside all Resources.
Note that Resources can have multiple Classes, and through that, they can have colliding Shortnames.
Resources are also free to include Properties from other Classes, and their Shortnames, too, might collide.</p>
<p>For example:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/people/123&quot;,
  &quot;https://example.com/name&quot;: &quot;John&quot;,
  &quot;https://another.example.com/someOtherName&quot;: &quot;Martin&quot;
}
</code></pre>
<p>Let's assume that <code>https://example.com/name</code> and <code>https://another.example.com/someOtherName</code> are Properties that have the Shortname: <code>name</code>.</p>
<p>What if a client tries something such as <code>people123.name</code>?
To consistently return a single value, we need some type of <em>precedence</em>:</p>
<ol>
<li>The earlier Class mentioned in the <a href="https://atomicdata.dev/properties/isA"><code>isA</code></a> Property of the resource. Resources can have multiple classes, but they appear in an ordered ResourceArray. Classes, internally should have no key collisions in required and recommended properties, which means that they might have. If these exist internally, sort the properties by how they are ordered in the <code>isA</code> array - first item is preferred.</li>
<li>When the Properties are not part of any of the mentioned Classes, use Alphabetical sorting of the Property URL.</li>
</ol>
<p>When shortname collisions are possible, it's recommended to not use the shortname, but use the URL of the Property:</p>
<pre><code>people123.&quot;https://example.com/name&quot;
</code></pre>
<p>It is likely that using the URL for keys is also the most <em>performant</em>, since it probably more closely mimics the internal data model.</p>
<h2 id="atomic-data-uses-a-lot-of-links-how-do-you-deal-with-links-that-dont-work"><a class="header" href="#atomic-data-uses-a-lot-of-links-how-do-you-deal-with-links-that-dont-work">Atomic Data uses a lot of links. How do you deal with links that don't work?</a></h2>
<p>Many features in Atomic Data apps depend on the availability of Resources on their subject URL.
If that server is offline, or the URL has changed, the existing links will break.
This is a fundamental problem to HTTP, and not unique to Atomic Data.
Like with websites, hosts should make sure that their server stays available, and that URLs remain static.</p>
<p>One possible solution to this problem, is using Content Addressing, such as the <a href="schema/../interoperability/ipfs.html">IPFS</a> protocol enables, which is why we're planning for using that in the near future.</p>
<p>Another approach, is using <a href="https://github.com/ontola/atomic-data-docs/issues/43">foreign keys (see issue)</a>.</p>
<h2 id="how-does-atomic-schema-relate-to-rdf--shacl--shex--owl--rdfs"><a class="header" href="#how-does-atomic-schema-relate-to-rdf--shacl--shex--owl--rdfs">How does Atomic Schema relate to RDF / SHACL / SheX / OWL / RDFS?</a></h2>
<p>Atomic Schema is <em>the</em> schema language for Atomic Data, whereas RDF has a couple of competing ones, which all vary greatly.
In short, OWL is not designed for schema validation, but SHACL and SheX can maybe be compared to Atomic Schema.
An important difference is that SHACL and SheX have to deal with all the complexities of RDF, whereas Atomic Data is more constrained.</p>
<p>For more information, see <a href="schema/../interoperability/rdf.html">RDF interoperability</a>.</p>
<h2 id="what-are-the-risks-of-using-schema-data-hosted-somewhere-else"><a class="header" href="#what-are-the-risks-of-using-schema-data-hosted-somewhere-else">What are the risks of using Schema data hosted somewhere else?</a></h2>
<p>Every time you use an external URL in your data, you kind of create a dependency.
This is fundamental to linked data.
In Atomic Data, not having access to the Property in some JSON-AD resource will lead to now knowing how to interpret the data itself.
You will no longer know what the Datatype was (other than the native JSON datatype, of course), or what the semantic meaning was of the relationship.</p>
<p>There are multiple ways we can deal with this:</p>
<ul>
<li><strong>Cache dependencies</strong>: Atomic Server already stores a copy of every class and property that it uses by default. The <code>/path</code> endpoint then allows clients to fetch these from servers that have cached it. If the source goes offline, the validations can still be performed by the server. However, it might be a good idea to migrate the data to a hosted ontology, e.g. by cloning the cached ontology.</li>
<li><strong>Content-addressing</strong>: using non-HTTP identifiers, such as with <a href="schema/../interoperability/ipfs.html">IPFS</a>.</li>
</ul>
<p><a href="https://github.com/ontola/atomic-data-docs/issues/99">See discussion</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-data-extended-1"><a class="header" href="#atomic-data-extended-1">Atomic Data Extended</a></h1>
<p>Atomic Data is a <em>modular</em> specification, which means that you can choose to implement parts of it.
All parts of Extended are <em>optional</em> to implement.
The <em>Core</em> of the specification (described in the previous chapter) is required for all of the Extended spec to work, but not the other way around.</p>
<p>However, many of the parts of Extended do depend on <em>eachother</em>.</p>
<ul>
<li><a href="commits/intro.html">Commits</a> communicate state changes. These Commits are signed using cryptographic keys, which ensures that every change can be audited. Commits are also used to construct a history of versions.</li>
<li><a href="agents.html">Agents</a> are Users that enable <a href="authentication.html">authentication</a>. They are Resources with their own Public and Private keys, which they use to identify themselves.</li>
<li><a href="schema/collections.html">Collections</a>: querying, filetering, sorting and pagination.</li>
<li><a href="core/paths.html">Paths</a>: traverse graphs.</li>
<li><a href="hierarchy.html">Hierarchies</a> used for authorization and keeping data organized. Similar to folder structures on filesystems.</li>
<li><a href="invitations.html">Invites</a>: create new users and provide them with rights.</li>
<li><a href="websockets.html">WebSockets</a>: real-time updates.</li>
<li><a href="endpoints.html">Endpoints</a>: provide machine-readable descriptions of web services.</li>
<li><a href="files.html">Files</a>: upload, download and metadata for files.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-agents"><a class="header" href="#atomic-agents">Atomic Agents</a></h1>
<p>Atomic Agents are used for <a href="./authentication.html">authentication</a>: to set an identity and prove who an actor actually is.
Agents can represent both actual individuals, or machines that interact with data.
Agents are the entities that can get write / read rights.
Agents are used to sign Requests and <a href="commits/intro.html">Commits</a> and to accept <a href="invitations.html">Invites</a>.</p>
<h2 id="design-goals-2"><a class="header" href="#design-goals-2">Design goals</a></h2>
<ul>
<li><strong>Decentralized</strong>: Atomic Agents can be created by anyone, at any domain</li>
<li><strong>Easy</strong>: It should be easy to work with, code with, and use</li>
<li><strong>Privacy-friendly</strong>: Agents should allow for privacy friendly workflows</li>
<li><strong>Verifiable</strong>: Others should be able to verify who did what</li>
<li><strong>Secure</strong>: Resistant to attacks by malicious others</li>
</ul>
<h2 id="the-agent-model"><a class="header" href="#the-agent-model">The Agent model</a></h2>
<p><em>url: https://atomicdata.dev/classes/Agent</em></p>
<p>An Agent is a Resource with its own URL.
When it is created, the one creating the Agent will generate a cryptographic (Ed25519) keypair.
It is <em>required</em> to include the <a href="https://atomicdata.dev/properties/publicKey"><code>publicKey</code></a> in the Agent resource.
The <a href="https://atomicdata.dev/properties/privateKey"><code>privateKey</code></a> should be kept secret, and should be safely stored by the creator.
For convenience, a <code>secret</code> can be generated, which is a single long string of characters that encodes both the <code>privateKey</code> and the <code>subject</code> of the Agent.
This <code>secret</code> can be used to instantly, easily log in using a single string.</p>
<p>The <code>publicKey</code> is used to verify commit signatures by that Agent, to check if that Agent actually did create and sign that Commit.</p>
<h2 id="creating-an-agent"><a class="header" href="#creating-an-agent">Creating an Agent</a></h2>
<p>Since an Agent is used for verification of commits, the Agent's <code>subject</code> should resolve and be publicly available.
This means that the one creating the Agent has to deal with this.
One way of doing this, is by hosting an <a href="https://crates.io/crates/atomic-server">Atomic Server</a>.
An easier way of doing this, is by accepting an <a href="invitations.html">Invite</a> that exists on someone else's server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hierarchy-rights-and-authorization"><a class="header" href="#hierarchy-rights-and-authorization">Hierarchy, rights and authorization</a></h1>
<p>Hierarchies help make information easier to find and understand.
For example, most websites use breadcrumbs to show you where you are.
Your computer probably has a bunch of <em>drives</em> and deeply nested <em>folders</em> that contain <em>files</em>.
We generally use these hierarchical elements to keep data organized, and to keep a tighter grip on rights management.
For example, sharing a specific folder with a team, but a different folder could be private.</p>
<p>Although you are free to use Atomic Data with your own custom authorization system, we have a standardized model that is currently being used by some of the tools that we've built.</p>
<h2 id="design-goals-3"><a class="header" href="#design-goals-3">Design goals</a></h2>
<ul>
<li><strong>Fast</strong>. Authorization can sometimes be costly, but in this model we'll be considering performance.</li>
<li><strong>Simple</strong>. Easy to understand, easy to implement.</li>
<li><strong>Handles most basic use-cases</strong>. Should deal with basic read / write access control, calculating the size of a folder, rendering things in a tree.</li>
</ul>
<h2 id="atomic-hierarchy-model"><a class="header" href="#atomic-hierarchy-model">Atomic Hierarchy Model</a></h2>
<ul>
<li>Every Resource SHOULD have a <a href="https://atomicdata.dev/properties/parent"><code>parent</code></a>.</li>
<li>Any Resource can be a <code>parent</code> of some other Resource, as long as both Resources exists on the same Atomic Server.</li>
<li>Inversely, every Resource could have <code>children</code>.</li>
<li>Only <a href="https://atomicdata.dev/classes/Drive"><code>Drive</code></a>s (Resources with the class <code>Drive</code>) are allowed to be a top-level parent.</li>
</ul>
<h2 id="authorization"><a class="header" href="#authorization">Authorization</a></h2>
<ul>
<li>Any Resource might have <a href="https://atomicdata.dev/properties/read"><code>read</code></a> and <a href="https://atomicdata.dev/properties/write"><code>write</code></a> Atoms. These both contain a list of Agents. These Agents will be granted the rights to edit (using Commits) or read / use the Resources.</li>
<li>Rights are <em>additive</em>, which means that the rights add up. If a Resource itself has no <code>write</code> Atom containing your Agent, but it's <code>parent</code> <em>does</em> have one, you will still get the <code>write</code> right.</li>
<li>Rights cannot be removed by children or parents - they can only be added.</li>
<li><code>Commits</code> can not be edited. They can be <code>read</code> if the Agent has rights to read the <a href="https://atomicdata.dev/properties/subject"><code>subject</code></a> of the <code>Commit</code>.</li>
</ul>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>See <a href="./authentication.html">authentication</a>.</p>
<h2 id="current-limitations-of-the-current-authorization-model"><a class="header" href="#current-limitations-of-the-current-authorization-model">Current limitations of the current Authorization model</a></h2>
<p>The specification is growing (and please contribute in the <a href="https://github.com/ontola/atomic-data-docs/issues">docs repo</a>), but the current specification lacks some features:</p>
<ul>
<li>Rights can only be added, but not removed in a higher item of a hierarchy. This means that you cannot have a secret folder inside a public folder.</li>
<li>No model for representing groups of Agents, or other runtime checks for authorization.</li>
<li>No way to limit delete access seperately from write rights</li>
<li>No way to request a set of rights for a Resource</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication-in-atomic-data"><a class="header" href="#authentication-in-atomic-data">Authentication in Atomic Data</a></h1>
<p>Authentication means knowing <em>who</em> is doing something, either getting access or creating some new data.
When an Agent wants to <em>edit</em> a resource, they have to send a signed <a href="commits/intro.html">Commit</a>, and the signatures are checked in order to authorize a Commit.</p>
<p>But how do we deal with <em>reading</em> data, how do we know who is trying to get access?
That's what this page will explain.
The short answer is: <strong>By signing the HTTP request</strong>.</p>
<h2 id="design-goals-4"><a class="header" href="#design-goals-4">Design goals</a></h2>
<ul>
<li><strong>Secure</strong>: Because, what's the point of authentication if it's not?</li>
<li><strong>Easy to use</strong>: Setting up an identity should not require <em>any</em> effort, and proving identity should be minimal effort.</li>
<li><strong>Anonimity allowed</strong>: Users should be able to have multiple identities, some of which are fully anonymous.</li>
<li><strong>Self-sovereign</strong>: No dependency on servers that user's don't control. Or at least, minimise this.</li>
<li><strong>Dummy-proof</strong>: We need a mechanism for dealing with forgetting passwords / client devices losing data.</li>
<li><strong>Compatible with Commits</strong>: Atomic Commits require clients to sign things. Ideally, this functionality / strategy would also fit with the new model.</li>
<li><strong>Fast</strong>: Of course, authentication will always slow things down. But let's keep that to a minimum.</li>
</ul>
<p>Authentication is done by signing individual (HTTP) requests with the Agent's private key.</p>
<h2 id="http-headers"><a class="header" href="#http-headers">HTTP Headers</a></h2>
<p>All of the following headers are required, if you need authentication.</p>
<ul>
<li><code>x-atomic-public-key</code>: The base64 public key (Ed25519) of the Agent sending the request</li>
<li><code>x-atomic-signature</code>: A base64 signature of the following string: <code>{subject} {timestamp}</code></li>
<li><code>x-atomic-timestamp</code>: The current time (when sending the request) as milliseconds since unix epoch</li>
<li><code>x-atomic-agent</code>: The subject URL of the Agent sending the request.</li>
</ul>
<h2 id="sending-a-request"><a class="header" href="#sending-a-request">Sending a request</a></h2>
<p>Here's an example (js) client side implementation with comments:</p>
<pre><code class="language-ts">// The Private Key of the agent is used for signing
// https://atomicdata.dev/properties/privateKey
const privateKey = &quot;someBase64Key&quot;;
const timestamp = Math.round(new Date().getTime());;
// This is what you will need to sign.
// The timestmap is to limit the harm of a man-in-the-middle attack.
// The `subject` is the full HTTP url that is to be fetched.
const message = `${subject} ${timestamp}`;
// Sign using Ed25519, see example implementation here: https://github.com/joepio/atomic-data-browser/blob/30b2f8af59d25084de966301cb6bd1ed90c0eb78/lib/src/commit.ts#L176
const signed = await signToBase64(message, privateKey);
// Set all of these headers
const headers = new Headers;
headers.set('x-atomic-public-key', await agent.getPublicKey());
headers.set('x-atomic-signature', signed);
headers.set('x-atomic-timestamp', timestamp.toString());
headers.set('x-atomic-agent', agent?.subject);
const response = await fetch(subject, {headers});
</code></pre>
<h2 id="handling-a-request"><a class="header" href="#handling-a-request">Handling a request</a></h2>
<ul>
<li>If none of the <code>x-atomic</code> HTTP headers are present, the server assigns the <a href="https://atomicdata.dev/agents/publicAgent">PublicAgent</a> to the request. This Agent represents any guest who is not signed in.</li>
<li>If some (but not all) of the <code>x-atomic</code> headers are present, the server will return with a <code>500</code>.</li>
<li>The server must check the timestamp (max 10 seconds difference).</li>
<li>The server must check whether the public key matches the one from the Agent.</li>
<li>The server must check if the signature is valid.</li>
<li>The server must check if the request resource can be shared</li>
</ul>
<h2 id="authentication-for-websockets"><a class="header" href="#authentication-for-websockets">Authentication for <a href="websockets.html">websockets</a></a></h2>
<ul>
<li>Since there's only a single HTTP request, we don't have a subject to fetch. Use <code>ws</code> as a subject, so sign a string like <code>ws 12940791247</code>.</li>
</ul>
<h2 id="hierarchies-for-authorization"><a class="header" href="#hierarchies-for-authorization">Hierarchies for authorization</a></h2>
<p>Atomic Data uses <a href="hierarchy.html">Hierarchies</a> to describe who gets to access some resource, and who can edit it.</p>
<h2 id="limitations--considerations"><a class="header" href="#limitations--considerations">Limitations / considerations</a></h2>
<ul>
<li>Since we need the Private Key to sign Commits and requests, the client should have this available. This means the client software as well as the user should deal with key management, and that can be a security risk in some contexts (such as a web browser). <a href="https://github.com/ontola/atomic-data-docs/issues/49">See issue #49</a>.</li>
<li>When using the Agent's subject to authenticate somwehere, the authorizer must be able to check what the public key of the agent is. This means the agent must be publicly resolvable. This is one of the reasons we should work towards a server-independent identifier, probably as base64 string that contains the public key (and, optionally, also the https identifier). See <a href="https://github.com/ontola/atomic-data-docs/issues/59">issue #59 on DIDs</a>.</li>
<li>Signing every single request takes a bit of time. We picked a fast algorithm (Ed25519) to minimize this cost.</li>
<li>We'll probably introduce some form of token-based-authentication in the future. <a href="https://github.com/ontola/atomic-data-docs/issues/87">See #87</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="invitations--tokens"><a class="header" href="#invitations--tokens">Invitations &amp; Tokens</a></h1>
<p><em>Discussion: https://github.com/ontola/atomic-data/issues/23</em></p>
<p>At some point on working on something in a web application, you're pretty likely to share that, often not with the entire world.
In order to make this process of inviting others as simple as possible, we've come up with an Invitation standard.</p>
<h2 id="design-goals-5"><a class="header" href="#design-goals-5">Design goals</a></h2>
<ul>
<li><strong>Edit without registration</strong>. Be able to edit or view things without being required to complete a registration process.</li>
<li><strong>Share with a single URL</strong>. A single URL should contain all the information needed.</li>
<li><strong>(Un)limited URL usage</strong>. A URL might be re-usable, or maybe not.</li>
</ul>
<h2 id="flow"><a class="header" href="#flow">Flow</a></h2>
<ol>
<li>The Owner or a resource creates an <a href="https://atomicdata.dev/classes/Invite">Invite</a>. This Invite points to a <code>target</code> Resource, provides <code>read</code> rights by default but can additionally add <code>write</code> rights, contains a bunch of <code>usagesLeft</code>.</li>
<li>The Guest opens the Invite URL. This returns the Invite resource, which provides the client with the information needed to do the next request which adds the actual rights.</li>
<li>The browser client app might generate a set of keys, or use an existing one. It sends the Agent URL to the Invite in a query param.</li>
<li>The server will respond with a Redirect resource, which links to the newly granted <code>target</code> resource.</li>
<li>The Guest will now be able to access the Resource.</li>
</ol>
<p>Try it on <a href="https://atomicdata.dev/invites/1">https://atomicdata.dev/invites/1</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-commits"><a class="header" href="#atomic-commits">Atomic Commits</a></h1>
<p><em>Disclaimer: Work in progress, prone to change.</em></p>
<p>Atomic Commits is a specification for communicating <em>state changes</em> (events / transactions / patches / deltas / mutations) of <a href="commits/../core/concepts.html">Atomic Data</a>.
It is the part of Atomic Data that is concerned with writing, editing, removing and updating information.</p>
<h2 id="design-goals-6"><a class="header" href="#design-goals-6">Design goals</a></h2>
<ul>
<li><strong>Event sourced</strong>: Store and standardize <em>changes</em>, as well as the <em>current</em> state. This enables versioning, history playback, undo, audit logs, and more.</li>
<li><strong>Traceable origin</strong>: Every change should be traceable to an actor and a point in time.</li>
<li><strong>Verifiable</strong>: Have cryptographic proof for every change. Know <em>when</em>, and <em>what</em> was changed by <em>whom</em>.</li>
<li><strong>Identifiable</strong>: A single commit has an identifier - it is a resource.</li>
<li><strong>Decentralized</strong>: Commits can be shared in P2P networks from device to device, whilst maintaining verifiability.</li>
<li><strong>Extensible</strong>: The methods inside a commit are not fixed. Use-case specific methods can be added by anyone.</li>
<li><strong>Streamable</strong>: The commits could be used in streaming context.</li>
<li><strong>Familiar</strong>: Introduces as little new stuff as possible (no new formats or language to learn)</li>
<li><strong>Pub/Sub</strong>: Subscribe to changes and get notified on changes.</li>
<li><strong>ACID-compliant</strong>: An Atomic commit will only occur if it results in a valid state.</li>
<li><strong>Atomic</strong>: All the Atomic Data design goals also apply here.</li>
</ul>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Although it's a good idea to keep data at the source as much as possible, we'll often need to synchronize two systems.
For example when data has to be queried or indexed differently than its source can support.
Doing this synchronization can be very difficult, since most of our software is designed to only maintain and share the <em>current state</em> of a system.</p>
<p>I noticed this mainly when working on OpenBesluitvorming.nl - an open data project where we aimed to fetch and standardize meeting data (votes, meeting minutes, documents) from 150+ local governments in the Netherlands.
We wrote software that fetched data from various systems (who all had different models, serialization formats and APIs), transformed this data to a single standard and share it through an API and a fulltext search endpoint.
One of the hard parts was keeping our data in sync with the sources.
How could we now if something was changed upstream?
We queried all these systems every night for <em>all meetings from the next and previous month</em>, and made deep comparisons to our own data.</p>
<p>This approach has a couple of issues:</p>
<ul>
<li>It costs a lot of resources, both for us and for the data suppliers.</li>
<li>It's not real-time - we can only run this once every 24 ours (because of how costly it is).</li>
<li>It's very prone to errors. We've had issues during all phases of Extraction, Transformation and Loading (ETL) processing.</li>
<li>It causes privacy issues. When some data at the source is removed (because it contained faulty or privacy sensitive data), how do we learn about that?</li>
</ul>
<p>Persisting and sharing state changes could solve these issues.
In order for this to work, we need to standardize this for all data suppliers.
We need a specification that is easy to understand for most developers.</p>
<p>Keeping track of where data comes from is essential to knowing whether you can trust it - whether you consider it to be true.
When you want to persist data, that quickly becomes bothersome.
Atomic Data and Atomic Commits aim to make this easier by using cryptography for ensuring data comes from some particular source, and is therefore trustworthy.</p>
<p>If you want to know how Atomic Commits differ from other specs, see the <a href="commits/compare.html">compare section</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-commits-concepts"><a class="header" href="#atomic-commits-concepts">Atomic Commits: Concepts</a></h1>
<h2 id="commit"><a class="header" href="#commit">Commit</a></h2>
<p><em>url: <a href="https://atomicdata.dev/classes/Commit">https://atomicdata.dev/classes/Commit</a></em></p>
<p>A Commit is a Resource that describes how a Resource must be updated.
It can be used for auditing, versioning and feeds.
It is cryptographically signed by an <a href="https://atomicdata.dev/classes/Agent">Agent</a>.</p>
<p>The <strong>required fields</strong> are:</p>
<ul>
<li><code>subject</code> - The thing being changed. A Resource Subject URL (HTTP identifier) that the Commit is changing about. A Commit Subject must not contain query parameters, as these are reserved for dynamic resources.</li>
<li><code>signer</code> - Who's making the change. The Atomic URL of the Author's profile - which in turn must contain a <code>publicKey</code>.</li>
<li><code>signature</code> - Cryptographic proof of the change. A hash of the JSON-AD serialized Commit (without the <code>signature</code> field), signed by the Agent's <code>private-key</code>. This proves that the author is indeed the one who created this exact commit. The signature of the Commit is also used as the identifier of the commit.</li>
<li><code>created-at</code> - When the change was made. A UNIX timestamp number of when the commit was created.</li>
</ul>
<p>The <strong>optional method fields</strong> describe how the data must be changed:</p>
<ul>
<li><code>destroy</code> - If true, the existing Resource will be removed.</li>
<li><code>remove</code> - an array of Properties that need to be removed (including their values).</li>
<li><code>set</code> - a Nested Resource which contains all the new or edited fields.</li>
</ul>
<p>These commands are executed in the order above.
This means that you can set <code>destroy</code> to <code>true</code> and include <code>set</code>, which empties the existing resource and sets new values.</p>
<h3 id="posting-commits-using-http"><a class="header" href="#posting-commits-using-http">Posting commits using HTTP</a></h3>
<p>Since Commits contains cryptographic proof of authorship, they can be accepted at a public endpoint.
There is no need for authentication.</p>
<p>A commit should be sent (using an HTTPS POST request) to a <code>/commmit</code> endpoint of an Atomic Server.
The server then checks the signature and the author rights, and responds with a <code>2xx</code> status code if it succeeded, or an <code>5xx</code> error if something went wrong.
The error will be a JSON object.</p>
<h3 id="serialization-with-json-ad"><a class="header" href="#serialization-with-json-ad">Serialization with JSON-AD</a></h3>
<p>Let's look at an example Commit:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://atomicdata.dev/commits/3n+U/3OvymF86Ha6S9MQZtRVIQAAL0rv9ZQpjViht4emjnqKxj4wByiO9RhfL+qwoxTg0FMwKQsNg6d0QU7pAw==&quot;,
  &quot;https://atomicdata.dev/properties/createdAt&quot;: 1611489929370,
  &quot;https://atomicdata.dev/properties/isA&quot;: [
    &quot;https://atomicdata.dev/classes/Commit&quot;
  ],
  &quot;https://atomicdata.dev/properties/set&quot;: {
    &quot;https://atomicdata.dev/properties/shortname&quot;: &quot;1611489928&quot;
  },
  &quot;https://atomicdata.dev/properties/signature&quot;: &quot;3n+U/3OvymF86Ha6S9MQZtRVIQAAL0rv9ZQpjViht4emjnqKxj4wByiO9RhfL+qwoxTg0FMwKQsNg6d0QU7pAw==&quot;,
  &quot;https://atomicdata.dev/properties/signer&quot;: &quot;https://surfy.ddns.net/agents/9YCs7htDdF4yBAiA4HuHgjsafg+xZIrtZNELz4msCmc=&quot;,
  &quot;https://atomicdata.dev/properties/subject&quot;: &quot;https://atomicdata.dev/test&quot;
}
</code></pre>
<p>This Commit can be sent to any Atomic Server.
This server, in turn, should verify the signature and the author's rights before the server applies the Commit.</p>
<h3 id="calculating-the-signature"><a class="header" href="#calculating-the-signature">Calculating the signature</a></h3>
<p>The signature is a base64 encoded Ed25519 signature of the deterministically serialized Commit.
Calculating the signature is a delicate process that should be followed to the letter - even a single character in the wrong place will result in an incorrect signature, which makes the Commit invalid.</p>
<p>The first step is <strong>serializing the commit deterministically</strong>.
This means that the process will always end in the exact same string.</p>
<ul>
<li>Serialize the Commit as JSON-AD.</li>
<li>Do not serialize the signature field.</li>
<li>Do not include empty objects or arrays.</li>
<li>If <code>destroy</code> is false, do not include it.</li>
<li>All keys are sorted alphabetically - both in the root object, as in any nested objects.</li>
<li>The JSON-AD is minified: no newlines, no spaces.</li>
</ul>
<p>This will result in a string.
The next step is to sign this string using the Ed25519 private key from the Author.
This signature is a byte array, which should be encoded in base64 for serialization.
Make sure that the Author's URL resolves to a Resource that contains the linked public key.</p>
<p>Congratulations, you've just created a valid Commit!</p>
<p>Here are currently working implementations of this process, including serialization and signing (links are permalinks).</p>
<ul>
<li><a href="https://github.com/joepio/atomic/blob/ceb88c1ae58811f2a9e6bacb7eaa39a2a7aa1513/lib/src/commit.rs#L81">in Rust (atomic-lib)</a>.</li>
<li><a href="https://github.com/joepio/atomic-data-browser/blob/fc899bb2cf54bdff593ee6b4debf52e20a85619e/src/atomic-lib/commit.ts#L51">in Typescript / Javascript (atomic-data-browser)</a>.</li>
</ul>
<p>If you want validate your implementation, check out the tests for these two projects.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>Commits adjust only one Resource at a time, which means that you cannot change multiple in one commit.</li>
<li>The one creating the Commit will need to sign it, which may make clients that write data more complicated than you'd like.</li>
<li>Commits require signatures, which means key management. Doing this securely is no trivial matter.</li>
<li>The signatures require JSON-AD serialization</li>
<li>If your implementation stores all Commits, this means</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-commits-compared-to-other-rdf-delta-models"><a class="header" href="#atomic-commits-compared-to-other-rdf-delta-models">Atomic Commits compared to other (RDF) delta models</a></h1>
<p>Let's compare the <a href="commits/concepts.html">Atomic Commit</a> approach with some existing protocols for communicating state changes / patches / mutations / deltas in linked data, JSON and text files.
First, I'll briefly discuss the existing examples (<a href="https://github.com/ontola/atomic-data/issues">open a PR / issue</a> if we're missing something!).
After that, we'll discuss how Atomic Data differs from the existing ones.</p>
<h2 id="git"><a class="header" href="#git">Git</a></h2>
<p>This might be an odd one in this list, but it is an interesting one nonetheless.
Git is an incredibly popular version control system that is used by most software developers to manage their code.
It's a decentralized concept which allows multiple computers to share a log of <em>commits</em>, which together represent a folder with its files and its history.
It uses hashing to represent (parts of) data (which keeps the <code>.git</code> folder compact through deduplication), and uses cryptographic keys to sign commits and verify authorship.
It is designed to work in the paradigm of text files, newlines and folders.
Since most data <em>can</em> be represented as text files in a folder, Git is very flexible.
This is partly because people are familiar with Git, but also because it has a great ecosystem - platforms such as Github provide a clean UI, cloud storage, issue tracking, authorization, authentication and more <em>for free</em>, as long as you use Git to manage your versions.</p>
<p>However, Git doesn't work great for structured data - especially when it changes a lot.
Git, on its own, does not perform any validations on integrity of data.
Git also does not adhere to some standardized serialization format for storing commits, which makes sense, because it was designed as a tool to solve a problem, and not as some standard that is to be used in various other systems.
Also, git is kind of a heavyweight abstraction for many applications.
It is designed for collaborating on open source projects, which means dealing with decentralized data storage and merge conflicts - things that might not be required in other kinds of scenarios.</p>
<h2 id="rdf-mutation-systems"><a class="header" href="#rdf-mutation-systems">RDF mutation systems</a></h2>
<p>Let's move on to specifications that mutate RDF specifically:</p>
<h3 id="n3-patch"><a class="header" href="#n3-patch">.n3 Patch</a></h3>
<p>N3 Patch is <a href="https://solidproject.org/TR/protocol#writing-resources">part of the Solid spec</a>, since december 2021.</p>
<p>It uses the N3 serialization format to describe changes to RDF documents.</p>
<pre><code>@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;

&lt;&gt; solid:patches &lt;https://tim.localhost:7777/read-write.ttl&gt;;
   solid:where   { ?a &lt;y&gt; &lt;z&gt;. };
   solid:inserts { ?a &lt;y&gt; &lt;z&gt;. };
   solid:deletes { ?a &lt;b&gt; &lt;c&gt;. }.
</code></pre>
<h3 id="rdf-delta"><a class="header" href="#rdf-delta">RDF-Delta</a></h3>
<p><a href="https://afs.github.io/rdf-delta/">https://afs.github.io/rdf-delta/</a></p>
<p>Describes changes (RDF Patches) in a specialized turtle-like serialization format.</p>
<pre><code>TX .
PA &quot;rdf&quot; &quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot; .
PA &quot;owl&quot; &quot;http://www.w3.org/2002/07/owl#&quot; .
PA &quot;rdfs&quot; &quot;http://www.w3.org/2000/01/rdf-schema#&quot; .
A &lt;http://example/SubClass&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://www.w3.org/2002/07/owl#Class&gt; .
A &lt;http://example/SubClass&gt; &lt;http://www.w3.org/2000/01/rdf-schema#subClassOf&gt; &lt;http://example/SUPER_CLASS&gt; .
A &lt;http://example/SubClass&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; &quot;SubClass&quot; .
TC .
</code></pre>
<p>Similar to Atomic Commits, these Delta's should have identifiers (URLs), which are denoted in a header.</p>
<h3 id="delta-ld"><a class="header" href="#delta-ld">Delta-LD</a></h3>
<p><a href="commits/">http://www.tara.tcd.ie/handle/2262/91407</a></p>
<p>Spec for classifying and representing state changes between two RDF resources.
I wasn't able to find a serialization or an implementation for this.</p>
<h3 id="patchr"><a class="header" href="#patchr">PatchR</a></h3>
<p><a href="commits/">https://www.igi-global.com/article/patchr/135561</a></p>
<p>An ontology for RDF change <em>requests</em>.
Looks very interesting, but I'm not able to find any implementations.</p>
<pre><code class="language-turtle">prefix :      &lt;http://example.org/&gt; .
@prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix pat:  &lt;http://purl.org/hpi/patchr#&gt; .
@prefix guo:  &lt;http://webr3.org/owl/guo#&gt; .
@prefix prov: &lt;http://purl.org/net/provenance/ns#&gt; .
@prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt; .
@prefix dbp:  &lt;http://dbpedia.org/resource/&gt; .
@prefix dbo:  &lt;http://dbpedia.org/ontology/&gt; .

:Patch_15 a pat:Patch ;
  pat:appliesTo &lt;http://dbpedia.org/void.ttl#DBpedia_3.5&gt; ;
  pat:status pat:Open ;
  pat:update [
    a guo:UpdateInstruction ;
    guo:target_graph &lt;http://dbpedia.org/&gt; ;
    guo:target_subject dbp:Oregon ;
    guo:delete [dbo:language dbp:De_jure ] ;
    guo:insert [dbo:language dbp:English_language ]
  ] ;
  prov:wasGeneratedBy [a prov:Activity ;
  pat:confidence &quot;0.5&quot;^^xsd:decimal ;
  prov:wasAssociatedWith :WhoKnows ;
  prov:actedOnBehalfOf :WhoKnows#Player_25 ;
  prov:performedAt &quot;...&quot;^^xsd:dateTime ] .
</code></pre>
<h3 id="ld-patch"><a class="header" href="#ld-patch">LD-Patch</a></h3>
<p><a href="commits/">https://www.w3.org/TR/ldpatch/</a></p>
<p>This offers quite a few features besides adding and deleting triples, such as updating lists.
It's a unique serialization format, inspired by turtle.
Some implementations exists, such as one in <a href="https://github.com/ruby-rdf/ld-patch">ruby</a> which is</p>
<pre><code>PATCH /timbl HTTP/1.1
Host: example.org
Content-Length: 478
Content-Type: text/ldpatch
If-Match: &quot;abc123&quot;

@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix schema: &lt;http://schema.org/&gt; .
@prefix profile: &lt;http://ogp.me/ns/profile#&gt; .
@prefix ex: &lt;http://example.org/vocab#&gt; .

Delete { &lt;#&gt; profile:first_name &quot;Tim&quot; } .
Add {
  &lt;#&gt; profile:first_name &quot;Timothy&quot; ;
    profile:image &lt;https://example.org/timbl.jpg&gt; .
} .

Bind ?workLocation &lt;#&gt; / schema:workLocation .
Cut ?workLocation .

UpdateList &lt;#&gt; ex:preferredLanguages 1..2 ( &quot;fr-CH&quot; ) .

Bind ?event &lt;#&gt; / schema:performerIn [ / schema:url = &lt;https://www.w3.org/2012/ldp/wiki/F2F5&gt; ]  .
Add { ?event rdf:type schema:Event } .

Bind ?ted &lt;http://conferences.ted.com/TED2009/&gt; / ^schema:url ! .
Delete { ?ted schema:startDate &quot;2009-02-04&quot; } .
Add {
  ?ted schema:location [
    schema:name &quot;Long Beach, California&quot; ;
    schema:geo [
      schema:latitude &quot;33.7817&quot; ;
      schema:longitude &quot;-118.2054&quot;
    ]
  ]
} .
</code></pre>
<h3 id="linked-delta"><a class="header" href="#linked-delta">Linked-Delta</a></h3>
<p><a href="commits/">https://github.com/ontola/linked-delta</a></p>
<p>An N-Quads serialized delta format.
Methods are URLs, which means they are extensible.
Does not specify how to bundle lines.
Used in production of a web app that we're working on (<a href="https://argu.co">Argu.co</a>).
Designed with simplicity (no new serialization format, simple to parse) and performance in mind by my colleague Thom van Kalkeren.</p>
<pre><code>Initial state:

&lt;http://example.org/resource&gt; &lt;http://example.org/predicate&gt; &quot;Old value &quot; .

Linked-Delta:

&lt;http://example.org/resource&gt; &lt;http://example.org/predicate&gt; &quot;New value &quot; &lt;http://purl.org/linked-delta/replace&gt; .

New state:

&lt;http://example.org/resource&gt; &lt;http://example.org/predicate&gt; &quot;New value &quot; .
</code></pre>
<h3 id="json-ld-patch"><a class="header" href="#json-ld-patch">JSON-LD-PATCH</a></h3>
<p><a href="commits/">https://github.com/digibib/ls.ext/wiki/JSON-LD-PATCH</a></p>
<p>A JSON denoted patch notation for RDF.
Seems similar to the <a href="https://www.w3.org/TR/rdf-json/">RDF/JSON</a> serialization format.
Uses string literals as operators / methods.
Conceptually perhaps most similar to linked-delta.</p>
<p>Has a <a href="https://developer.aliyun.com/mirror/npm/package/jsonld-patch">JS implementation</a>.</p>
<pre><code>[
  {
    &quot;op&quot;: &quot;add&quot;,
    &quot;s&quot;: &quot;http://example.org/my/resource&quot;,
    &quot;p&quot;: &quot;http://example.org/ontology#title&quot;,
    &quot;o&quot;: {
      &quot;value&quot;: &quot;New Title&quot;,
      &quot;type&quot;: &quot;http://www.w3.org/2001/XMLSchema#string&quot;
    }
  }
]
</code></pre>
<h3 id="sparql-update"><a class="header" href="#sparql-update">SPARQL UPDATE</a></h3>
<p><a href="commits/">https://www.w3.org/TR/sparql11-update/</a></p>
<p>SPARQL queries that change data.</p>
<pre><code class="language-sparql">PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
INSERT DATA
{
  &lt;http://example/book1&gt; dc:title &quot;A new book&quot; ;
                         dc:creator &quot;A.N.Other&quot; .
}
</code></pre>
<p>Allows for very powerful queries, combined with updates.
E.g. rename all persons named <code>Bill</code> to <code>William</code>:</p>
<pre><code>PREFIX foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;

WITH &lt;http://example/addresses&gt;
DELETE { ?person foaf:givenName 'Bill' }
INSERT { ?person foaf:givenName 'William' }
WHERE
  { ?person foaf:givenName 'Bill'
  }
</code></pre>
<p>SPARQL Update is the most powerful of the formats, but also perhaps the most difficult to implement and understand.</p>
<h2 id="json-patch"><a class="header" href="#json-patch">JSON-PATCH</a></h2>
<p><a href="commits/">http://jsonpatch.com/</a></p>
<p>A simple way to edit JSON objects:</p>
<pre><code>The original document

{
  &quot;baz&quot;: &quot;qux&quot;,
  &quot;foo&quot;: &quot;bar&quot;
}

The patch

[
  { &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/baz&quot;, &quot;value&quot;: &quot;boo&quot; },
  { &quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/hello&quot;, &quot;value&quot;: [&quot;world&quot;] },
  { &quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/foo&quot; }
]

The result

{
  &quot;baz&quot;: &quot;boo&quot;,
  &quot;hello&quot;: [&quot;world&quot;]
}
</code></pre>
<p>It uses the <a href="http://tools.ietf.org/html/rfc6901">JSON-Pointer spec</a> for denoting <code>path</code>s.
It has quite a bunch of implementations, in various languages.</p>
<!--
## m-ld

[m-ld](https://m-ld.org/doc/) is a specification that uses JSON-LD to enable real-time collaboration.
It is fundamentally decentralized -->
<h2 id="atomic-commits---how-its-different-and-why-it-exists"><a class="header" href="#atomic-commits---how-its-different-and-why-it-exists">Atomic Commits - how it's different and why it exists</a></h2>
<p>Let's talk about the differences between the concepts above and Atomic Commits.</p>
<p>For starters, Atomic Commits can only work with a <em>specific subset</em> of RDF, namely Atomic Data.
RDF allows for blank nodes, does not have subject-predicate uniqueness and offers named graphs - which all make it hard to unambiguously select a single value.
Most of the alternative patch / delta models described above had to support these concepts.
Atomic Data is more strict and constrained than RDF.
It does not support named graphs and blank nodes.
This enables a simpler approach to describing state changes, but it also means that Atomic Commits will not work with most existing RDF data.</p>
<p>Secondly, individual Atomic Commits are tightly coupled to specific Resources.
A single Commit cannot change multiple resources - and most of the models discussed above to enable this.
This is a big constraint, and it does not allow for things like compact migrations in a database.
However, this resource-bound constraint opens up some interesting possibilities:</p>
<ul>
<li>it becomes easier to combine it with <em>authorization</em> (i.e. check if the person has the correct rights to edit some resource): simply check if the Author has the rights to edit the Subject.</li>
<li>it makes it easier to find all Commits for a Resource, which is useful when constructing a history / audit log / previous version.</li>
</ul>
<p>Thirdly, Atomic Commits don't introduce a new serialization format.
It's just JSON.
This means that it will feel familiar for most developers, and will be supported by many existing environments.</p>
<p>Finally, Atomic Commits use cryptography (hashing) to determine authenticity of commits.
This concept is borrowed from git commits, which also uses signatures to prove authorship.
As is the case with git, this also allows for verifiable P2P sharing of changes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="websockets-in-atomic-data"><a class="header" href="#websockets-in-atomic-data">WebSockets in Atomic Data</a></h1>
<p>WebSockets are a very fast and efficient way to have a client and server communicate in an asynchronous fashion.
They are used in Atomic Data to allow real-time updates, which makes it possible to create things like collaborative applications and multiplayer games.
These have been implemented in <code>atomic-server</code> and <code>atomic-data-browser</code> (powered by <code>@tomic/lib</code>).</p>
<h2 id="initializing-a-websocket-connection"><a class="header" href="#initializing-a-websocket-connection">Initializing a WebSocket connection</a></h2>
<p>Send an HTTP <code>GET</code> request to the <code>/ws</code> endpoint of an <code>atomic-server</code>. The Server should update that request to a secure WebSocket (<code>wss</code>) connection.
Use <code>x-atomic</code> <a href="./authentication.html">authentication headers (read more here)</a> and use <code>ws</code> as a subject when signing.</p>
<h2 id="client-to-server-messages"><a class="header" href="#client-to-server-messages">Client to server messages</a></h2>
<ul>
<li><code>SUBSCRIBE ${subject}</code> tells the Server that you'd like to receive Commits about this Subject.</li>
<li><code>UNSUBSCRIBE ${subject}</code> tells the Server that you'd like to stop receiving Commits about this Subject.</li>
<li><code>GET ${subject}</code> fetch an individual resource.</li>
</ul>
<h2 id="server-to-client-messages"><a class="header" href="#server-to-client-messages">Server to client messages</a></h2>
<ul>
<li><code>COMMIT ${CommitBody}</code> an entire Commit for a resource that you're subscribed to</li>
<li><code>RESOURCE ${CommitBody}</code> a resource as a response to a GET request.</li>
</ul>
<h2 id="example-implementations"><a class="header" href="#example-implementations">Example implementations</a></h2>
<ul>
<li><a href="https://github.com/joepio/atomic-data-browser/blob/main/lib/src/websockets.ts">Example client implementation in Typescript (@tomic/lib).</a></li>
<li><a href="https://github.com/joepio/atomic-data-rust/blob/master/server/src/handlers/web_sockets.rs">Example server implementation in Rust using Actix-Web</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-endpoints"><a class="header" href="#atomic-endpoints">Atomic Endpoints</a></h1>
<p><em>URL: https://atomicdata.dev/classes/Endpoint</em></p>
<p>An Endpoint is a resource that accepts parameters in order to generate a response.
You can think of it like a function in a programming language, or a API endpoint in an OpenAPI spec.
It can be used to perform calculations on the server side, such as filtering data, sorting data, selecting a page in a collection, or performing some calculation.
Because Endpoints are resources, they can be defined and read programmatically.
This means that it's possible to render Endpoints as forms.</p>
<p>The most important property in an Endpoint is <a href="https://atomicdata.dev/properties/endpoint/parameters"><code>parameters</code></a>, which is the list of Properties that can be filled in.</p>
<p>You can find a list of Endpoints supported by Atomic-Server on <a href="https://atomicdata.dev/endpoints">atomicdata.dev/endpoints</a>.</p>
<p>Endpoint Resources are <em>dynamic</em>, because their properties could be calculated server-side.
When a Property tends to be calculated server-side, they will have a <a href="https://atomicdata.dev/properties/isDynamic"><code>isDynamic</code> property</a> set to <code>true</code>, which tells the client that it's probably useless to try to overwrite it.</p>
<h2 id="incomplete-resources"><a class="header" href="#incomplete-resources">Incomplete resources</a></h2>
<p>A Server can also send one or more partial Resources for an Endpoint to the client, which means that some properties may be missing.
When this is the case, the Resource will have an <a href="https://atomicdata.dev/properties/incomplete"><code>incomplete</code></a> property set to <code>true</code>.
This tells the client that it has to individually fetch the resource from the server to get the full body.</p>
<p>One scenario where this happens, is when fetching Collections that have other Collections as members.
If we would not have incomplete resources, the server would have to perform expensive computations even if the data is not needed by the client.</p>
<h2 id="design-goals-7"><a class="header" href="#design-goals-7">Design Goals</a></h2>
<ul>
<li><strong>Familiar API</strong>: should look like something that most developers already know</li>
<li><strong>Auto-generate forms</strong>: a front-end app should present Endpoints as forms that non-developers can interact with</li>
</ul>
<p><a href="https://github.com/ontola/atomic-data-docs/issues/15">Discussion in issue tracker</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-collections-1"><a class="header" href="#atomic-collections-1">Atomic Collections</a></h1>
<p><em>URL: <a href="https://atomicdata.dev/classes/Collection">https://atomicdata.dev/classes/Collection</a></em></p>
<p>Sooner or later, developers will have to deal with (long) lists of items.
For example, a set of blog posts, activities or users.
These lists often need to be paginated, sorted, and filtered.
For dealing with these problems, we have Atomic Collections.</p>
<p>An Atomic Collection is a Resource that links to a set of resources.
Note that Collections are designed to be <em>dynamic resources</em>, often (partially) generated at runtime.
Collections are <a href="schema/../endpoints.html">Endpoints</a>, which means that part of their properties are calculated server-side.
Collections have various filters (<code>subject</code>, <code>property</code>, <code>value</code>) that can help to build a useful query.</p>
<ul>
<li><a href="https://atomicdata.dev/properties/collection/members"><code>members</code></a>: How many items (members) are visible per page.</li>
<li><a href="https://atomicdata.dev/properties/collection/property"><code>property</code></a>: Filter results by a property URL.</li>
<li><a href="https://atomicdata.dev/properties/collection/value"><code>value</code></a>: Filter results by a Value. Combined with <code>property</code>, you can create powerful queries.</li>
<li><a href="https://atomicdata.dev/properties/collection/sortBy"><code>sort_by</code></a>: A property URL by which to sort. Defaults to the <code>subject</code>.</li>
<li><a href="https://atomicdata.dev/properties/collection/sortDesc"><code>sort_desc</code></a>: Sort descending, instead of ascending. Defaults to <code>false</code>.</li>
<li><a href="https://atomicdata.dev/properties/collection/currentPage"><code>current_page</code></a>: The number of the current page.</li>
<li><a href="https://atomicdata.dev/properties/collection/pageSize"><code>page_size</code></a>: How many items (members) are visible per page.</li>
<li><a href="https://atomicdata.dev/properties/collection/totalPages"><code>total_pages</code></a>: How many pages there are for the current collection.</li>
<li><a href="https://atomicdata.dev/properties/collection/totalMembers"><code>total_members</code></a>: How many items (members) are visible per page.</li>
</ul>
<!-- - `scope`: The parent resource in which to limit the query (see Atomic Hierarchy) -->
<h2 id="persisting-properties-vs-query-parameters"><a class="header" href="#persisting-properties-vs-query-parameters">Persisting Properties vs Query Parameters</a></h2>
<p>Since Atomic Collections are dynamic resources, you can pass query parameters to it.
The keys of the query params match the shortnames of the properties of the Collection.</p>
<p>For example, let's take the <a href="https://atomicdata.dev/collections/property">Properties Collection on atomicdata.dev</a>.
We could limit the page size to 2 by adding the <code>page_size=2</code> query parameter: <code>https://atomicdata.dev/collections/property?page_size=2</code>.
Or we could sort the list by the description property: <code>https://atomicdata.dev/collections/property?sort_by=https%3A%2F%2Fatomicdata.dev%2Fproperties%2Fdescription</code>.
Note that URLs need to be URL encoded.</p>
<p>These properties of Collections can either be set by passing query parameters, or they can be <em>persisted</em> by the Collection creator / editor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uploading-downloading-and-describing-files-with-atomic-data"><a class="header" href="#uploading-downloading-and-describing-files-with-atomic-data">Uploading, downloading and describing files with Atomic Data</a></h1>
<p>The Atomic Data model (Atomic Schema) is great for describing structured data, but for many types of existing data, we already have a different way to represent them: files.
In Atomic Data, files have two URLs.
One <em>describes</em> the file and its metadata, and the other is a URL that downloads the file.
This allows us to present a better view when a user wants to take a look at some file, and learn about its context before downloading it.</p>
<h2 id="the-file-class"><a class="header" href="#the-file-class">The File class</a></h2>
<p><em>url: <a href="https://atomicdata.dev/classes/File">https://atomicdata.dev/classes/File</a></em></p>
<p>Files always have a downloadURL.
They often also have a filename, a filesize, a checksum, a mimetype, and an internal ID (more on that later).
They also often have a <a href="https://atomicdata.dev/properties/parent"><code>parent</code></a>, which can be used to set permissions / rights.</p>
<h2 id="uploading-a-file"><a class="header" href="#uploading-a-file">Uploading a file</a></h2>
<p>In <code>atomic-server</code>, a <code>/upload</code> endpoint exists for uploading a file.</p>
<ul>
<li>Decide where you want to add the file in the <a href="hierarchy.html">hierarchy</a> of your server. You can add a file to any resource - your file will refer to this resource as its <a href="https://atomicdata.dev/properties/parent"><code>parent</code></a>. Make sure you have <code>write</code> rights on this parent.</li>
<li>Use that parent to add a query parameter to the server's <code>/upload</code> endpoint, e.g. <code>/upload?parent=https%3A%2F%2Fatomicdata.dev%2Ffiles</code>.</li>
<li>Send an HTTP <code>POST</code> request to the server's <code>/upload</code> endpoint containing <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData/Using_FormData_Objects"><code>multi-part-form-data</code></a>. You can upload multiple files in one request. Add <a href="authentication.html">authentication</a> headers, and sign the HTTP request with the</li>
<li>The server will check your authentication headers, your permissions, and will persist your uploaded file(s). It will now create File resources.</li>
<li>The server will reply with an array of created Atomic Data Files</li>
</ul>
<h2 id="downloading-a-file"><a class="header" href="#downloading-a-file">Downloading a file</a></h2>
<p>Simply send an HTTP GET request to the File's <a href="https://atomicdata.dev/properties/downloadURL"><code>download-url</code></a> (make sure to authenticate this request).</p>
<ul>
<li><a href="https://github.com/ontola/atomic-data-docs/issues/57">Discussion on specification</a></li>
<li><a href="https://github.com/joepio/atomic-data-rust/issues/72">Discussion on Rust server implementation</a></li>
<li><a href="https://github.com/joepio/atomic-data-browser/issues/121">Discussion on Typescript client implementation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interoperability-relation-to-other-technology"><a class="header" href="#interoperability-relation-to-other-technology">Interoperability: Relation to other technology</a></h1>
<p>Atomic data is designed to be easy to use in existing projects, and be interoperable with existing formats.
This section will discuss how Atomic Data differs from or is similar to various data formats and paradigms, and how it can interoperate.</p>
<h2 id="upgrade-guide"><a class="header" href="#upgrade-guide">Upgrade guide</a></h2>
<ul>
<li><a href="interoperability/upgrade.html">Upgrade</a>: How to make your existing (server-side) application serve Atomic Data. From easy, to hard.</li>
</ul>
<h2 id="data-formats"><a class="header" href="#data-formats">Data formats</a></h2>
<ul>
<li><a href="interoperability/json.html">JSON</a>: Atomic Data is designed to be easily serializable to clean, idiomatic JSON. However, if you want to turn JSON into Atomic Data, you'll have to make sure that all keys in the JSON object are URLs that link to Atomic Properties, and the data itself also has to be available at its Subject URL.</li>
<li><a href="interoperability/rdf.html">RDF</a>: Atomic Data is a strict subset of RDF, and can therefore be trivially serialized to all RDF formats (Turtle, N-triples, RDF/XML, JSON-LD, and others). The other way around is more difficult. Turning RDF into Atomic Data requires that all predicates are Atomic Properties, the values must match its properties datatype, the atoms must be available at the subject URL, and the subject-predicate combinations must be unique.</li>
</ul>
<h2 id="protocols"><a class="header" href="#protocols">Protocols</a></h2>
<ul>
<li><a href="interoperability/solid.html">Solid</a>: A set of specifications that has many similarities with Atomic Data</li>
<li><a href="interoperability/ipfs.html">IPFS</a>: Content-based addressing to prevent 404s and centralization</li>
</ul>
<h2 id="database-paradigms"><a class="header" href="#database-paradigms">Database paradigms</a></h2>
<ul>
<li><a href="interoperability/sql.html">SQL</a>: How Atomic Data differs from and could interact with SQL databases</li>
<li><a href="interoperability/graph-database.html">Graph</a>: How it differs from some labeled property graphs, such as Neo4j</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrade-your-existing-application-to-serve-atomic-data"><a class="header" href="#upgrade-your-existing-application-to-serve-atomic-data">Upgrade your existing application to serve Atomic Data</a></h1>
<p>You don't have to use <a href="https://crates.io/crates/atomic-server">Atomic-Server</a> and ditch your existing projects or apps, if you want to adhere to Atomic Data specs.</p>
<p>As the Atomic Data spec is modular, you can start out simply and conform to more specs as needed:</p>
<ol>
<li>Map your JSON keys to new or existing Atomic Data properties</li>
<li>Add <code>@id</code> fields to your resources, make sure these URLs resolve using HTTP</li>
<li>Implement parts of the <a href="interoperability/../extended.html">Extended spec</a></li>
</ol>
<p>There's a couple of levels you can go to, when adhering to the Atomic Data spec.</p>
<h2 id="easy-map-your-json-keys-to-atomic-data-properties"><a class="header" href="#easy-map-your-json-keys-to-atomic-data-properties">Easy: map your JSON keys to Atomic Data Properties</a></h2>
<p>If you want to make your existing project compatible with Atomic Data, you probably don't have to get rid of your existing storage / DB implementation.
The only thing that matters, is how you make the data accessible to others: the <em>serialization</em>.
You can keep your existing software and logic, but simply change the last little part of your API.</p>
<p>In short, this is what you'll have to do:</p>
<p>Map all properties of resources to Atomic Properties.
Either use <a href="https://atomicdata.dev/properties">existing ones</a>, or <a href="https://atomicdata.dev/app/new?classSubject=https%3A%2F%2Fatomicdata.dev%2Fclasses%2FProperty&amp;parent=https%3A%2F%2Fatomicdata.dev%2Fagents%2F8S2U%2FviqkaAQVzUisaolrpX6hx%2FG%2FL3e2MTjWA83Rxk%3D&amp;newSubject=https%3A%2F%2Fatomicdata.dev%2Fproperty%2Fsu98ox6tvkh">create new ones</a>.
This means: take your JSON objects, and change things like <code>name</code> to <code>https://atomicdata.dev/properties/name</code>.</p>
<p>That's it, you've done the most important step!</p>
<p>Now your data is already more interoperable:</p>
<ul>
<li>Every field has a clear <strong>semantic meaning</strong> and <strong>datatype</strong></li>
<li>Your data can now be <strong>easily imported</strong> by Atomic Data systems</li>
</ul>
<h2 id="medium-add-id-urls-that-properly-resolve"><a class="header" href="#medium-add-id-urls-that-properly-resolve">Medium: add <code>@id</code> URLs that properly resolve</a></h2>
<p>Make sure that when the user requests some URL, that you return that resource as a <a href="interoperability/../core/json-ad.html">JSON-AD</a> object (at the very least if the user requests it using an HTTP <code>Accept: application/ad+json</code> header).</p>
<ul>
<li>Your data can now be <strong>linked to</strong> by external data sources, it can become part of a <strong>web of data</strong>!</li>
</ul>
<h2 id="hard-implement-atomic-data-extended-protocols"><a class="header" href="#hard-implement-atomic-data-extended-protocols">Hard: implement Atomic Data Extended protocols</a></h2>
<p>You can go all out, and implement Commits, Hierarchies, Authentication, Collections and <a href="https://docs.atomicdata.dev/extended.html">more</a>.
I'd suggest starting with <a href="interoperability/../commits.html">Commits</a>, as these allow users to modify data whilst maintaining versioning and auditability.
Check out the <a href="https://github.com/joepio/atomic-data-rust/tree/master/server">Atomic-Server source code</a> to get inspired on how to do this.</p>
<h2 id="reach-out-for-help"><a class="header" href="#reach-out-for-help">Reach out for help</a></h2>
<p>If you need any help, join our <a href="https://discord.gg/a72Rv2P">Discord</a>.</p>
<p>Also, share your thoughts on creating Atomic Data in <a href="https://github.com/ontola/atomic-data-docs/issues/95">this issue on github</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-does-atomic-data-relate-to-rdf"><a class="header" href="#how-does-atomic-data-relate-to-rdf">How does Atomic Data relate to RDF?</a></h1>
<p>RDF (the <a href="https://www.w3.org/TR/rdf-primer/">Resource Description Framework</a>) is a W3C specification from 1999 that describes the original data model for linked data.
It is the forerunner of Atomic Data, and is therefore highly similar in its model.
Both heavily rely on using URLs, and both have a fundamentally simple and uniform model for data statements.
Both view the web as a single, connected graph database.
Because of that, Atomic Data is also highly compatible with RDF - <strong>all Atomic Data is also valid RDF</strong>.
Atomic Data can be thought of as a <strong>more constrained, type safe version of RDF</strong>.
However, it does differ in some fundamental ways.</p>
<ul>
<li>Atomic calls the three parts of a Triple <code>subject</code>, <code>property</code> and <code>value</code>, instead of <code>subject</code>, <code>predicate</code>, <code>object</code>.</li>
<li>Atomic does not support having multiple statements with the same <code>&lt;subject&gt; &lt;predicate&gt;</code>, every combination must be unique.</li>
<li>Atomic does not have <code>literals</code>, <code>named nodes</code> and <code>blank nodes</code> - these are all <code>values</code>, but with different datatypes.</li>
<li>Atomic uses <code>nested Resources</code> and <code>paths</code> instead of <code>blank nodes</code></li>
<li>Atomic requires URL (not URI) values in its <code>subjects</code> and <code>properties</code> (predicates), which means that they should be resolvable. Properties must resolve to an <code>Atomic Property</code>, which describes its datatype.</li>
<li>Atomic only allows those who control a resource's <code>subject</code> URL endpoint to edit the data. This means that you can't add triples about something that you don't control.</li>
<li>Atomic has no separate <code>datatype</code> field, but it requires that <code>Properties</code> (the resources that are shown when you follow a <code>predicate</code> value) specify a datatype. However, it is allowed to serialize the datatype explicitly, of course.</li>
<li>Atomic has no separate <code>language</code> field, but it does support <a href="interoperability/../schema/translations.html">Translation Resources</a>.</li>
<li>Atomic has a native Event (state changes) model (<a href="interoperability/../commits/intro.html">Atomic Commits</a>), which enables communication of state changes</li>
<li>Atomic has a native Schema model (<a href="interoperability/../schema/intro.html">Atomic Schema</a>), which helps developers to know what data types they can expect (string, integer, link, array)</li>
<li>Atomic does not support Named Graphs. These should not be needed, because all statements should be retrievable by fetching the Subject of a resource. However, it <em>is</em> allowed to include other resources in a response.</li>
</ul>
<h2 id="why-these-changes"><a class="header" href="#why-these-changes">Why these changes?</a></h2>
<p>I have been working with RDF for quite some time now, and absolutely believe in some of the core premises of RDF.
I started a company that specializes in Linked Data (<a href="https://ontola.io">Ontola</a>), and we use it extensively in our products and services.
Using URIs (and more-so URLs, which are URIs that can be fetched) for everything is a great idea, since it helps with interoperability and enables truly decentralized knowledge graphs.
However, some of the characteristics of RDF make it hard to use, and have probably contributed to its relative lack of adoption.</p>
<h3 id="its-too-hard-to-select-a-specific-value-object-in-rdf"><a class="header" href="#its-too-hard-to-select-a-specific-value-object-in-rdf">It's too hard to select a specific value (object) in RDF</a></h3>
<p>For example, let's say I want to render someone's birthday:</p>
<pre><code class="language-ttl">&lt;example:joep&gt; &lt;schema:birthDate&gt; &quot;1991-01-20&quot;^^xsd:date
</code></pre>
<p>Rendering this item might be as simple as fetching the subject URL, filtering by predicate URL, and parsing the <code>object</code> as a date.</p>
<p>However, this is also valid RDF:</p>
<pre><code class="language-ttl">&lt;example:joep&gt; &lt;schema:birthDate&gt; &quot;1991-01-20&quot;^^xsd:date &lt;example:someNamedGraph&gt;
&lt;example:joep&gt; &lt;schema:birthDate&gt; &lt;example:birthDateObject&gt; &lt;example:someOtherNamedGraph&gt;
&lt;example:joep&gt; &lt;schema:birthDate&gt; &quot;20th of januari 1991&quot;@en &lt;example:someNamedGraph&gt;
&lt;example:joep&gt; &lt;schema:birthDate&gt; &quot;20 januari 1991&quot;@nl &lt;example:someNamedGraph&gt;
&lt;example:joep&gt; &lt;schema:birthDate&gt; &quot;2000-02-30&quot;^^xsd:date &lt;example:someNamedGraph&gt;
</code></pre>
<p>Now things get more complicated if you just want to select the original birthdate value:</p>
<ol>
<li><strong>Select the named graph</strong>. The triple containing that birthday may exist in some named graph different from the <code>subject</code> URL, which means that I first need to identify and fetch that graph.</li>
<li><strong>Select the subject</strong>.</li>
<li><strong>Select the predicate</strong>.</li>
<li><strong>Select the datatype</strong>. You probably need a specific datatype (in this case, a Date), so you need to filter the triples to match that specific datatype.</li>
<li><strong>Select the language</strong>. Same could be true for language, too, but that is not necessary in this birthdate example.</li>
<li><strong>Select the specific triple</strong>. Even after all our previous selectors, we <em>still</em> might have multiple values. How do I know which is the triple I'm supposed to use?</li>
</ol>
<p>To be fair, with a lot of RDF data, only steps 2 and 3 are needed, since there are often no <code>subject-predicate</code> collisions.
And if you <em>control</em> the data of the source, you can set any constraints that you like, inlcluding <code>subject-predicate</code> uniqueness.
But if you're building a system that uses arbitrary RDF, that system also needs to deal with steps 1,4,5 and 6.
That often means writing a lot of conditionals and other client-side logic to get the value that you need.
It also means that serializing to a format like JSON becomes complicated - you can't just map predicates to keys - you might get collisions.
And you can't use key-value stores for storing RDF, at least not in a trivial way.
Every single <em>selected value</em> should be treated as an array of unknown datatypes, and that makes it really difficult to build software.
All this complexity is the direct result of the lack of <code>subject-predicate</code> uniqueness.</p>
<p>As a developer who uses RDF data, I want to be able to do something like this:</p>
<pre><code class="language-js">// Fetches the resource
const joep = get(&quot;https://example.com/person/joep&quot;)
// Returns the value of the birthDate atom
console.log(joep.birthDate()) // =&gt; Date(1991-01-20)
// Fetches the employer relation at possibly some other domain, checks that resource for a property with the 'name' shortkey
console.log(joep.employer().name()) // =&gt; &quot;Ontola.io&quot;
</code></pre>
<p>Basically, I'd like to use all knowledge of the world as if it were a big JSON object.
Being able to do that, requires using some things that are present in JSON, and using some things that are present in RDF.</p>
<ul>
<li>Traverse data on various domains (which is already possible with RDF)</li>
<li>Have <a href="interoperability/rdf.html#subject-predicate-uniqueness">unique <code>subject-predicate</code> combinations</a> (which is default in JSON)</li>
<li>Map properties URLs to keys (which often requires local mapping with RDF, e.g. in JSON-LD)</li>
<li>Link properties to datatypes (which is possible with ontologies like SHACL / SHEX)</li>
</ul>
<h3 id="less-focus-on-semantics-more-on-usability"><a class="header" href="#less-focus-on-semantics-more-on-usability">Less focus on semantics, more on usability</a></h3>
<p>One of the core ideas of the semantic web, is that anyone should be able to say anything about anything, using semantic triples.
This is one of the reasons why it can be so hard to select a specific value in RDF.
When you want to make all graphs mergeable (which is a great idea), but also want to allow anyone to create any triples about any subject, you get <code>subject-predicate</code> non-uniqueness.
For the Semantic Web, having <em>semantic</em> triples is great.
For linked data, and connecting datasets, having atomic triples (with unique <code>subject-predicate</code> combinations) seems preferable.
Atomic Data chooses a more constrained approach, which makes it easier to use the data, but at the cost of some expressiveness.</p>
<h3 id="changing-the-names"><a class="header" href="#changing-the-names">Changing the names</a></h3>
<p>RDF's <code>subject</code>, <code>predicate</code> and <code>object</code> terminology can be confusing to newcomers, so Atomic Data uses <code>subject</code>, <code>property</code>, <code>value</code>.
This more closely resembles common CS terminology. (<a href="https://github.com/ontola/atomic-data/issues/3">discussion</a>)</p>
<h3 id="subject--predicate-uniqueness"><a class="header" href="#subject--predicate-uniqueness">Subject + Predicate uniqueness</a></h3>
<p>As discussed above, in RDF, it's very much possible for a graph to contain multiple statements that share both a <code>subject</code> and a <code>predicate</code>.
This is probably because of two reasons:</p>
<ol>
<li>RDF graphs must always be <strong>mergeable</strong> (just like Atomic Data).</li>
<li>Anyone can make <strong>any statement</strong> about <strong>any subject</strong> (<em>unlike</em> Atomic Data, see next section).</li>
</ol>
<p>However, this introduces a lot extra complexity for data users (see above), which makes it not very attractive to use RDF in any client.
Whereas most languages and datatypes have <code>key-value</code> uniqueness that allow for unambiguous value selection, RDF clients have to deal with the possibility that multiple triples with the same <code>subject-predicate</code> combination might exist.
It also introduces a different problem: How should you interpret a set of <code>subject-predicate</code> combinations?
Does this represent a non-ordered collection, or did something to wrong with setting values?<br />
In the RDF world, I've seen many occurences of both.</p>
<p>Atomic Data requires <code>subject-property</code> uniqueness, which means that these issues are no more.
However, in order to guarantee this, and still retain <em>graph merge-ability</em> we also need to limit who creates statements about a subject:</p>
<h3 id="limiting-subject-usage"><a class="header" href="#limiting-subject-usage">Limiting subject usage</a></h3>
<p>RDF allows that <code>anne.com</code> creates and hosts statements about the subject <code>john.com</code>.
In other words, domain A creates statements about domain B.
It allows anyone to say anything about any subject, thus allowing for extending data that is not under your control.</p>
<p>For example, developers at both Ontola and Inrupt (two companies that work a lot with RDF) use this feature to extend the Schema.org ontology with translations.
This means they can still use standards from Schema.org, and have their own translations of these concepts.</p>
<p>However, I think this is a flawed approach.
In the example above, two companies are adding statements about a subject.
In this case, both are adding translations.
They're doing the same work twice.
And as more and more people will use that same resource, they will be forced to add the same translations, again and again.</p>
<p>I think one of the core perks of linked data, is being able to make your information highly re-usable.
When you've created statements about an external thing, these statements are hard to re-use.</p>
<p>This means that someone using RDF data about domain B cannot know that domain B is actually the source of the data.
Knowing <em>where data comes from</em> is one of the great things about URIs, but RDF does not require that you can think of subjects as the source of data.
Many subjects in RDF don't actually resolve to all the known triples of the statement.
It would make the conceptual model way simpler if statements about a subject could only be made from the source of the domain owner of the subject.
When triples are created about a resource in a place other than where the subject is hosted, these triples are hard to share.</p>
<p>The way RDF projects deal with this, is by using <em>named graphs</em>.
As a consequence, all systems that use these triples should keep track of another field for every atom.
To make things worse, it makes <code>subject-predicate</code> <em>impossible</em> to guarantee.
That's a high price to pay.</p>
<p>I've asked two RDF developers (who did not know each other) working on RDF about limiting subject usage, and both were critical.
Interestingly, they provided the same usecase for using named graphs that would conflict with the limiting subject usage constraint.
They both wanted to extend the schema.org ontology by adding properties to these items in a local graph.
I don't think even this usecase is appropriate for named graphs. They were actually using an external resource that did not provide them with the things they needed. The things that they would add (the translations) are not re-usable, so in the end they will just keep spreading a URL that doesn't provide people with the things that they will come to expect. The schema.org URL still won't provide the translations that they wrote!
I believe a better solution is to copy the resource (in this case a part of the schema.org ontology), and extend it, and host it somewhere else, and use that URL.
Or even better: have a system for <a href="https://github.com/ontola/atomic-data/issues/21">sharing your change suggestions</a> with the source of the data, and allow for easy collaboration on ontologies.</p>
<h3 id="no-more-literals--named-nodes"><a class="header" href="#no-more-literals--named-nodes">No more literals / named nodes</a></h3>
<p>In RDF, an <code>object</code> can either be a <code>named node</code>, <code>blank node</code> or <code>literal</code>. A <code>literal</code> has a <code>value</code>, a <code>datatype</code> and an optional <code>language</code> (if the <code>literal</code> is a string).
Although RDF statements are often called <code>triples</code>, a single statement can consist of five fields: <code>subject</code>, <code>predicate</code>, <code>object</code>, <code>language</code>, <code>datatype</code>.
Having five fields is way more than most information systems. Usually we have just <code>key</code> and <code>value</code>.
This difference leads to compatibility issues when using RDF in applications.
In practice, clients have to run a lot of checks before they can use the data - which makes RDF in most contexts harder to use than something such as JSON.</p>
<p>Atomic Data drops the <code>named node</code> / <code>literal</code> distinction.
We just have <code>values</code>, and they are interpreted by looking at the <code>datatype</code>, which is defined in the <code>property</code>.
When a value is a URL, we don't call it a named node, but we simply use a URL datatype.</p>
<h3 id="requiring-urls"><a class="header" href="#requiring-urls">Requiring URLs</a></h3>
<p>A URL (Uniform Resource <em>Locator</em>) is a specific and cooler version of a URI (Uniform Resource <em>Identifier</em>), because a URL tells you where you can find more information about this thing (hence <em>Locator</em>).</p>
<p>RDF allows any type of URIs for <code>subject</code> and <code>predicate</code> value, which means they can be URLs, but don't have to be.
This means they don't always resolve, or even function as locators.
The links don't work, and that restricts how useful the links are.
Atomic Data takes a different approach: these links MUST Resolve. Requiring <a href="https://atomicdata.dev/classes/Property">Properties</a> to resolve is part of what enables the type system of Atomic Schema - they provide the <code>shortname</code> and <code>datatype</code>.</p>
<p>Requiring URLs makes things easier for data users, but makes things a bit more difficult for the data producer.
With Atomic Data, the data producer MUST offer the data at the URL of the subject.
This is a challenge that requires tooling, which is why I've built <a href="https://crates.io/crates/atomic-server">Atomic-Server</a>: an easy to use, performant, open source data management sytem.</p>
<p>Making sure that links <em>actually work</em> offer tremendous benefits for data consumers, and that advantage is often worth the extra trouble.</p>
<h3 id="replace-blank-nodes-with-paths"><a class="header" href="#replace-blank-nodes-with-paths">Replace blank nodes with paths</a></h3>
<p>Blank (or anonymous) nodes are RDF resources with identifiers that exist only locally.
In other words, their identifiers are not URLs.
They are sometimes also called <code>anonymous nodes</code>.
They make life easier for data producers, who can easily create (nested) resources without having to mint all the URLs.
In most non-RDF data models, blank nodes are the default.
For example, we nest JSON object without thinking twice.</p>
<p>Unfortunately, blank nodes tend to make things harder for clients.
These clients will now need to keep track of where these blank nodes came from, and they need to create internal identifiers that will not collide.
Cache invalidation with blank nodes also becomes a challenge.
To make this a bit easier, Atomic Data introduces a new way of dealing with names of things that you have not given a URL yet: <a href="interoperability/../core/paths.html">Atomic Paths</a>.</p>
<p>Since Atomic Data has <code>subject-predicate</code> uniqueness (like JSON does, too), we can use the <em>path</em> of triples as a unique identifier:</p>
<pre><code>https://example.com/john https://schema.org/employer
</code></pre>
<p>This prevents collisions and still makes it easy to point to a specific value.</p>
<p>Serialization formats are free to use nesting to denote paths - which means that it is not necessary to include these path strings explicitly in most serialization formats, such as in JSON-AD.</p>
<h3 id="combining-datatype-and-predicate"><a class="header" href="#combining-datatype-and-predicate">Combining datatype and predicate</a></h3>
<p>Having both a <code>datatype</code> and a <code>predicate</code> value can lead to confusing situations.
For example, the <a href="https://schema.org/dateCreated"><code>schema:dateCreated</code></a> Property requires an ISO DateTime string (according to the schema.org definition), but using a value <code>true</code> with an <code>xsd:boolean</code> datatype results in perfectly valid RDF.
This means that client software using triples with a <code>schema:dateCreated</code> predicate cannot safely assume that its value will be a DateTime.
So if the client wants to use <code>schema:dateCreated</code> values, the client must also specify which type of data it expects, check the datatype field of every Atom and provide logic for when these don't match.
Also important combining <code>datatype</code> and <code>predicate</code> fits the model of most programmers and languages better - just look at how every single struct / model / class / shape is defined in programming languages: <code>key: datatype</code>.
This is why Atomic Data requires that a <code>predicate</code> links to a Property which must have a <code>Datatype</code>.</p>
<h3 id="adding-shortnames-slugs--keys-in-properties"><a class="header" href="#adding-shortnames-slugs--keys-in-properties">Adding shortnames (slugs / keys) in Properties</a></h3>
<p>Using full URI strings as keys (in RDF <code>predicates</code>) results in a relatively clunky Developer Experience.
Consider the short strings that developers are used to in pretty much all languages and data formats (<code>object.attribute</code>).
Adding a <em>required</em> / tightly integrated key mapping (from long URLs to short, simple strings) in Atomic Properties solves this issue, and provides developers a way to write code like this: <code>someAtomicPerson.bestFriend.name =&gt; &quot;Britta&quot;</code>.
Although the RDF ecosystem does have some solutions for this (@context objects in JSON-LD, @prefix mappings, the @ontologies library), these prefixes are not defined in Properties themselves and therefore are often defined locally or separate from the ontology, which means that developers have to manually map them most of the time.
This is why Atomic Data introduces a <code>shortname</code> field in Properties, which forces modelers to choose a 'key' that can be used in ORM contexts.</p>
<h3 id="adding-native-arrays"><a class="header" href="#adding-native-arrays">Adding native arrays</a></h3>
<p>RDF lacks a clear solution for dealing with <a href="https://ontola.io/blog/ordered-data-in-rdf/">ordered data</a>, resulting in confusion when developers have to create lists of content.
Adding an Array data type as a base data type helps solve this. (<a href="https://github.com/ontola/atomic-data/issues/4">discussion</a>)</p>
<h3 id="adding-a-native-state-changes-standard"><a class="header" href="#adding-a-native-state-changes-standard">Adding a native state changes standard</a></h3>
<p>There is no integrated standard for communicating state changes.
Although <a href="https://github.com/ontola/linked-delta">linked-delta</a> and <a href="https://afs.github.io/rdf-delta/">rdf-delta</a> do exist, they aren't referred to by the RDF spec.
I think developers need guidance when learning a new system such as RDF, and that's why <a href="interoperability/../commits/intro.html">Atomic Commits</a> is included in this book.</p>
<h3 id="adding-a-schema-language-and-type-safety"><a class="header" href="#adding-a-schema-language-and-type-safety">Adding a schema language and type safety</a></h3>
<p>A schema language is necessary to constrain and validate instances of data.
This is very useful when creating domain-specific standards, which can in turn be used to generate forms or language-specific types / interfaces.
Shape validations are already possible in RDF using both <a href="https://www.w3.org/TR/shacl/">SHACL</a> and <a href="https://shex.io/">SHEX</a>, and these are both very powerful and well designed.</p>
<p>However, with Atomic Data, I'm going for simplicity.
This also means providing an all-inclusive documentation.
I want people who read this book to have a decent grasp of creating, modeling, sharing, versioning and querying data.
It should provide all information that most developers (new to linked data) will need to get started quickly.
Simply linking to SHACL / SHEX documentation could be intimidating for new developers, who simply want to define a simple shape with a few keys and datatypes.</p>
<p>Also, SHACL requires named graphs (which are not specified in Atomic Data) and SHEX requires a new serialization format, which might limit adoption.
Atomic Data has some unique constrains (such as subject-predicate uniqueness) which also might make things more complicated when using SHEX / SHACL.</p>
<p><em>However</em>, it is not the intention of Atomic Data to create a modeling abstraction that is just as powerful as the ones mentioned above, so perhaps it is better to include a SHACL / SHEX tutorial and come up with a nice integration of both worlds.</p>
<h3 id="a-new-name-with-new-docs"><a class="header" href="#a-new-name-with-new-docs">A new name, with new docs</a></h3>
<p>Besides the technical reasons described above, I think that there are social reasons to start with a new concept and give it a new name:</p>
<ul>
<li>The RDF vocabulary is intimidating. When trying to understand RDF, you're likely to traverse many pages with new concepts: <code>literal</code>, <code>named node</code>, <code>graph</code>, <code>predicate</code>, <code>named graph</code>, <code>blank node</code>... The core specification provides a formal description of these concepts, but fails to do this in a way that results in quick understanding and workable intuitions. Even experienced RDF developers tend to be confused about the nuances of the core model.</li>
<li>There is a lack of learning resources that provide a clear, complete answer to the lifecycle of RDF data: modeling data, making data, hosting it, fetching it, updating it. Atomic Data aims to provide an opinionated answer to all of these steps. It feels more like a one-stop-shop for questions that developers are likely to encounter, whilst keeping the extendability.</li>
<li>All Core / Schema URLs should resolve to simple, clear explanations with both examples and machine readable definitions. Especially the Property and Class concepts.</li>
<li>The Semantic Web community has had a lot of academic attention from formal logic departments, resulting in a highly developed standard for knowledge modeling: the Web Ontology Language (OWL). While this is mostly great, its open-world philosophy and focus on reasoning abilities can confuse developers who are simply looking for a simple way to share models in RDF.</li>
</ul>
<h2 id="convert-rdf-to-atomic-data"><a class="header" href="#convert-rdf-to-atomic-data">Convert RDF to Atomic Data</a></h2>
<ul>
<li><strong>All the <code>subject</code> URLs MUST actually resolve, and return all triples about that subject</strong>. All <code>blank nodes</code> should be converted into URLs. Atomic Data tools might help to achieve this, for example by hosting the data.</li>
<li><strong>All <code>predicates</code> SHOULD resolve to Atomic Properties, and these SHOULD have a <code>datatype</code></strong>. You will probably need to change predicate URLs to Atomic Property URLs, or update the things that the predicate points to to include the required Atomic Property items (e.g. having a Datatype and a Shortname). This also means that the <code>datatype</code> in the original RDF statement can be dropped.</li>
<li>Literals with a <code>language</code> tag are converted to TranslationBox resources, which also means their identifiers must be created. Keep in mind that Atomic Data does not allow for blank nodes, so the TranslationBox identifiers must be URLs.</li>
</ul>
<p>Step by step, it entails:</p>
<ol>
<li>Set up some server to make sure the URLs will resolve.</li>
<li>Create (or find and refer to) Atomic Properties for all the <code>predicates</code>. Make sure they have a DataType and a Shortname.</li>
<li>If you have triples about a subject that you don't control, change the URL to some that you <em>can</em> control, and refer to that external resource.</li>
</ol>
<p>Atomic Data will need <a href="interoperability/../tooling.html">tooling</a> to facilitate in this process.
This tooling should help to create URLs, Properties, and host everything on an easy to use server.</p>
<h2 id="convert-atomic-data-to-rdf"><a class="header" href="#convert-atomic-data-to-rdf">Convert Atomic data to RDF</a></h2>
<p>Since all Atomic Data is also valid RDF, it's trivial to convert / serialize Atoms to RDF.
This is why <a href="https://github.com/joepio/atomic">atomic</a> can serialize Atomic Data to RDF. (For example, try <code>atomic-cli get https://atomicdata.dev/properties/description --as n3</code>)</p>
<p>However, contrary to Atomic Data, RDF has optional Language and Datatype elements in every statement.
It is good practice to use these RDF concepts when serializing Atomic Data into Turtle / RDF/XML, or other <a href="https://ontola.io/blog/rdf-serialization-formats/">RDF serialization formats</a>.</p>
<ul>
<li>Convert Atoms with linked <code>TranslationBox</code> Resources to Literals with an <code>xsd:string</code> datatype and the corresponding language in the tag.</li>
<li>Convert Atoms with ResourceArrays to <a href="https://ontola.io/blog/ordered-data-in-rdf/">Collections</a> that are native to that serialization format.</li>
<li>Dereference the Property and Datatype from Atomic Properties, and add the URLs in <code>datatypes</code> in RDF statements.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-data-and-solid"><a class="header" href="#atomic-data-and-solid">Atomic Data and Solid</a></h1>
<p>The <a href="https://solidproject.org/">Solid project</a> is an initiative by the inventor of linked data and the world wide web: sir Tim Berners-Lee.
In many ways, it has <strong>similar goals</strong> to Atomic Data:</p>
<ul>
<li>Decentralize the web</li>
<li>Make things more interoperable</li>
<li>Give people more control over their data</li>
</ul>
<p>Technically, both are also similar:</p>
<ul>
<li>Usage of <strong>personal servers</strong>, or PODs (Personal Online Datastores). Both Atomic Data and Solid aim to provide users with a highly personal server where all sorts of data can be stored.</li>
<li>Usage of <strong>linked data</strong>. All Atomic Data is valid RDF, which means that <strong>all Atomic Data is compatible with Solid</strong>. However, the other way around is more difficult. In other words, if you choose to use Atomic Data, you can always put it in your Solid Pod.</li>
</ul>
<p>But there are some important <strong>differences</strong>, too, which will be explained in more detail below.</p>
<ul>
<li>Atomic Data uses a strict built-in schema to ensure type safety</li>
<li>Atomic Data standardizes state changes (which also provides version control / history, audit trails)</li>
<li>Atomic Data is more easily serializable to other formats (like JSON)</li>
<li>Atomic Data has different models for authentication, authorzation and hierarchies</li>
<li>Atomic Data does not depend on existing semantic web specifications</li>
<li>Atomic Data is a smaller and younger project, and as of now a one-man show</li>
</ul>
<p><em>Disclaimer: I've been quite involved in the development of Solid, and have a lot of respect for all the people who are working on it.
Solid and RDF have been important inspirations for the design of Atomic Data.
The following is not meant as a critique on Solid, let alone the individuals working on it.</em></p>
<h2 id="atomic-data-is-type-safe-because-of-its-built-in-schema"><a class="header" href="#atomic-data-is-type-safe-because-of-its-built-in-schema">Atomic Data is type-safe, because of its built-in schema</a></h2>
<p>Atomic Data is more strict than Solid - which means that it only accepts data that conforms to a specific shape.
In a Solid Pod, you're free to add any shape of data that you like - it is not <em>validated</em> by some schema.
Yes, there are some efforts of using SHACL or SHEX to <em>constrain</em> data before putting it in, but as of now it is not part of the spec or any implementation that I know of.
A lack of schema strictness can be helpful during prototyping and rapid development, especially if you write data by hand, but it also limits how easy it is to build reliable apps with that data.
Atomic Data aims to be very friendly for developers that re-use data, and that's why we take a different approach: all data <em>must be</em> validated by Atomic Schema before it's stored on a server.
This means that all Atomic Properties will have to exist on a publicly accessible URL, before the property can be used somewhere.</p>
<p>You can think of Atomic Data more like a (dynamic) SQL database that offers guarantees about its content type, and a Solid Pod more like a document store that takes in all kinds of content.
Most of the differences have to do with how Atomic Schema aims to make linked data easier to work with, but that is covered in the previous <a href="interoperability/./rdf.html">RDF chapter</a>.</p>
<h2 id="atomic-data-standardizes-state-changes-event-sourcing"><a class="header" href="#atomic-data-standardizes-state-changes-event-sourcing">Atomic Data standardizes state changes (event sourcing)</a></h2>
<p>With Solid, you change a Resource by sending a POST request to the URL that you want to change.
With Atomic, you change a Resource by sending a signed Commit that contains the requested changes to a Server.</p>
<p>Event sourcing means that all changes are stored (persisted) and used to calculate the current state of things.
In practice, this means that users get a couple of nice features for free:</p>
<ul>
<li><strong>Versioning for all items by default</strong>. Storing events means that these events can be <em>replayed</em>, which means you get to traverse time / undo / redo.</li>
<li><strong>Edit / audit log for everything</strong>. Events contain information about who made which change at which point in time. Can be useful for finding out why things are the way they are.</li>
<li><strong>Easier to add query options / indexes</strong>. Any system can play-back the events, which means that the events can be used as an API to add new query options / fill new indexes. This is especially useful if you want to add things like full-text search, or some geolocation index.</li>
</ul>
<p>It also means that, compared to Solid, there is a relatively simple and strict API for changing data.
Atomic Data has a <strong>uniform write API</strong>.
All changes to data are done by posting Commits to the <code>/commits</code> endpoint of a Server.
This removes the need to think about differences between all sorts of HTTP methods like POST / PUT / PATCH, and how servers should reply to that.</p>
<p><em>EDIT: as of december 2021, Solid has introduced <code>.n3 patch</code> for standardizing state changes. Although this adds a uniform way of describing changes, it still lacks the power of Atomic Commits. It does not specify signatures, mention versioning, or deals with persisting changesets. On top of that, it is quite difficult to read or parse, being <code>.n3</code>.</em></p>
<h2 id="atomic-data-is-more-easily-serializable-to-other-formats-like-json"><a class="header" href="#atomic-data-is-more-easily-serializable-to-other-formats-like-json">Atomic Data is more easily serializable to other formats (like JSON)</a></h2>
<p>Atomic Data is designed with the modern (web)developer in mind.
One of the things that developers expect, is to be able to traverse (JSON) objects easily.
Doing this with RDF is not easily possible, because doing this requires <em>subject-predicate uniqueness</em>.
Atomic Data does not have this problem (properties <em>must</em> be unique), which means that traversing objects becomes easy.</p>
<p>Another problem that Atomic Data solves, is dealing with long URLs as property keys.
Atomic Data uses <code>shortnames</code> to map properties to short, human-readable strings.</p>
<p>For more information about these differences, see the previous <a href="interoperability/./rdf.html">RDF chapter</a>.</p>
<h2 id="authentication-1"><a class="header" href="#authentication-1">Authentication</a></h2>
<p>Both Solid an Atomic Data use URLs to refer to individuals / users / Agents.</p>
<p>Solid's identity system is called WebID.
There are multiple supported authentication protocols, the most common being <a href="https://github.com/solid/webid-oidc-spec">WebID-OIDC</a>.</p>
<p>Atomic Data's <a href="interoperability/../authentication.html">authentication model</a> is more similar to how SSH works.
Atomic Data identities (Agents) are a combination of HTTP based, and cryptography (public / private key) based.
In Atomic, all actions (from GET requests to Commits) are signed using the private key of the Agent.
This makes Atomic Data a bit more unconventional, but also makes its auth mechanism very decentralized and lightweight.</p>
<h2 id="hierarchy-and-authorization"><a class="header" href="#hierarchy-and-authorization">Hierarchy and authorization</a></h2>
<p>Atomic Data uses <code>parent-child</code> <a href="interoperability/../hierarchy.html">hierarchies</a> to model data structures and perform authorization checks.
This closely resembles how filesystems work (including things like Google Drive).
Per resource, <code>write</code> and <code>read</code> rights can be defined, which both contain lists of Agents.</p>
<p>Solid is working on the <a href="https://shapetrees.org/TR/specification/">Shape Trees</a> spec, which also describes hierarchies.
It uses SHEX to perform shape validation, similar to how Atomic Schema does.</p>
<h2 id="no-dependency-on-existing-semantic-web-specifications"><a class="header" href="#no-dependency-on-existing-semantic-web-specifications">No dependency on existing semantic web specifications</a></h2>
<p>The Solid specification (although still in draft) builds on a 20+ year legacy of committee meetings on semantic web standards such as RDF, SPARQL, OWL and XML.
I think the process of designing specifications in <a href="https://en.wikipedia.org/wiki/Design_by_committee">various (fragmented) committees</a> has led to a set of specifications that lack simplicity and consistency.
Many of these specifications have been written long before there were actual implementations.
Much of the effort was spent on creating highly formal and abstract descriptions of common concepts, but too little was spent on making specs that are easy to use and solve actual problems for developers.</p>
<p>Aaron Scharz (co-founder or reddit, inventor of RSS and Markdown) wrote this in his <a href="https://ieeexplore.ieee.org/document/6814657">unfinished book 'A Programmable Web'</a>:</p>
<blockquote>
<p>Instead of the lets just build something that works attitude that made the Web (and the Internet) such a roaring success, they brought the formalizing mindset of mathematicians and the institutional structures of academics and defense
contractors.
They formed committees to form working groups to write drafts of ontologies that carefully listed (in 100-page Word documents) all possible things in the universe and the various properties they could have, and they spent hours in Talmudic debates over whether a washing machine was a kitchen appliance or a household cleaning device.</p>
</blockquote>
<p>(The book is a great read on this topic, by the way!)</p>
<p>So, in a nutshell, I think this legacy makes Solid unnecessarily hard to use for developers, for the following reasons:</p>
<ul>
<li><strong>RDF Quirks</strong>: Solid has to deal with all the <a href="interoperability/./rdf.html">complexities of the RDF data model</a>, such as blank nodes, named graphs, subject-predicate duplication.</li>
<li><strong>Multiple (uncommon) serialization formats</strong> need to be understood, such as <code>n3</code>, <code>shex</code> and potentially all the various RDF serialization formats. These will feel foreign to most (even very experienced) developers and can have a high degree of complexity.</li>
<li><strong>A heritage of broken URLs</strong>. Although a lot if RDF data exists, only a small part of it is actually resolvable as machine-readable RDF. The large majority won't give you the data when sending a HTTP GET request with the correct <code>Accept</code> headers to the subject's URL. Much of it is stored in documents on a different URL (<code>named graphs</code>), or behind some SPARQL endpoint that you will first need to find. Solid builds on a lot of standards that have these problems.</li>
<li><strong>Confusing specifications</strong>. Reading up on RDF, Solid, and the Semantic Web can be a daunting (yet adventurous) task. I've seen many people traverse a similar path as I did: read the RDF specs, dive into OWL, install protege, create ontologies, try doing things that OWL doesn't do (validate data), read more complicated specs that don't help to clear things, become frustrated... It's a bit of a rabbit hole, and I'd like to prevent people from falling into it. There's a lot of interesting ideas there, but it is not a pragmatic framework to develop interoperable apps with.</li>
</ul>
<h2 id="atomic-data-and-solid-server-implementations"><a class="header" href="#atomic-data-and-solid-server-implementations">Atomic Data and Solid server implementations</a></h2>
<p>Both Atomic Data and Solid are specifications that have different implementations.
Some open source Solid implementations are the <a href="https://github.com/solid/node-solid-server">Node Solid Server</a>, the <a href="https://github.com/solid/community-server">Community Solid Server</a> (also nodejs based) and the <a href="https://gitlab.com/ontola/dexpod">DexPod</a> (Ruby on Rails based).</p>
<p><a href="https://github.com/joepio/atomic-data-rust/">Atomic-Server</a> is a database + server written in the Rust programming language, that can be considered an alternative to Solid Pod implementations.
It was definitely built to be one, at least.
It implements every part of the Atomic Data specification.
I believe that as of today (february 2022), Atomic-Server has quite a few advantages over existing Solid implementations:</p>
<ul>
<li><strong>Dynamic schema validation</strong> / type checking using <a href="https://docs.atomicdata.dev/schema/intro.html">Atomic Schema</a>, combining the best of RDF, JSON and type safety.</li>
<li><strong>Fast</strong> (1ms responses on my laptop)</li>
<li><strong>Lightweight</strong> (15MB binary, no runtime dependencies)</li>
<li><strong>HTTPS + HTTP2 support</strong> with Built-in LetsEncrypt handshake.</li>
<li><strong>Browser GUI included</strong> powered by <a href="https://github.com/joepio/atomic-data-browser">atomic-data-browser</a>. Features dynamic forms, tables, authentication, theming and more. Easy to use!</li>
<li><strong>Event-sourced versioning</strong> / history powered by <a href="https://docs.atomicdata.dev/commits/intro.html">Atomic Commits</a></li>
<li><strong>Many serialization options</strong>: to JSON, <a href="https://docs.atomicdata.dev/core/serialization.html#json-ad">JSON-AD</a>, and various Linked Data / RDF formats (RDF/XML, N-Triples / Turtle / JSON-LD).</li>
<li><strong>Full-text search</strong> with fuzzy search and various operators, often &lt;3ms responses.</li>
<li><strong>Pagination, sorting and filtering</strong> using <a href="https://docs.atomicdata.dev/schema/collections.html">Atomic Collections</a></li>
<li><strong>Invite and sharing system</strong> with <a href="https://docs.atomicdata.dev/invitations.html">Atomic Invites</a></li>
<li><strong>Desktop app</strong> Easy desktop installation, with status bar icon, powered by <a href="https://github.com/tauri-apps/tauri/">tauri</a>.</li>
<li><strong>MIT licensed</strong> So fully open-source and free forever!</li>
</ul>
<h2 id="things-that-atomic-data-misses-but-solid-has"><a class="header" href="#things-that-atomic-data-misses-but-solid-has">Things that Atomic Data misses, but Solid has</a></h2>
<p>Atomic Data is not even two years old, and although progress has been fast, it does lack some specifications.
Here's a list of things missing in Atomic Data, with links to their open issues and links to their existing Solid counterpart.</p>
<ul>
<li>No inbox or <a href="https://www.w3.org/TR/ldn/">notifications</a> yet (<a href="https://github.com/ontola/atomic-data/issues/28">issue</a>)</li>
<li>No OIDC support yet. (<a href="https://github.com/joepio/atomic-data-rust/issues/277">issue</a>)</li>
<li>No support from a big community, a well-funded business or the inventor of the world wide web.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-does-atomic-data-relate-to-json"><a class="header" href="#how-does-atomic-data-relate-to-json">How does Atomic Data relate to JSON?</a></h1>
<p>Because JSON is so popular, Atomic Data is designed with JSON in mind.</p>
<p>Atomic Data is often (by default) serialized to <a href="interoperability/../core/json-ad.html">JSON-AD</a>, which itself uses JSON.
JSON-AD uses URLs as keys, which is what gives Atomic Data many of its perks, but using these long strings as keys is not very easy to use in many contexts.
That's why you can serialize Atomic Data to simple, clean JSON.</p>
<h2 id="from-atomic-data-to-plain-json"><a class="header" href="#from-atomic-data-to-plain-json">From Atomic Data to plain JSON</a></h2>
<p>The JSON keys are then derived from the <code>shortnames</code> of properties.
For example, we could convert this JSON-AD:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://atomicdata.dev/properties/description&quot;,
  &quot;https://atomicdata.dev/properties/datatype&quot;: &quot;https://atomicdata.dev/datatypes/markdown&quot;,
  &quot;https://atomicdata.dev/properties/description&quot;: &quot;A textual description of something. When making a description, make sure that the first few words tell the most important part. Give examples. Since the text supports markdown, you're free to use links and more.&quot;,
  &quot;https://atomicdata.dev/properties/isA&quot;: [
    &quot;https://atomicdata.dev/classes/Property&quot;
  ],
  &quot;https://atomicdata.dev/properties/shortname&quot;: &quot;description&quot;
}
</code></pre>
<p>... into this plain JSON:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://atomicdata.dev/properties/description&quot;,
  &quot;datatype&quot;: &quot;https://atomicdata.dev/datatypes/markdown&quot;,
  &quot;description&quot;: &quot;A textual description of something. When making a description, make sure that the first few words tell the most important part. Give examples. Since the text supports markdown, you're free to use links and more.&quot;,
  &quot;is-a&quot;: [
    &quot;https://atomicdata.dev/classes/Property&quot;
  ],
  &quot;shortname&quot;: &quot;description&quot;
}
</code></pre>
<p>Note that when you serialize Atomic Data to plain JSON, some information is lost: the URLs are no longer there.
This means that it is no longer possible to find out what the datatype of a single value is - we now only know if it's a <code>string</code>, but not if it actually represents a markdown string or something else.
Most Atomic Data systems will therefore <em>not</em> use this plain JSON serialization, but for some clients (e.g. a front-end app), it might be easier to use the plain JSON, as the keys are easier to write than the long URLs that JSON-AD uses.</p>
<h2 id="from-json-to-json-ad"><a class="header" href="#from-json-to-json-ad">From JSON to JSON-AD</a></h2>
<p>Atomic Data requires a bit more information about pieces of data than JSON tends to contain. Let's take a look at a regular JSON example:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;John&quot;,
  &quot;birthDate&quot;: &quot;1991-01-20&quot;
}
</code></pre>
<p>We need more information to convert this JSON into Atomic Data.
The following things are missing:</p>
<ul>
<li>What is the <strong>Subject</strong> URL of the resource being described?</li>
<li>What is the <strong>Property</strong> URL of the keys being used? (<code>name</code> and <code>birthDate</code>), and consequentially, how should the values be parsed? What are their DataTypes?</li>
</ul>
<p>In order to make this conversion work, we need to link to three URLs that <em>resolve to atomic data resources</em>.
The <code>@id</code> subject should resolve to the Resource itself, returning the JSON-AD from below.
The Property keys (e.g. &quot;https://example.com/properties/name&quot;) need to resolve to Atomic Properties.</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/people/john&quot;,
  &quot;https://example.com/properties/name&quot;: &quot;John&quot;,
  &quot;https://example.com/properties/birthDate&quot;: &quot;1991-01-20&quot;
}
</code></pre>
<p>In practice, the easiest approach to make this conversion, is to create the data and host it using software like <a href="https://github.com/joepio/atomic/blob/master/server/README.md">Atomic Server</a>.</p>
<h2 id="from-atomic-data-to-json-ld"><a class="header" href="#from-atomic-data-to-json-ld">From Atomic Data to JSON-LD</a></h2>
<p>Atomic Data is a strict subset of RDF, and the most popular serialization of RDF for JSON data is <a href="https://json-ld.org/">JSON-LD</a>.</p>
<p>Since Atomic Schema requires the presence of a <code>key</code> slug in Properties, converting Atomic Data to JSON results in dev-friendly objects with nice shorthands.</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/people/John&quot;,
  &quot;https://example.com/properties/lastname&quot;: &quot;John&quot;,
  &quot;https://example.com/properties/bestFriend&quot;: &quot;https://example.com/sarah&quot;,
}
</code></pre>
<p>Can be automatically converted to:</p>
<pre><code class="language-json">{
  &quot;@context&quot;: {
    &quot;@id&quot;: &quot;https://example.com/people/John&quot;,
    &quot;name&quot;: &quot;https://example.com/properties/lastname&quot;,
    &quot;bestFriend&quot;: &quot;https://example.com/properties/bestFriend&quot;,
  },
  &quot;name&quot;: &quot;John&quot;,
  &quot;bestFriend&quot;: {
    &quot;@id&quot;: &quot;https://example.com/sarah&quot;
  },
}
</code></pre>
<p>The <code>@context</code> object provides a <em>mapping</em> to the original URLs.</p>
<p>JSON-AD and JSON-LD are very similar by design, but there are some important differences:</p>
<ul>
<li>JSON-AD is designed just for atomic data, and is therefore easier and more performant to parse / serialize.</li>
<li>JSON-LD uses <code>@context</code> to map keys to URLs. Any type of mapping is valid. JSON-AD, on the other hand, doesn't map anything - all keys are URLs.</li>
<li>JSON-LD uses nested objects for links and sequences, such as <code>@list</code>. JSON-AD does not.</li>
<li>Arrays in JSON-LD do not indicate ordered data - they indicate that for some subject-predicate combination, multiple values exist. This is a result of how RDF works.</li>
</ul>
<h2 id="json-ld-requirements-for-valid-atomic-data"><a class="header" href="#json-ld-requirements-for-valid-atomic-data">JSON-LD Requirements for valid Atomic Data</a></h2>
<ul>
<li>Make sure the URLs used in the <code>@context</code> resolve to Atomic Properties.</li>
</ul>
<!-- Not sure about this.. maybe use RDF collections or some other model? -->
<ul>
<li>Convert JSON-LD arrays into ResourceArrays</li>
<li>Creating nested JSON objects is possible (by resolving the identifiers from <code>@id</code> relations), but it is up to the serializer to decide how deep this object nesting should happen.</li>
</ul>
<p>Note that as of now, there are no JSON-LD parsers for Atomic Data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-data-and-ipfs"><a class="header" href="#atomic-data-and-ipfs">Atomic Data and IPFS</a></h1>
<h2 id="what-is-ipfs"><a class="header" href="#what-is-ipfs">What is IPFS</a></h2>
<p>IPFS (the InterPlanetary File System) is a standard that enables decentralized file storage and retrieval using content-based identifiers.
Instead of using an HTTP URL like <code>http://example.com/helloworld</code>, it uses the IPFS scheme, such as <code>ipfs:QmX6j9DHcPhgBcBtZsuRkfmk2v7G5mzb11vU9ve9i8vDsL</code>.
IPFS identifies things based on their unique content hash (the long, seemingly random string) using a thing called a Merkle DAG (<a href="https://medium.com/textileio/whats-really-happening-when-you-add-a-file-to-ipfs-ae3b8b5e4b0f#:%7E:text=In%20practice%2C%20content%20addressing%20systems,function%2C%20to%20produce%20a%20digest.&amp;text=From%20raw%20image%20to%20cryptographic%20digest%20to%20content%20id%20(multihash).">this great article</a> explains it nicely).
This is called a <a href="https://github.com/multiformats/cid">CID</a>, or Content ID.
This simple idea (plus some not so simple network protocols) allows for decentralized, temper-proof storage of data.
This fixes some issues with HTTP that are related to its centralized philosophy: <strong>no more 404s</strong>!</p>
<h2 id="why-is-ipfs-interesting-for-atomic-data"><a class="header" href="#why-is-ipfs-interesting-for-atomic-data">Why is IPFS interesting for Atomic Data</a></h2>
<p>Atomic Data is highly dependent on the availability of Resources, especially Properties and Datatypes.
These resources are meant to be re-used a lot, and when these go offline or change (for whatever reason), it could cause issues and confusion.
IPFS guarantees that these resources are entirely static, which means that they cannot change.
This is useful when dealing with Properties, as a change in datatype could break things.
IPFS also allows for location-independent fetching, which means that resources can be retrieved from any location, as long as it's online.
This Peer-to-peer functionality is a very fundamental advantage of IPFS over HTTP, especially when the resources are very likely to be re-use, which is <em>especially</em> the case for Atomic Data Properties.</p>
<h2 id="considerations-using-ipfs-urls"><a class="header" href="#considerations-using-ipfs-urls">Considerations using IPFS URLs</a></h2>
<p>IPFS URLs are <strong>static</strong>, which means that their contents can never change.
This is great for some types of data, but not so much for others.
If you're describing a time-dependent thing (such as a person's job), you'll probably want to know what the <em>current</em> value is, and that is not possible when you only have an IPFS identifier.
This can be fixed by including an HTTP URL in IPFS bodies.</p>
<p>IPFS data is also <strong>hard to remove</strong>, as it tends to be replicated across machines.
If you're describing personal, private information, it can therefore be a bad idea to use IPFS.</p>
<p>And finally, its <strong>performance</strong> is typically not as good as HTTP.
If you know the IPFS gateway that hosts the IPFS resource that you're looking for, things improve drastically.
Luckily for Atomic Data, this is often the case, as we know the HTTP url of the server and could try whether that server has an IPFS gateway.</p>
<h2 id="atomic-data-and-ipld"><a class="header" href="#atomic-data-and-ipld">Atomic Data and IPLD</a></h2>
<p>IPLD (not IPFS) stands for InterPlanetary Linked Data, but is not related to RDF.
The scope seems fundamentally different from RDF, too, but I have to read more about this.</p>
<h2 id="share-your-thoughts"><a class="header" href="#share-your-thoughts">Share your thoughts</a></h2>
<p>Discuss on <a href="https://github.com/ontola/atomic-data-docs/issues/42">this issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-data-and-sql"><a class="header" href="#atomic-data-and-sql">Atomic Data and SQL</a></h1>
<p>Atomic Data has some characteristics that make it similar and different from SQL.</p>
<ul>
<li>Atomic Data has a <em>dynamic</em> schema. Any Resource could have different properties, so you can <strong>add new properties</strong> to your data without performing any migrations. However, the properties themselves are still validated (contrary to most NoSQL solutions)</li>
<li>Atomic Data uses <strong>HTTP URLs</strong> in its data, which means it's easy to <strong>share and reuse</strong>.</li>
<li>Atomic Data separates <em>reading</em> and <em>writing</em>, whereas SQL has one language for both.</li>
<li>Atomic Data has a standardized way of <strong>storing changes</strong> (<a href="interoperability/../commits/intro.html">Commits</a>)</li>
</ul>
<h2 id="tables-and-rows-vs-classes-and-properties"><a class="header" href="#tables-and-rows-vs-classes-and-properties">Tables and Rows vs. Classes and Properties</a></h2>
<p>At its core, SQL is a query language based around <em>tables</em> and <em>rows</em>.
The <em>tables</em> in SQL are similar to <code>Classes</code> in Atomic Data: they both define a set of <code>properties</code> which an item could have.
Every single item in a table is called a <em>row</em> in SQL, and a <code>Resource</code> in Atomic Data.
One difference is that in Atomic Data, you can add new properties to resources, without making changes to any tables (migrations).</p>
<h2 id="dynamic-vs-static-schema"><a class="header" href="#dynamic-vs-static-schema">Dynamic vs static schema</a></h2>
<p>In SQL, the schema of the database defines which shape the data can have, which properties are required, what datatypes they have.
In Atomic Data, the schema exists as a Resource on the web, which means that they can be retrieved using HTTP.
An Atomic Database (such as <a href="https://crates.io/crates/atomic-server">Atomic-Server</a>) uses a <em>dynamic schema</em>,
which means that any Resource can have different properties, and the properties themselves can be validated, even when the server is not aware of these properties beforehand.
In SQL, you'd have to manually adjust the schema of your database to add a new property.
Atomic Data is a decentralized, open system, which can read new schema data from other sources.
SQL is a centralized, closed system, which relies on the DB manager to define the schema.</p>
<h2 id="identifiers-numbers-vs-urls"><a class="header" href="#identifiers-numbers-vs-urls">Identifiers: numbers vs. URLs</a></h2>
<p>In SQL, rows have numbers as identifiers, whereas in Atomic Data, every resource has a resolvable HTTP URL as an identifier.
URLs are great identifiers, because you can open them and get more information about something.
This means that with Atomic Data, other systems can re-use your data by referencing to it, and you can re-use data from other systems, too.
With Atomic Data, you're making your data part of a bigger <em>web of data</em>, which opens up a lot of possibilities.</p>
<h2 id="atomic-server-combines-server-and-database"><a class="header" href="#atomic-server-combines-server-and-database">Atomic Server combines server and database</a></h2>
<p>If you're building an App with SQL, you will always need some server that connects to your database.
If you're building an App with Atomic Server, the database can function as your server, too. It deals with authentication, authorization, and more.</p>
<h2 id="querying"><a class="header" href="#querying">Querying</a></h2>
<p>The SQL query language is for both <em>reading</em> and <em>writing</em> data.
In Atomic Data a distinction is made between Query and Command - getting and setting (Command Query Responsibility Segregation, <a href="https://martinfowler.com/bliki/CQRS.html">CQRS</a>).
The <a href="interoperability/../core/querying.html">Query side</a> is handled using Subject Fetching (sending a GET request to a URL, to get a single resource) and <a href="interoperability/../schema/collections.html">Collections</a> (filtering and sorting data).
The Command side is typically done using <a href="interoperability/../commits/intro.html">Atomic Commits</a>, although you're free not to use it.</p>
<p>SQL is way more powerful, as a query language.
In SQL, the one creating the query basically defines the shape of a table that is requested, and the database returns that shape.
Atomic Data does not offer such functionality.
So if you need to create custom tables at runtime, you might be better off using SQL, or move your Atomic Data to a query system.</p>
<h2 id="convert-an-sql-database-to-atomic-data"><a class="header" href="#convert-an-sql-database-to-atomic-data">Convert an SQL database to Atomic Data</a></h2>
<p>If you want to make your existing SQL project serve Atomic Data, you can keep your existing SQL database, see <a href="interoperability/upgrade.html">the upgrade guide</a>.
It basically boils down to mapping the rows (properties) in your SQL tables to Atomic Data <a href="https://atomicdata.dev/classes/Property">Properties</a>.</p>
<p>When you want to <em>import arbitrary Atomic Data</em>, though, it might be easier to use <code>atomic-server</code>.
If you want to store arbitrary Atomic Data in a SQL database, you might be best off by creating a <code>Resources</code> table with a <code>subject</code> and a <code>propertyValues</code> column, or create both a <code>properties</code> table and a <code>resources</code> one.</p>
<h2 id="limitations-of-atomic-data"><a class="header" href="#limitations-of-atomic-data">Limitations of Atomic Data</a></h2>
<ul>
<li>SQL is far more common, many people will know how to use it.</li>
<li>SQL databases are battle-tested and has been powering countless of products for tens of years, whereas Atomic Server is at this moment in beta.</li>
<li>SQL databases have a more powerful and expressive query language, where you can define tables in your query and combine resources.</li>
</ul>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<h3 id="is-atomic-data-nosql-or-sql"><a class="header" href="#is-atomic-data-nosql-or-sql">Is Atomic Data NOSQL or SQL?</a></h3>
<p>Generally, Atomic Data apps do not use SQL - so they are NOSQL.
Atomic-server, for example, internally uses a key-value store (sled) for persistence.</p>
<p>Like most NOSQL systems, Atomic Data does not limit data entries to a specific table shape, so you can add any property that you like to a resource.
However, unlike most NOSQL systems, Atomic Data <em>does</em> perform validations on each value.
So in a way, Atomic Data tries to combine best of both worlds: the extendibility and flexibility of NOSQL, with the type safety of SQL.</p>
<h3 id="is-atomic-data-transactional--acid"><a class="header" href="#is-atomic-data-transactional--acid">Is Atomic Data transactional / ACID?</a></h3>
<p>Yes, if you use Atomic-Server, then you can only write to the server by using Atomic Commits, which are in fact transactions.
This means that if part of the transaction fails, it is reverted - transactions are only applied when they are 100% OK.
This prevents inconsistent DB states.</p>
<h3 id="how-does-atomic-server-build-indexes-for-its-resources-if-the-schema-is-not-known-in-advance"><a class="header" href="#how-does-atomic-server-build-indexes-for-its-resources-if-the-schema-is-not-known-in-advance">How does Atomic Server build indexes for its resources if the schema is not known in advance</a></h3>
<p>It creates indexed collections when users perform queries.
This means that the first time your perform some type of query (that sorts and filters by some properties), it will be slow, but the next time you perform a similar query, it will be fast.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-data-and-graph-databases"><a class="header" href="#atomic-data-and-graph-databases">Atomic Data and Graph Databases</a></h1>
<p>Atomic Data fundamentally is a <em>graph data model</em>.
We can think of Atomic Resources as <em>nodes</em>, and links to other resources through <em>properties</em> as <em>edges</em>.</p>
<p>In this section, we'll explore how Atomic Data relates to some graph technologies.</p>
<h2 id="comparing-atomic-data-to-neo4j"><a class="header" href="#comparing-atomic-data-to-neo4j">Comparing Atomic Data to Neo4j</a></h2>
<p>Neo4j is a popular graph database that supports multiple query languages.
The first difference is that Atomic Data is not a single piece of software but a <em>specification</em>.
However, we can compare Neo4j as a <em>product</em> with the open source <a href="https://crates.io/crates/atomic-server">Atomic-Server</a>.
Atomic-Server is fully open source and free (MIT licensed), whereas Neo4j is partially open source and GPL licensed.</p>
<h3 id="labeled-property-graph"><a class="header" href="#labeled-property-graph">Labeled Property Graph</a></h3>
<p>The data model of Neo4j features a <em>labeled property graph</em>, which means that edges (relationships between nodes) can have their own properties.
This can be useful when adding data to relationship between nodes.
For example: in the <code>john - (knows) -&gt; mary</code> relationship, you might want to specify <em>for how long</em> they have known each other.
In Neo4j, we can add this data to the labeled property graph.</p>
<p>In Atomic Data, we'd have to make a new resource to describe the relation between the two, if we wanted to add information about the relationship itself.
This is called <em>reification</em>.
This process can be time consuming, especially in Atomic Data, as this means that you'll have to specify the Class of this relationship and its properties.
However, one benefit of this approach, is that the relationship itself becomes clearly defined and re-usable.
Another benefit is that the simpler model of Atomic Data maps perfectly to datamodels like JSON, which makes things very convenient and familiar for developers.</p>
<h3 id="query-language-vs-rest"><a class="header" href="#query-language-vs-rest">Query language vs REST</a></h3>
<p>Neo4j supports multiple query languages, but its mainly known for <em>Cypher</em>.
It is used for doing practically everything: reading, writing, modelling, and more.</p>
<p>Atomic Data on the other hand does not have a query language.
It uses a RESTful HTTP + JSON-AD approach for everything.
Atomic Data uses <a href="interoperability/../endpoints.html">Endpoints</a> for specific goals that you'd do in a query language:</p>
<ul>
<li><a href="interoperability/../schema/collections.html">Collections</a> (which can filter by Property or Value, and sort by any Property) to generate lists of resources</li>
<li><a href="interoperability/../core/paths.html">Paths</a> for traversing graphs by property</li>
</ul>
<p>And finally, data is written using <a href="interoperability/../commits/intro.html">Commits</a>.
Commits are very strict, as each one describes modifications to individual resources, and every Commits has to be signed.
This means that with Atomic Data, we get <em>versioning + audit trails</em> for all data, but at the cost of more storage requirements and a bit more expensive write process.</p>
<h3 id="schema-language-and-type-safety"><a class="header" href="#schema-language-and-type-safety">Schema language and type safety</a></h3>
<p>In Neo4j, constraints can be added to the database by
Atomic Data uses Atomic Schema for validating datatypes and required properties in resources.</p>
<h3 id="other-differences"><a class="header" href="#other-differences">Other differences</a></h3>
<ul>
<li>Atomic Data has an <a href="interoperability/../agents.html">Authentication model</a> and <a href="interoperability/../hierarchy.html">Hierarchy model</a> for authorization. Neo4j uses <a href="https://neo4j.com/docs/operations-manual/current/authentication-authorization/built-in-roles/#auth-built-in-roles">roles</a>.</li>
<li>Neo4j is actually used in production by many big organizations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="various-use-cases-for-atomic-data"><a class="header" href="#various-use-cases-for-atomic-data">Various Use Cases for Atomic Data</a></h1>
<p>Most of this book is either abstract or technical, but this section aims to be different.
In this section, we'll present concrete examples of things that can be built with Atomic Data.
Although you could use Atomic Data for pretty much any type of application, it is especially valuable where <strong>data re-use</strong>, <strong>standardization</strong>, and <strong>data ownership</strong> are important.</p>
<!-- This should align with SUMMARY.md -->
<ul>
<li><a href="usecases/personal-data-store.html">Personal Data Store</a></li>
<li><a href="usecases/e-commerce.html">E-commerce &amp; marketplaces</a></li>
<li><a href="usecases/surveys.html">Surveys</a></li>
<li><a href="usecases/verifiable-credentials.html">Verifiable Credentials</a></li>
<li><a href="usecases/food-labels.html">Food labels</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-data-for-personal-data-stores"><a class="header" href="#atomic-data-for-personal-data-stores">Atomic Data for personal data stores</a></h1>
<p>A Personal Data Store (or personal data service) is a place where you store all sorts of personal information.
For example a list of contacts, todo items, pictures, or your profile data.
Not that long ago, the default for this was the <code>my Documents</code> folder on your hard drive.
But as web applications became better, we started moving our data to the cloud.
More and more of our personal information is stored by large corporations who use the information to build profiles to show us ads.
And as cloud consumers, we often don't have the luxury of moving our personal data to a place to where we want it to be.
Many services don't even provide export functionality, and even if they do, the exports often lack information or are not interoperable with other apps.</p>
<p>Atomic Data could help to re-introduce data ownership.
Because the specification helps to standardize information, it becomes easier to make data interoperable.
And even more important: Apps don't need their own back-end - they can use the same personal data store: an Atomic Server (such as <a href="https://github.com/joepio/atomic/blob/master/server/README.md">this one</a>).</p>
<p>Realizing this goal requires quite a bit of work, though.
This specification needs to mature, and we need reliable implementations.
We also need proper tutorials, libraries and tools that convince developers to use atomic data to power their applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-data-for-e-commerce--marketplaces"><a class="header" href="#atomic-data-for-e-commerce--marketplaces">Atomic Data for e-commerce &amp; marketplaces</a></h1>
<p>Buying good and services on the internet is currently responsible for about 15% of all commerce, and is steadily climbing.
The internet makes it easier to find products, compare prices, get information and reviews, and finally order something.
But the current e-commerce situation is far from perfect, as large corporations tend to monopolize, which means that we have less competition which ultimately harms prices and quality for consumers.
Atomic Data can help empower smaller businesses, make searching for specific things way easier and ultimately make things cheaper for everyone.</p>
<h2 id="decentralize-platform--sharing-economy-service-marketplaces"><a class="header" href="#decentralize-platform--sharing-economy-service-marketplaces">Decentralize platform / sharing economy service marketplaces</a></h2>
<p>Platforms like Uber, AirBNB and SnapCar are virtual marketplaces that help people share and find services.
These platforms are responsible for:</p>
<ol>
<li>providing an interface for <strong>managing offers</strong> (e.g. describe your car, add specifications and pricing)</li>
<li><strong>hosting</strong> the data of the offers themselves (make the data available on the internet)</li>
<li>providing a <strong>search interface</strong> (which means indexing the data from all the existing offers)</li>
<li>facilitating the <strong>transaction</strong> / payments</li>
<li>provide <strong>trust</strong> through reviews and warranties (e.g. refunds if the seller fails to deliver)</li>
</ol>
<p>The fact that these responsibilities are almost always combined in a single platforms leads to vendor lock-in and an uncompetitive landscape, which ultimately harms consumers.
Currently, if you want to manage your listing / offer on various platforms, you need to manually adjust it on all these various platforms.
Some companies even prohibit offering on multiple platforms (which is a legal problem, not a technical one).
This means that the biggest (most known) platforms have the most listings, so if you're looking for a house / car / rental / meal, you're likely to go for the biggest business - because that's the one that has the biggest assortment.</p>
<p>Compare this to how the web works: every browser should support every type of webpage, and it does not matter where the webpage is hosted.
I can browse a webpage written on a mac on my windows machine, and I can read a webpage hosted by amazon on an google device.
It does not matter, because the web is <em>standardized</em> and <em>open</em>, instead of being <em>centralized</em> and managed by one single company as <em>proprietary</em> data.
This openness of the web means that we get search engines like Google and Bing that <em>scrape</em> the web and add it to their index.
This results in a dynamic where those who want to sell their stuff will need to share their stuff using an open standard (for webpages things like HTML and sometimes a bit of metadata), so crawlers can properly index the webpages.
We could do the same thing for <em>structured data</em> instead of <em>pages</em>, and that's what Atomic Data is all about.</p>
<p>Let's discuss a more practical example of what this could mean.
Consider a restaurant owner who currently uses UberEats as their delivery platform.
Using Atomic Data, they could define their menu on their own website.
The Atomic Schema specification makes it easy to standardize how the data of a menu item looks like (e.g. price, image, title, allergens, vegan...).
Several platforms (potentially modern variants of platforms like JustEat / UberEats) could then crawl this standardized Atomic Data, index it, and make it easily searchable.
The customer would use one (or multiple) of these platforms, that would probably have the <em>exact same</em> offers.
Where these platforms might differ, is in their own service offering, such as delivery speed or price.
This would result in a more competitive and free market, where customers would be able to pick a platform based on their service price and quality, instead of their list of offerings.
It would empower the small business owner to be far more flexible in which service they will do business with.</p>
<h2 id="highly-personalized-and-customizable-search"><a class="header" href="#highly-personalized-and-customizable-search">Highly personalized and customizable search</a></h2>
<p>Searching for products on the internet is mostly limited to text search.
If we want to buy a jacket, we see tonnes of jackets that are not even available in our own size.
Every single website has their own way of searching and filtering.</p>
<p>Imagine making a search query in <em>one</em> application, and sending that to <em>multiple suppliers</em>, after you'll receive a fully personalized and optimized list of products.
Browsing in an application that you like to use, not bound to any one specific store, that doesn't track you, and doesn't show advertisements.
It is a tool that helps you to find what you need, and it is the job of producers to accurately describe their products in a format that your product browser can understand.</p>
<p>How do we get there?</p>
<p>Well, for starters, producers and suppliers will need to reach a consensus on <em>how to describe their articles</em>.
This is not new; for many products, we already have a common language.
Shoes have a shoe size, televisions have a screen size in diagonal inches, brightness is measured in nits, etc.
Describing this in a machine-readable and predictable format as data is the next logical step.
This is, of course, where Atomic Schema could help.
Atomic-server could be the connected, open source database that suppliers use to describe their products as data.</p>
<!--
## Product specific updates after purchase

Imagine buying an external battery pack with a production error.
All units with a serial number between 1561168 and 1561468 have a serious error, where overcharging could lead to spontaneous combustion.
This is something that you'd like to know.
But how would the _manufacturer_ of that resource know where to find you?
Well, if your Atomic Server would have a list of all the things that you've bought, it could _automatically_ subscribe to safety updates from all manufacturers.
When any of these manufacturers would publish a safety warning about a product that you possess, you'll get an alert.

## Product lifecycle insights

Imagine buying a product, and being able to see where each part came from.
The car that you buy might contain a list of all the maintenance moments, and every replaced part. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-data-for-surveys"><a class="header" href="#atomic-data-for-surveys">Atomic Data for Surveys</a></h1>
<p>Surveys and Questionnaires haven't been evolving that much over the past few years.
However, Atomic Data has a couple of unique characteristics that would make it especially suitable for surveys.
It could help make surveys easier to <strong>fill in</strong>, easier to <strong>analyze</strong>, easier to <strong>create</strong>, and more <strong>privacy friendly</strong>.</p>
<ul>
<li><strong>Re-useable survey responses</strong> which enable <strong>pre-filled form fields</strong> which can save the respondent a lot of time. They also make it possible for users to use their own responses to <strong>gather insights</strong>, for example into their own health.</li>
<li><strong>Question standardization</strong> which helps researchers to re-use (validated) questions, which saves time for the researcher</li>
<li><strong>Privacy friendly, yet highly personalized invites</strong> as a researcher, send profile descriptions to servers, and let the servers tell if the question is relevant.</li>
</ul>
<h2 id="re-useable-survey-responses"><a class="header" href="#re-useable-survey-responses">Re-useable survey responses</a></h2>
<p>Since many surveys describe personal information, it makes sense, as a respondent, to have a way of storing the information you filled in in a place that you control.
Making this possible enables a few nice use cases.</p>
<ol>
<li><strong>Auto-fill forms</strong>. Previously entered response data could be usable while filling in new surveys. This could result in a UX similar to auto-filling forms, but far more powerful and rich than browsers currently support.</li>
<li><strong>Analyze your own personal data</strong>. Standardized survey responses could also be used to gather insights into your own personal information. For example, filling in a survey about how your shortness of breath linked to air pollution has been today could be used in a different app to make a graph that visualizes how your shortness of breath has progressed over the months for personal insight.</li>
</ol>
<p>Achieving something like this requires a high degree of standardization in both the surveys and the responses. The survey and its questions should provide information about:</p>
<ul>
<li>The <strong>question</strong>. This is required in all survey questions, of course.</li>
<li>The <strong>required datatype</strong> of the response, such as 'string', or 'datetime' or some 'enumeration'.</li>
<li>A (link to a) <strong>semantic definition</strong> of the property being described. This is a bit more obscure: all pieces of linked data use links, instead of keys, to describe the relation between some resource and its property. For example, a normal resource might have a 'birthdate', while in linked data, we'd use '<a href="https://schema.org/birthDate">https://schema.org/birthDate</a>'. This semantic definition makes things easier to share, because it prevents misinterpretation. Links remove ambiguity.</li>
<li><strong>A query description</strong>. This is even more obscure, but perhaps the most interesting. A query description means describing how a piece of information can be retrieved. Perhaps a question in a survey will want to know what your payment pointer is. If a piece of software wants to auto-fill this field, it needs to know where it can find your payment pointer.</li>
</ul>
<h2 id="question-standardization"><a class="header" href="#question-standardization">Question Standardization</a></h2>
<p>We can think of Questions as Resources that have a URL, and can be shared.
Sharing questions like that can make it easier to use the same questions across surveys, which in turn can make it easier to interpret data.
Some fields (e.g. medical) have highly standardized questions, which have been validated by studies.
These Question resources should contain information about:</p>
<ul>
<li>The <strong>question</strong> itself and its translations</li>
<li>The <strong>datatype</strong> of the response (e.g. <code>date</code>, <code>string</code>, <code>enum</code>), denoted by the <a href="https://atomicdata.dev/classes/Property">Property</a> of the response.</li>
<li>The <strong>path of the data</strong>, relative to the user. For example, a user's <code>birthdate</code> can be found by going to <code>/ profile birthdate</code></li>
</ul>
<p><a href="usecases/../schema/intro.html">Atomic Schema</a> and <a href="usecases/../core/paths.html">Atomic Paths</a> can be of value here.</p>
<h2 id="privacy-friendly-invites-with-client-side-filtering"><a class="header" href="#privacy-friendly-invites-with-client-side-filtering">Privacy friendly invites with client-side filtering</a></h2>
<p>Currently, a researcher needs to either build their own panel, or use a service that has a lot of respondents.
Sometimes, researchers will need a very specific target audience, like a specific age group, nationality, gender, or owners of specific types of devices.
Targeting these individuals is generally done by having a large database of personal information from many individuals.
But there is another way of doing this: <strong>client-side filtering</strong>
Instead of asking for the users data, and storing it centralized, we could send queries to decentralized personal data stores.
There queries basically contain the targeting information and an invitation.
The query is executed on the personal data store, and if the user characteristics align with the desired participants profile, the user receives an invite.
The user only sees invitations that are highly relevant, without sharing <em>any</em> information with the researcher.</p>
<p>The Atomic Data specification solves at least part of this problem.
<a href="usecases/../core/paths.html">Paths</a> are used to describe the queries that researchers make.
<a href="https://github.com/joepio/atomic/blob/master/server/README.md">Atomic Server</a> can be used as the personal online data store.</p>
<p>However, we still need to specify the process of sending a request to an individual (probably by introducing an <a href="https://github.com/ontola/atomic-data/issues/28">inbox</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-data-and-verifiable-credentials--ssi"><a class="header" href="#atomic-data-and-verifiable-credentials--ssi">Atomic Data and Verifiable Credentials / SSI</a></h1>
<h2 id="what-are-verifiable-credentials--self-sovereign-identity"><a class="header" href="#what-are-verifiable-credentials--self-sovereign-identity">What are Verifiable Credentials / Self-Sovereign Identity</a></h2>
<p>Verifiable Credentials are pieces of information that have cryptographic proof by some reliable third party.
For example, you could have a credential that proves your degree, signed by your education.
These credentials an enable privacy-friendly transactions where a credential owner can prove being part of some group, without needing to actually identify themselves.
For example, you could prove that you're over 18 by showing a credential issued by your government, without actually having to show your ID card with your birthdate.
Verifiable Credentials are still not that widely used, but various projects exists that have had moderate success in implementing it.</p>
<h2 id="what-makes-atomic-data-suitable-for-this"><a class="header" href="#what-makes-atomic-data-suitable-for-this">What makes Atomic Data suitable for this</a></h2>
<p>Firstly, <a href="usecases/../commits/intro.html">Atomic Commit</a> are already verifiable using signatures that contain all the needed information.
Secondly, <a href="usecases/../schema/intro.html">Atomic Schema</a> can be used for standardizing Credential Schemas.</p>
<h2 id="every-atomic-commit-is-a-verifiable-credential"><a class="header" href="#every-atomic-commit-is-a-verifiable-credential">Every Atomic Commit is a Verifiable Credential</a></h2>
<p>Every time an Agent updates a Resource, an <a href="usecases/../commits/intro.html">Atomic Commit</a> is made.
This Commit is cryptographically signed by an Agent, just like how Verfifiable Credentials are signed.
In essence, this means that <em>all atomic data created through commits is fully verifiable</em>.</p>
<p>How could this verification work?</p>
<ul>
<li><strong>Find the Commit</strong> that has created / edited the value that you want to verify. This can be made easier with a specialized Endpoint that takes a <code>resource</code>, <code>property</code> and <code>signer</code> and returns the associated Commit(s).</li>
<li><strong>Check the signer of the Commit</strong>. Is that an Agent that you trust?</li>
<li><strong>Verify the signature</strong> of the Commit using the public key of the Agent.</li>
</ul>
<p>Sometimes, credentials need to be revoked.
How could revocation work?</p>
<ul>
<li><strong>Find the Commit</strong> (see above)</li>
<li><strong>Get the signer</strong> (see above)</li>
<li><strong>Find the <code>/isRevoked</code> Endpoint of that signer</strong>, send a Request there to make sure the linked Commit is still valid and not revoked.</li>
</ul>
<p>Visit the <a href="https://github.com/ontola/atomic-data-docs/issues/22">issue on github</a> to join the discussion about this subject.</p>
<h2 id="use-atomic-schema-for-standardizing-credentials"><a class="header" href="#use-atomic-schema-for-standardizing-credentials">Use Atomic Schema for standardizing Credentials</a></h2>
<p>If you are a Verifier who wants to check someone's <em>birthdate</em>, you'll probably expect a certain datatype in return, such as a <a href="https://atomicdata.dev/datatypes/date">date</a> that is formatted in some specific way.
<a href="usecases/../schema/intro.html">Atomic Schema</a> makes it possible to express which <em>properties</em> are <a href="https://atomicdata.dev/properties/requires">required</a> in a certain <a href="https://atomicdata.dev/classes/Class">Class</a>, and it also makes it possible to describe which <a href="https://atomicdata.dev/classes/Datatype">datatype</a> is linked to a specific <a href="https://atomicdata.dev/classes/Property">Property</a>.
Combined, they allow for fine-grained descriptions of models / classes / schemas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic-data-for-food-label-standardization"><a class="header" href="#atomic-data-for-food-label-standardization">Atomic Data for food label standardization</a></h1>
<p>In most countries, food producers are required to provide nutritional information on the packages of products, which helps citizens to make informed decisions about what to eat.
But how about we upgrade these labels to machine-readable, atomic data?
We could describe products using Atomic Data, and put their identifiers (Subject URLs) as QR codes on packages.
Imagine these scenarios:</p>
<h2 id="scan-labels-to-get-detailed-reliable-interactive-information"><a class="header" href="#scan-labels-to-get-detailed-reliable-interactive-information">Scan labels to get detailed, reliable, interactive information</a></h2>
<p>You want to know more about some new cereal you've just bought.
You scan the QR code on the package.
A web app opens that shows detailed, yet highly visual information about its nutritional value.
The screen is no longer limited to what realistically fits on a package.
The elements are interactive, and provide explanations.
Everything is translated to the user's language.
If the food is (soon to be) expired, the app will clearly and visually alert you.
Click on the question mark next to <code>granulated sugars</code>, and you get an explanation of what this means to your health.
E-numbers are clickable, too, and help you instantly understand far more about what they represent.
When AR glasses become technologically feasible, you could even help people make better decisions while doing grocery shopping.</p>
<p>Using <em>links</em> instead of <em>names</em> helps to guide consumers to <em>trustworthy</em> pages that communicate clearly.
The alternative is that they use search engines, and maybe end up reading misinformation.</p>
<h2 id="provide-nutritional-advice-based-on-shopping-behavior"><a class="header" href="#provide-nutritional-advice-based-on-shopping-behavior">Provide nutritional advice based on shopping behavior</a></h2>
<p>You order a bunch of products on your favorite groceries delivery app.
When going to the payment screen, you are shown a nutritional overview of your order.
You see that with this diet, you might have a deficit of the Lysene amino acid.
The shopping cart suggest adding egg, dairy or soy to your diet.
This can be done, because the groceries app can easily check detailed information about the food in your shopping cart, and reason about your dietary intake.</p>
<h2 id="how-to-achieve-all-this"><a class="header" href="#how-to-achieve-all-this">How to achieve all this</a></h2>
<ol>
<li>The governing body (e.g. the European Commision) should set up an <a href="https://github.com/joepio/atomic-data-rust/">Atomic Server</a> and host it on some recognizable domain.</li>
<li>Create the <a href="https://atomicdata.dev/classes/Class">Class</a> for a food product, containing the same (or more) information that is shown on food packages.</li>
<li>Create the Class for Ingredient.</li>
<li>Create instances for various Ingredients. Start with the E-numbers, work your way up to all kinds of used ingredients. Add Translations.</li>
<li>Give instructions to Producers on how to describe their Products. Give them to option to host their own Server and control their own data, and give them the option to use some EU server.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-and-libraries-for-atomic-data"><a class="header" href="#software-and-libraries-for-atomic-data">Software and libraries for Atomic Data</a></h1>
<p>Although Atomic Data is a specification, it also has reference implementations:</p>
<p>Open source (MIT licenced) software for Atomic Data:</p>
<ul>
<li><strong>Server + Database</strong>: <a href="https://github.com/joepio/atomic">atomic-server</a></li>
<li><strong>GUI</strong>: <a href="https://github.com/joepio/atomic-data-browser">atomic-data-browser</a></li>
<li><strong>CLI</strong>: <a href="https://github.com/joepio/atomic">atomic-cli</a></li>
</ul>
<p>Libraries (MIT licenced) to build apps with:</p>
<ul>
<li>Typescript / javascript library: <a href="https://www.npmjs.com/package/@tomic/lib">@tomic/lib (npm)</a></li>
<li>React library: <a href="https://www.npmjs.com/package/@tomic/react">@tomic/react (npm)</a></li>
<li>Rust library: <a href="https://crates.io/crates/atomic-lib">atomic-lib (crates.io)</a></li>
</ul>
<h2 id="applications"><a class="header" href="#applications">Applications</a></h2>
<h3 id="atomic-server"><a class="header" href="#atomic-server"><code>atomic-server</code></a></h3>
<p>Server for hosting Atomic Data. Uses <code>atomic-lib</code>.</p>
<ul>
<li>Responds to requests for created Atomic Resources, makes atomic data available at their URL.</li>
<li>Embedded database</li>
<li>Authorization, authentication, versioning, collections, pagination</li>
<li>Browser-friendly HTML presentation, JSON serialization, RDF serialization.</li>
</ul>
<p>One liner: <code>$ docker run -p 80:80 -p 443:443 -v atomic-storage:/atomic-storage joepmeneer/atomic-server</code></p>
<p><a href="https://atomicdata.dev/">demo</a></p>
<p><a href="https://github.com/joepio/atomic">repository + issue tracker</a>.</p>
<h3 id="atomic-data-browser"><a class="header" href="#atomic-data-browser"><code>atomic-data-browser</code></a></h3>
<p>Data browser, powered by <code>@tomic/lib</code> and <code>@tomic/react</code>.</p>
<ul>
<li>View &amp; edit atomic data, using dynamic forms</li>
<li>Collections with pagination and sorting</li>
<li>Client-side full-text search</li>
</ul>
<p><a href="https://atomicdata.dev/">demo</a> (same as <code>atomic-server</code>)</p>
<p><a href="https://github.com/joepio/atomic-data-browser">repository + issue tracker</a>.</p>
<h3 id="atomic-cli"><a class="header" href="#atomic-cli"><code>atomic-cli</code></a></h3>
<p>A tool for generating / querying Atomic Data from the command line. Install with <code>cargo install atomic-cli</code>.</p>
<pre><code>atomic 0.20.0
Joep Meindertsma &lt;joep@ontola.io&gt;
Create, share, fetch and model linked atomic data!

USAGE:
    atomic-cli [SUBCOMMAND]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    destroy    Permanently removes a Resource. Uses Commits.
    edit       Edit a single Atom from a Resource using your text editor. Uses Commits.
    get        Traverses a Path and prints the resulting Resource or Value.
    help       Prints this message or the help of the given subcommand(s)
    list       List all bookmarks
    new        Create a Resource
    remove     Remove a single Atom from a Resource. Uses Commits.
    set        Update an Atom's value. Uses Commits.
    tpf        Finds Atoms using Triple Pattern Fragments.

Visit https://github.com/joepio/atomic for more info
</code></pre>
<p><a href="https://github.com/joepio/atomic">repository + issue tracker</a>.</p>
<h3 id="raycast-extension-full-text-search-from-your-desktop"><a class="header" href="#raycast-extension-full-text-search-from-your-desktop">Raycast extension: Full-text search from your desktop</a></h3>
<p><a href="https://www.raycast.com/joepio/atomic">Install here</a>.</p>
<h2 id="libraries"><a class="header" href="#libraries">Libraries</a></h2>
<h3 id="tomiclib-and-tomicreact"><a class="header" href="#tomiclib-and-tomicreact"><code>@tomic/lib</code> and <code>@tomic/react</code></a></h3>
<p>Javascript / typescript libraries, especially useful for creating front-end apps.</p>
<p>Fork the <a href="https://codesandbox.io/s/atomic-data-react-template-4y9qu?file=/src/MyResource.tsx">atomic-data-react-template</a> on codesandbox to get started directly!</p>
<h3 id="atomic-lib-rust"><a class="header" href="#atomic-lib-rust"><code>atomic-lib</code> (Rust)</a></h3>
<p>Library that powers <code>atomic-server</code> and <code>atomic-cli</code>. Features:</p>
<ul>
<li>An in-memory store</li>
<li>Parsing (JSON-AD) / Serialization (JSON-AD, JSON-LD, TTL, N-Triples)</li>
<li>Commit validation and processing</li>
<li>TPF queries</li>
<li>Constructing Collections</li>
<li>Path traversal</li>
<li>Basic validation</li>
</ul>
<p><a href="https://github.com/joepio/atomic">repository + issue tracker</a>.</p>
<h2 id="want-to-add-to-this-list-some-ideas-for-tooling"><a class="header" href="#want-to-add-to-this-list-some-ideas-for-tooling">Want to add to this list? Some ideas for tooling</a></h2>
<p>This document contains a set of ideas that would help achieve that success.
Open a PR and <a href="https://github.com/ontola/atomic-data-docs/edit/master/src/tooling.md">edit this file</a> to add your project!</p>
<h3 id="atomic-companion"><a class="header" href="#atomic-companion">Atomic Companion</a></h3>
<p>A mobile app for granting permissions to your data and signing things. See <a href="https://github.com/ontola/atomic-data-docs/issues/45">github issue</a>.</p>
<ul>
<li>Show a notification when you try to log in somewhere with your agent</li>
<li>Notifications for mentions and other social items</li>
<li>Check uptime of your server</li>
</ul>
<h3 id="atomizer-data-importer-and-conversion-kit"><a class="header" href="#atomizer-data-importer-and-conversion-kit">Atomizer (data importer and conversion kit)</a></h3>
<ul>
<li>Import data from some data source (CSV / SQL / JSON / RDF), fill in the gaps (mapping / IRI creation / datatypes) an create new Atoms</li>
<li>Perhaps a CLI, library, GUI or a combination of all of these</li>
</ul>
<h3 id="atomic-preview"><a class="header" href="#atomic-preview">Atomic Preview</a></h3>
<ul>
<li>A simple (JS) widget that can be embedded anywhere, which converts an Atomic Graph into an HTML view.</li>
<li>Would be useful for documentation, and as a default view for Atomic Data.</li>
<li>Use <code>@tomic/react</code> and <code>@tomic/lib</code> to get started</li>
</ul>
<h3 id="atomic-dart--flutter"><a class="header" href="#atomic-dart--flutter">Atomic-Dart + Flutter</a></h3>
<p>Library + front-end app for browsing / manipulating Atomic Data on mobile devices.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h1>
<h2 id="authors"><a class="header" href="#authors">Authors:</a></h2>
<ul>
<li><strong>Joep Meindertsma</strong> (<a href="https://github.com/joepio/">joepio</a> from <a href="https://ontola.io/">Ontola.io</a>)</li>
</ul>
<h2 id="special-thanks-to"><a class="header" href="#special-thanks-to">Special thanks to:</a></h2>
<ul>
<li><strong>Thom van Kalkeren</strong> (my colleague, friend and programming mentor who came up with many great ideas on how to work with RDF, such as <a href="https://github.com/ontola/hextuples">HexTuples</a> and <a href="https://github.com/ontola/linked-delta">linked-delta</a>)</li>
<li><strong>Tim Berners-Lee</strong> (for everything he did for linked data and the web)</li>
<li><strong>Ruben Verborgh</strong> (for doing great work with RDF, such as the TPF spec)</li>
<li><strong>Pat McBennett</strong> (for lots of valuable feedback on initial Atomic Data docs)</li>
<li><strong>Manu Sporny</strong> (for his work on JSON-LD, which was an important inspiration for JSON-AD)</li>
<li><strong>Jonas Smedegaard</strong> (for the various interesting talks we had and the feedback he provided)</li>
<li><strong>Arthur Dingemans</strong> (for sharing his thoughts, providing feedback and his valuable suggestions)</li>
<li><strong>Anja Koopman</strong> (for all her support, even when this project ate away days and nights of our time together)</li>
<li><strong>Alex Mikhalev</strong> (for sharing many inspiring project and ideas)</li>
<li><strong>Daniel Lutrha</strong> (for inspiring me to be more ambitious and for providing lots of technical ideas)</li>
<li>All the other people who contributed to linked data related standards</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subscribe-to-the-atomic-data-newsletter"><a class="header" href="#subscribe-to-the-atomic-data-newsletter">Subscribe to the Atomic Data newsletter</a></h1>
<p>We'll send you an update (max once per month) when there's something relevant to share, such as</p>
<ul>
<li>Major changes to the specification</li>
<li>Major new releases (with new features)</li>
<li>Use-cases, implementations</li>
<li>Tutorials, blog posts</li>
<li>Organizational / funding news</li>
</ul>
<p><a href="http://eepurl.com/hHcRA1">Click here to sign up to the Atomic Data Newsletter</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-involved"><a class="header" href="#get-involved">Get involved</a></h1>
<p>Atomic Data is an open specification, and that means that you're very welcome to share your thoughts and help make this standard as good as possible.</p>
<p>Things you can do:</p>
<ul>
<li>Join the <a href="https://discord.gg/a72Rv2P">Discord server</a> for voice / text chat</li>
<li>Start playing with / contributing to <a href="tooling.html">the implementations</a></li>
<li>Drop an <a href="https://github.com/ontola/atomic-data-docs/issues">issue on Github</a> to share your suggestions or criticism of this book / spec</li>
<li>Subscribe to the <a href="newsletter.html">newsletter</a></li>
<li>Join our <a href="https://www.w3.org/community/atomic-data/">W3C Community Group</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-121994595-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
