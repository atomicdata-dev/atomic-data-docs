<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Atomic Data</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for the Atomic Data standard.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="atomic-data-overview.html"><strong aria-hidden="true">1.</strong> Atomic Data Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="motivation.html"><strong aria-hidden="true">1.1.</strong> Motivation</a></li><li class="chapter-item expanded "><a href="when-to-use.html"><strong aria-hidden="true">1.2.</strong> When (not) to use it</a></li></ol></li><li class="chapter-item expanded "><a href="core/intro.html"><strong aria-hidden="true">2.</strong> Atomic Data Core</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core/concepts.html"><strong aria-hidden="true">2.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="core/serialization.html"><strong aria-hidden="true">2.2.</strong> Serialization</a></li><li class="chapter-item expanded "><a href="core/json-ad.html"><strong aria-hidden="true">2.3.</strong> JSON-AD</a></li><li class="chapter-item expanded "><a href="core/querying.html"><strong aria-hidden="true">2.4.</strong> Querying</a></li><li class="chapter-item expanded "><a href="core/paths.html"><strong aria-hidden="true">2.5.</strong> Paths</a></li></ol></li><li class="chapter-item expanded "><a href="schema/intro.html"><strong aria-hidden="true">3.</strong> Atomic Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="schema/classes.html"><strong aria-hidden="true">3.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="schema/datatypes.html"><strong aria-hidden="true">3.2.</strong> Datatypes</a></li><li class="chapter-item expanded "><a href="schema/translations.html"><strong aria-hidden="true">3.3.</strong> Translations</a></li><li class="chapter-item expanded "><a href="schema/collections.html"><strong aria-hidden="true">3.4.</strong> Collections</a></li><li class="chapter-item expanded "><a href="schema/faq.html"><strong aria-hidden="true">3.5.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="core/validations.html"><strong aria-hidden="true">3.6.</strong> Types of Graph Validations</a></li></ol></li><li class="chapter-item expanded "><a href="commits/intro.html"><strong aria-hidden="true">4.</strong> Atomic Commits</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commits/concepts.html"><strong aria-hidden="true">4.1.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="commits/compare.html"><strong aria-hidden="true">4.2.</strong> Compared to</a></li></ol></li><li class="chapter-item expanded "><a href="interoperability/intro.html"><strong aria-hidden="true">5.</strong> Interoperability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="interoperability/rdf.html"><strong aria-hidden="true">5.1.</strong> Relation to RDF</a></li><li class="chapter-item expanded "><a href="interoperability/solid.html"><strong aria-hidden="true">5.2.</strong> Relation to Solid</a></li><li class="chapter-item expanded "><a href="interoperability/json.html"><strong aria-hidden="true">5.3.</strong> Relation to JSON</a></li><li class="chapter-item expanded "><a href="interoperability/ipfs.html"><strong aria-hidden="true">5.4.</strong> Relation to IPFS</a></li><li class="chapter-item expanded "><a href="interoperability/sql.html"><strong aria-hidden="true">5.5.</strong> Relation to SQL</a></li><li class="chapter-item expanded "><a href="interoperability/upgrade.html"><strong aria-hidden="true">5.6.</strong> Your existing project</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">6.</strong> Tooling</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="get-involved.html">Get involved</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Atomic Data</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/ontola/atomic-data" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#atomic-data-docs---overview" id="atomic-data-docs---overview">Atomic Data Docs - Overview</a></h1>
<p>Atomic Data is a specification for sharing, modifying and modeling data.</p>
<p>It uses links to connect pieces of data, and therefore makes it easier to connect datasets to each other - even when these datasets exist on separate machines.</p>
<p>Atomic Data is especially suitable for knowledge graphs, distributed datasets, semantic data, p2p applications, decentralized apps and linked open data.
It is designed to be highly extensible, easy to use, and to make the process of domain specific standardization as simple as possible.</p>
<p>Atomic Data is <a href="https://ontola.io/what-is-linked-data/">Linked Data</a>, as it is a more strict subset of RDF.
It is typed (you know if something is a <code>string</code>, <code>number</code>, <code>date</code>, <code>URL</code>, etc.) and extensible through <a href="schema/intro.html">Atomic Schema</a>, which means that you can define your own Classes, Properties and Datatypes.
Atomic Data has a standard for synchronizing data by communicating state changes, called <a href="commits/intro.html">Atomic Commits</a>.
You can use parts of Atomic Data separately, but the standard is designed as a full, integrated data management package that makes it easier to create, share and use structured data on the web.</p>
<ul>
<li><a href="core/intro.html">Atomic Data Core</a>: the core model for typed, Linked Data</li>
<li><a href="schema/intro.html">Atomic Schema</a>: defining properties, datatypes and classes</li>
<li><a href="commits/intro.html">Atomic Commits</a>: sharing state changes, verifying changes and collaboration</li>
</ul>
<h2><a class="header" href="#get-started" id="get-started">Get Started</a></h2>
<p>If you want to read more about how Atomic Data works - read on.
If you'd rather play and discover for yourself, play with the existing <a href="tooling.html">tooling</a>:</p>
<ul>
<li>Server: <a href="https://github.com/joepio/atomic">atomic-server</a> (powers <a href="https://atomicdata.dev">atomicdata.dev</a>, run with <code>docker run -p 80:80 -p 443:443 -v atomic-storage:/atomic-storage joepmeneer/atomic-server</code>)</li>
<li>Browser app <a href="https://github.com/joepio/atomic-data-browser">atomic-data-browser</a> (<a href="https://joepio.github.io/atomic-data-browser/">demo</a>)</li>
<li>CLI (atomic-cli): <a href="https://github.com/joepio/atomic">atomic-cli</a> (<code>cargo install atomic-cli</code>)</li>
<li>Rust library: <a href="https://github.com/joepio/atomic">atomic-lib</a></li>
</ul>
<p>Make sure to <a href="https://discord.gg/a72Rv2P">join our Discord</a> if you'd like to discuss Atomic Data with others.</p>
<h2><a class="header" href="#reading-these-docs" id="reading-these-docs">Reading these docs</a></h2>
<p>This is written mostly as a book, so reading it in the order of the Table of Contents will probably give you the best experience.
That being said, feel free to jump around - links are often used to refer to earlier discussed concepts.
If you encounter any issues while reading, please leave an <a href="https://github.com/ontola/atomic-data/issues">issue on Github</a>.
Use the arrows on the side / bottom to go to the next page.</p>
<h1><a class="header" href="#motivation-why-atomic-data" id="motivation-why-atomic-data">Motivation: Why Atomic Data?</a></h1>
<p>Linked data (RDF / the semantic web) enables us to use the web as a large, decentralized graph database.
Using links everywhere in data has amazing merits: links remove ambiguity, they enable exploration, they enable connected datasets.
Linked Data could help to democratize the web by decentralizing information storage, and giving people more control.
The Solid Project by Tim Berners-Lee is a great example of why linked data can help to create a more decentralized web.</p>
<p>At <a href="https://ontola.io/">Ontola</a>, we've been working with linked data quite intensely for the last couple of years.
We went all-in on RDF, and challenged ourselves to create software that communicates exclusively using it.
That has been an inspiring, but also sometimes a frustrating journey.
While building various production grade apps (e.g. our e-democracy platform <a href="https://argu.co/">Argu.co</a>, which is used by various governments), we had to <a href="https://ontola.io/blog/full-stack-linked-data/">solve many problems</a>.
How to properly model data in RDF? How to deal with sequences? How to communicate state changes? Converting RDF to HTML? Typing? CORS?
We tackled some of these problems by having a tight grip on the data that we create (e.g. we know the type of data, because we control the resources), and another part is creating new protocols, formats, tools, and libraries.
But it took a long time, and it was hard.
It's been almost 15 years since the <a href="https://www.w3.org/DesignIssues/LinkedData.html">introduction of linked data</a>, and its adoption has been slow.
We know that some of its merits are undeniable, and we truly want the semantic web to succeed.
We believe the lack of growth partially has to do with a lack of tooling, but also with <a href="interoperability/rdf.html#why-these-changes">some problems that lie in the RDF data model</a>.</p>
<p>Atomic Data aims to take the best parts from RDF, and learn from the past to make a more developer-friendly, performant and reliable data model to achieve a truly linked web.</p>
<h1><a class="header" href="#when-not-to-use-atomic-data" id="when-not-to-use-atomic-data">When (not) to use Atomic Data</a></h1>
<h2><a class="header" href="#when-should-you-use-atomic-data" id="when-should-you-use-atomic-data">When should you use Atomic Data</a></h2>
<ul>
<li><strong>Flexible schemas</strong>. When dealing with structured wikis or semantic data, various instances of things will have different attributes. Atomic Data allows <em>any</em> kind of property on <em>any</em> resource.</li>
<li><strong>High-value open data</strong>. Atomic Data is a bit harder to create than plain JSON, for example, but it is easier to re-use and understand. It's use of URLs for properties makes data self-documenting.</li>
<li><strong>High interoperability requirements</strong>. When multiple groups of people have to use the same schema, Atomic Data provides easy ways to constrain and validate the data and ensure type safety.</li>
<li><strong>Multi-class / multi-model</strong>. Contrary to (SQL) tables, Atomic Data allows a single thing to have multiple classes, each with their own properties.</li>
<li><strong>Connected / decentralized data</strong>. With Atomic Data, you use URLs to point to things on other computers. This makes it possible to connect datasets very explicitly, without creating copies. Very useful for decentralized social networks, for example.</li>
<li><strong>Audibility &amp; Versioning</strong>. Using Atomic Commits, we can store all changes to data as transactions that can be replayed. This creates a complete audit log and history.</li>
<li><strong>JSON or RDF as Output</strong>. Atomic Data serializes to idiomatic, clean JSON as well as various RDF formats (Turtle / JSON-LD / n-triples / RDF/XML).</li>
</ul>
<h2><a class="header" href="#when-not-to-use-atomic-data-1" id="when-not-to-use-atomic-data-1">When not to use Atomic Data</a></h2>
<ul>
<li><strong>Internal use only</strong>. If you're not sharing structured data, Atomic Data will probably only make things harder for you.</li>
<li><strong>Big Data</strong>. If you're dealing with TeraBytes of data, you probably don't want to use Atomic Data. The added cost of schema validation and the lack of distributed / large scale persistence tooling makes it not the right choice.</li>
<li><strong>Video / Audio / 3D</strong>. These should have unique, optimized binary representations and have very strict, static schemas. The advantages of linke data do little to improve this, unless it's just for metadata.</li>
</ul>
<h1><a class="header" href="#atomic-data-core" id="atomic-data-core">Atomic Data Core</a></h1>
<p>The Atomic Data Core describes the fundamental data model of Atomic Data.</p>
<h2><a class="header" href="#design-goals" id="design-goals">Design goals</a></h2>
<ul>
<li><strong>Browsable</strong>: Data should explicitly link to other pieces of data, and these links should be followable.</li>
<li><strong>Semantic</strong>: Every data Atom and relation has a clear semantic meaning.</li>
<li><strong>Interoperable</strong>: Plays nice with other data formats (e.g. JSON, XML, and all RDF formats).</li>
<li><strong>Open</strong>: Free to use, open source, no strings attached.</li>
<li><strong>Clear Ownership</strong>: The data shows who is in control of the data, so new versions of the data can easily be retrieved.</li>
<li><strong>Mergeable</strong>: Any two sets of Atoms can be merged into a single graph without any merge conflicts / name collisions.</li>
<li><strong>Extensible</strong>: Anyone can define their own data types and create Atoms with it.</li>
<li><strong>ORM-friendly</strong>: Navigate a <em>decentralized</em> graph by using dot.syntax, similar to how you navigate a JSON object in javascript.</li>
<li><strong>Typed</strong>: All valid Atomic data has an unambiguous, static datatype. Models expressed in Atomic Data can be mapped to programming language models, such as <code>structs</code> or <code>interfaces</code> in Typescript / Rust / Go.</li>
</ul>
<h1><a class="header" href="#atomic-data-core-concepts" id="atomic-data-core-concepts">Atomic Data Core: Concepts</a></h1>
<h2><a class="header" href="#atomic-data" id="atomic-data">Atomic Data</a></h2>
<p>Atomic Data is a data model for sharing information on the web.
It can be used to express any type of information, including personal data, vocabularies, metadata, documents, files and more.
It's designed to be easily serializable to both JSON and linked data formats.
It is <em>typed</em> data model, which means that every value should be validated and predictable.</p>
<p>It is a directed, labeled graph, similar to RDF, so contrary to some other (labeled) graph data models (e.g. NEO4j), a relationship between two items (Resources) does not have attributes.</p>
<h2><a class="header" href="#resource" id="resource">Resource</a></h2>
<p>A Resource is a bunch of information about a single things.
Formally, it is a set of Atoms (a Graph) that share the same Subject URL.
You can think of a Resource as a single row in a spreadsheet or database.
In practice, Resources can be anything - a Person, a Blogpost, a Todo item.
A Resource consists of at least one Atom, so it always has some Property and some Value.
The most important Property of a Resource is the <a href="https://atomicdata.dev/properties/isA"><code>is-a</code></a> Property, which refers to which <em>Class</em> it belongs (e.g. Person or Blogpost).
A Class can specify <a href="https://atomicdata.dev/properties/requires"><code>required</code></a> and <a href="https://atomicdata.dev/properties/recommends"><code>recommended</code></a> properties.
More on that in the Atomic Schema chapter!</p>
<h2><a class="header" href="#atom-or-atomic-triple" id="atom-or-atomic-triple">Atom (or Atomic Triple)</a></h2>
<p>Every Resource is composed of Atoms.
The Atom is the smallest possible piece of <em>meaningful</em> data / information.
You can think of an Atom as a single cell in a spreadsheet or database.
An Atom consists of three fields:</p>
<ul>
<li><strong><a href="core/concepts.html#subject-field">Subject</a></strong>: the Thing that the atom is providing information about.</li>
<li><strong><a href="core/concepts.html#property-field">Property</a></strong>: the property of the Thing that the atom is about (will always be a URL to a <a href="core/../schema/classes.html#property">Property</a>).</li>
<li><strong><a href="core/concepts.html#value-field">Value</a></strong>: the new piece of information about the Atom.</li>
</ul>
<p>If you're familiar with RDF, you'll notice similarities.
An Atom is comparable with an RDF Triple / Statement (<a href="core/../interoperability/rdf.html">although there are important differences</a>).</p>
<p>Let's turn this sentence into Atoms:</p>
<p><code>Arnold Peters, who's born on the 20th of Januari 1991, has a best friend named Britta Smalls.</code></p>
<table><thead><tr><th>Subject</th><th>Property</th><th>Value</th></tr></thead><tbody>
<tr><td>Arnold</td><td>last name</td><td>Peters</td></tr>
<tr><td>Arnold</td><td>birthdate</td><td>1991-01-20</td></tr>
<tr><td>Arnold</td><td>best friend</td><td>Britta</td></tr>
<tr><td>Britta</td><td>last name</td><td>Smalls</td></tr>
</tbody></table>
<p>The table above shows easily readable strings, but in reality, Atomic Data will almost exclusively consist of links (URLs).
The standard serialization format for Atomic Data is JSON-AD, which looks like this:</p>
<pre><code class="language-json">[{
  &quot;@id&quot;: &quot;https://example.com/arnold&quot;,
  &quot;https://example.com/properties/lastname&quot;: &quot;Peters&quot;,
  &quot;https://example.com/properties/birthDate&quot;: &quot;1991-01-20&quot;,
  &quot;https://example.com/properties/bestFriend&quot;: &quot;https://example.com/britta&quot;,
},{
  &quot;@id&quot;: &quot;https://example.com/britta&quot;,
  &quot;https://example.com/properties/lastname&quot;: &quot;Smalls&quot;,
}]
</code></pre>
<p>The <code>@id</code> field denotes the Subject of each Resource, which is also the URL that should point to where the resource can be downloaded.</p>
<p>In the Atomic Data above, we have:</p>
<ul>
<li>two different <strong>Resources</strong>, describing two different <strong>Subjects</strong>: <code>https://example.com/arnold</code> and <code>https://example.com/britta</code>.</li>
<li>three different <strong>Properties</strong> (<code>https://example.com/properties/bornAt</code>, <code>https://example.com/properties/firstName</code>, and <code>https://example.com/properties/bestFriend</code>)</li>
<li>four different <strong>Values</strong> (<code>1991-01-20</code>, <code>Arnold</code>, <code>https://example.com/britta</code> and <code>Britta</code>)</li>
</ul>
<p>All Subjects and Properties are Atomic URLs: they are links that point to more Atomic Data.
One of the Values is a URL, too, but we also have values like <code>Arnold</code> and <code>1991-01-20</code>.
These Values have different <em>Datatypes</em>
In most other data formats, the datatypes are limited and are visually distinct.
JSON, for example, has <code>array</code>, <code>object</code>, <code>string</code>, <code>number</code> and <code>boolean</code>.
In Atomic Data, however, datatypes are defined somewhere else, and are extendible.
To find the Datatype of an Atom, you fetch the Property, and that one has a Datatype.
For example, the <code>https://example.com/properties/bornAt</code> Property requires an ISO Date string, and the <code>https://example.com/properties/firstName</code> Property requires a regular string.
This might seem a little tedious and weird at first, but is has some nice advantages!
Their Datatypes are defined in the Properties.</p>
<h2><a class="header" href="#subject-field" id="subject-field">Subject field</a></h2>
<p>The Subject field is the first part of an Atom.
It is the identifier that the rest of the Atom is providing information about.
The Subject field is a URL that points to the Resource.
The creator of the Subject MUST make sure that it resolves.
In other words: following / downloading the Subject link will provide you with all the Atoms about the Subject (see <a href="core/querying.html">Querying Atomic Data</a>.
This also means that the creator of a Resource must make sure that it is available at its URL - probably by hosting the data, or by using some service that hosts it.</p>
<h2><a class="header" href="#property-field" id="property-field">Property field</a></h2>
<p>The Property field is the second part of an Atom.
It is a URL that points to an Atomic <a href="core/../schema/classes.html#Property">Property</a>.
For example <code>https://example.com/createdAt</code> or <code>https://example.com/firstName</code>.</p>
<!-- Making this a requirement is what makes Atomic Data typed and semantic -->
<p>The Property field MUST be a URL, and that URL MUST resolve to an Atomic Property, which contains information about the Datatype.</p>
<h2><a class="header" href="#value-field" id="value-field">Value field</a></h2>
<p>The Value field is the third part of an Atom.
In RDF, this is called an <code>object</code>.
Contrary to the Subject and Property values, the Value can be of any datatype.
This includes URLs, strings, integers, dates and more.</p>
<h2><a class="header" href="#graph" id="graph">Graph</a></h2>
<p>A Graph is a set of Atoms.
A Graph can describe various subjects, and may or may not be related.
Graphs can have several characteristics (Schema Complete, Valid, Closed)</p>
<h2><a class="header" href="#atomic-web" id="atomic-web">Atomic Web</a></h2>
<p>The Atomic Web refers to all Atomic Graphs on the web.</p>
<p>In the next chapter, we'll explore how Atomic Data is serialized.</p>
<h2><a class="header" href="#nested-resource" id="nested-resource">Nested Resource</a></h2>
<p>A Nested Resource only exists inside of another resource.
It does not have its own subject.</p>
<p>In the following example, the address is a nested resource:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/arnold&quot;,
  &quot;https://example.com/properties/address&quot;: {
    &quot;https://example.com/properties/firstLine&quot;: &quot;Longstreet 22&quot;,
    &quot;https://example.com/properties/city&quot;: &quot;Watertown&quot;,
    &quot;https://example.com/properties/country&quot;: &quot;the Netherlands&quot;,
  }
}
</code></pre>
<p>It does not have its own subject (<code>@id</code>), but it <em>does</em> have its own unique <a href="core/./paths.html">path</a>, which can be used as its identifier.
In this case, the path of the address is <code>https://example.com/arnold address</code> or <code>https://example.com/arnold https://example.com/properties/address</code> (both are valid).</p>
<h1><a class="header" href="#serialization-of-atomic-data" id="serialization-of-atomic-data">Serialization of Atomic Data</a></h1>
<p>Atomic Data is not necessarily bound to a single serialization format.
It's fundamentally a data model, and that's an important distinction to make.</p>
<h2><a class="header" href="#json-ad" id="json-ad">JSON-AD</a></h2>
<p>However, it's recommended to use <a href="core/json-ad.html"><code>JSON-AD</code></a> (more about that on the next page), which is specifically designed to be a simple, complete and performant format for Atomic Data.</p>
<h2><a class="header" href="#json-simple" id="json-simple">JSON (simple)</a></h2>
<p>Atomic Data is designed to be serializable to clean, simple <a href="core/../interoperability/json.html">JSON</a>, for usage in (client) apps that don't need to know the full URLs of properties.</p>
<h2><a class="header" href="#rdf-serialization-formats" id="rdf-serialization-formats">RDF serialization formats</a></h2>
<p>Since Atomic Data is a strict subset of RDF, RDF serialization formats can be used to communicate and store Atomic Data, such as N-Triples, Turtle, HexTuples, JSON-LD and <a href="https://ontola.io/blog/rdf-serialization-formats/">other RDF serialization formats</a>.
However, not all valid RDF is valid Atomic Data.
Atomic Data is more strict.
Read more about serializing Atomic Data to RDF in the <a href="core/../interoperability/rdf.html">RDF interoperability section</a>.</p>
<h2><a class="header" href="#experimental-serialization-formats" id="experimental-serialization-formats">Experimental serialization formats</a></h2>
<p>Some experimental ideas for Atomic Data serialization are <a href="https://github.com/ontola/atomic-data/blob/master/src/experimental-serialization.md">written here</a>.</p>
<h1><a class="header" href="#json-ad-the-atomic-data-serialization-format" id="json-ad-the-atomic-data-serialization-format">JSON-AD: The Atomic Data serialization format</a></h1>
<p><code>JSON-AD</code> is the <em>default</em> serialization format for Atomic Data.
It is what the current <a href="https://github.com/joepio/atomic">Rust</a> and <a href="https://github.com/joepio/atomic-data-browser">Typescript / React</a> implementation use to communicate.
It is a <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">JSON</a> with a lot of links in it and the following rules:</p>
<ul>
<li>Every Object is a Resource.</li>
<li>Every Key is a Property URL.</li>
<li>The <code>@id</code> field is special: it defines the Subject of the Resource.</li>
<li>JSON arrays are mapped to <a href="https://atomicdata.dev/datatypes/resourceArray">Resource Arrays</a></li>
<li>Numbers can be <a href="https://atomicdata.dev/datatypes/integer">Integers</a>, <a href="https://atomicdata.dev/datatypes/timestamp">Timestamps</a> or <a href="https://atomicdata.dev/datatypes/float">Floats</a>.</li>
<li>JSON booleans map to Atomic Booleans.</li>
<li>Strings can be many datatypes, including <a href="https://atomicdata.dev/datatypes/string">String</a>, <a href="https://atomicdata.dev/datatypes/markdown">Markdown</a>, <a href="https://atomicdata.dev/datatypes/date">Date</a> or other.</li>
<li>Nested Objects are Nested Resources. A Nested Resource can either be an Anonymous Resource (without an <code>@id</code> field) or a regular Resource.</li>
<li>When you want to describe multiple Resources in one JSON-AD document, use an array as the root item.</li>
</ul>
<p>Let's look at an example JSON-AD Resource:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://atomicdata.dev/properties/description&quot;,
  &quot;https://atomicdata.dev/properties/datatype&quot;: &quot;https://atomicdata.dev/datatypes/markdown&quot;,
  &quot;https://atomicdata.dev/properties/description&quot;: &quot;A textual description of something. When making a description, make sure that the first few words tell the most important part. Give examples. Since the text supports markdown, you're free to use links and more.&quot;,
  &quot;https://atomicdata.dev/properties/isA&quot;: [
    &quot;https://atomicdata.dev/classes/Property&quot;
  ],
  &quot;https://atomicdata.dev/properties/shortname&quot;: &quot;description&quot;
}
</code></pre>
<h2><a class="header" href="#canonicalized-json-ad" id="canonicalized-json-ad">Canonicalized JSON-AD</a></h2>
<p>When you need deterministic serialization of Atomic Data (e.g. when calculating a cryptographic hash or signature, used in Atomic Commits), you can use the following procedure:</p>
<ol>
<li>Serialize your Resource to JSON-AD</li>
<li>Do not include empty objects, empty arrays or null values.</li>
<li>All keys are sorted alphabetically (lexicographically) - both in the root object, as in any nested objects.</li>
<li>The JSON-AD is minified: no newlines, no spaces.</li>
</ol>
<p>The last two steps of this process is more formally defined by the JSON Canonicalization Scheme (JCS, <a href="https://tools.ietf.org/html/rfc8785">rfc8785</a>).</p>
<h1><a class="header" href="#querying-atomic-data" id="querying-atomic-data">Querying Atomic Data</a></h1>
<p>There are multiple ways of getting Atomic Data into some system:</p>
<ul>
<li><a href="core/../schema/collections.html"><strong>Atomic Collections</strong></a> is a simple way to traverse Atomic Graphs and target specific values</li>
<li><a href="core/paths.html"><strong>Atomic Paths</strong></a> is a simple way to traverse Atomic Graphs and target specific values</li>
<li><a href="core/querying.html#subject-fetching-http"><strong>Subject Fetching</strong></a> requests a single subject right from its source</li>
<li><a href="core/querying.html#triple-pattern-fragments"><strong>Triple Pattern Fragments</strong></a> allows querying for specific (combinations of) Subject, Property and Value.</li>
<li><a href="core/querying.html#SPARQL"><strong>SRARQL</strong></a> is a powerful Query language for traversing linked data graphs</li>
</ul>
<h2><a class="header" href="#atomic-paths" id="atomic-paths">Atomic Paths</a></h2>
<p>An Atomic Path is a string that consist of one or more URLs, which when traversed point to an item.
For more information, see <a href="core/paths.html">Atomic Paths</a>.</p>
<h2><a class="header" href="#subject-fetching-http" id="subject-fetching-http">Subject fetching (HTTP)</a></h2>
<p>The simplest way of getting Atomic Data when the Subject is an HTTP URL, is by sending a GET request to the subject URL.
Set the <code>Content-Type</code> header to an Atomic Data compatible mime type, such as <code>application/ad3-ndjson</code>.</p>
<pre><code class="language-HTTP">GET https://atomicdata.dev/test HTTP/1.1
Content-Type: application/ad+json
</code></pre>
<p>The server SHOULD respond with all the Atoms of which the requested URL is the subject:</p>
<pre><code class="language-HTTP">HTTP/1.1 200 OK
Content-Type: application/ad+json
Connection: Closed

{
  &quot;@id&quot;: &quot;https://atomicdata.dev/test&quot;,
  &quot;https://atomicdata.dev/properties/shortname&quot;: &quot;1611489928&quot;
}
</code></pre>
<p>The server MAY also include other resources, if they are deemed relevant.</p>
<h2><a class="header" href="#triple-pattern-fragments" id="triple-pattern-fragments">Triple Pattern Fragments</a></h2>
<p><a href="https://linkeddatafragments.org/specification/triple-pattern-fragments/">Triple Pattern Fragments</a> (TPF) is an interface for querying RDF.
It works great for Atomic Data as well.</p>
<p>An HTTP implementation of a TPF endpoint might accept a GET request to a URL such as this:</p>
<p><code>http://example.org/tpf?subject={subject}&amp;property={property}&amp;value={value}</code></p>
<p>Make sure to URL encode the <code>subject</code>, <code>property</code>, <code>value</code> strings.</p>
<p>For example, let's search for all Atoms where the value is <code>test</code>.</p>
<pre><code class="language-HTTP">GET https://atomicdata.dev/tpf?value=0 HTTP/1.1
Content-Type: text/turtle
</code></pre>
<p>This is the HTTP response:</p>
<pre><code class="language-HTTP">HTTP/1.1 200 OK
Content-Type: text/turtle
Connection: Closed

&lt;https://atomicdata.dev/agents&gt; &lt;https://atomicdata.dev/properties/collection/currentPage&gt; &quot;0&quot;^^&lt;https://atomicdata.dev/datatypes/integer&gt; .
</code></pre>
<h2><a class="header" href="#sparql" id="sparql">SPARQL</a></h2>
<p><a href="https://www.w3.org/TR/rdf-sparql-query/">SPARQL</a> is a powerful RDF query language.
Since all Atomic Data is also valid RDF, it should be possible to query Atomic Data using SPARQL.</p>
<ul>
<li>Convert / serialize Atomic Data to RDF (for example by using the <code>/tpf</code> endpoint and an <code>accept</code> header: <code>curl -i -H &quot;Accept: text/turtle&quot; &quot;https://atomicdata.dev/tpf&quot;</code>)</li>
<li>Load it into a SPARQL engine (e.g. )</li>
</ul>
<h1><a class="header" href="#atomic-paths-1" id="atomic-paths-1">Atomic Paths</a></h1>
<p>An Atomic Path is a string that consists of at least one URL, followed by one or more URLs or Shortnames.
Every single value in an Atomic Resource can be targeted through such a Path.
They can be used as identifiers for specific Values.</p>
<p>The simplest path, is the URL of a resource, which represents the entire Resource with all its properties.
If you want to target a specific atom, you can use an Atomic Path with a second URL.
This second URL can be replaced by a Shortname, if the Resource is an instance of a class which has properties with that Shortname (sounds more complicated than it is).</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>Let's start with this simple Resource:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/john&quot;,
  &quot;https://example.com/lastName&quot;: &quot;McLovin&quot;,
}
</code></pre>
<p>Then the following Path targets the <code>McLovin</code> value:</p>
<p><code>https://example.com/john https://example.com/lastName</code> =&gt; <code>McLovin</code></p>
<p>Instead of using the full URL of the <code>lastName</code> Property, we can use its <a href="https://atomicdata.dev/properties/shortname">shortname</a>:</p>
<p><code>https://example.com/john lastname</code> =&gt; <code>McLovin</code></p>
<p>We can also traverse relationships between resources:</p>
<pre><code class="language-json">[{
  &quot;@id&quot;: &quot;https://example.com/john&quot;,
  &quot;https://example.com/lastName&quot;: &quot;McLovin&quot;,
  &quot;https://example.com/employer&quot;: &quot;https://example.com/XCorp&quot;,
},{
  &quot;@id&quot;: &quot;https://example.com/XCorp&quot;,
  &quot;https://example.com/description&quot;: &quot;The greatest company!&quot;,
}]
</code></pre>
<p><code>https://example.com/john employer description</code> =&gt; <code>The greatest company!</code></p>
<p>In the example above, the XCorp subject exists and is the source of the <code>The greatest company!</code> value.
We can use this path as a unique identifier for the description of John's current employer.
Note that the data for the description of that employer does not have to be in John's control for this path to work - it can live on a totally different server.
However, in Atomic Data it's also possible to include this description in the resource of John as a <em>Nested Resource</em>.</p>
<h2><a class="header" href="#nested-resources" id="nested-resources">Nested Resources</a></h2>
<p>All Atomic Data Resources that we've discussed so far have an explicit URL as a subject.
Unfortunately, creating unique and resolvable URLs can be a bother, and sometimes not necessary.
If you've worked with RDF, this is what Blank Nodes are used for.
In Atomic Data, we have something similar: <em>Nested Resources</em>.</p>
<p>Let's use a Nested Resource in the example from the previous section:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/john&quot;,
  &quot;https://example.com/lastName&quot;: &quot;McLovin&quot;,
  &quot;https://example.com/employer&quot;: {
    &quot;https://example.com/description&quot;: &quot;The greatest company!&quot;,
  }
}
</code></pre>
<p>Now the <code>employer</code> is simply a nested Object.
Note that it no longer has its own <code>@id</code>.
However, we can still identify this Nested Resource using its Path.</p>
<p>The Subject of the nested resource is its path: <code>https://example.com/john https://example.com/employer</code>, including the spacebar.</p>
<p>Note that the path from before still resolves:</p>
<p><code>https://example.com/john employer description</code> =&gt; <code>The greatest company!</code></p>
<h2><a class="header" href="#traversing-arrays" id="traversing-arrays">Traversing Arrays</a></h2>
<p>We can also navigate Arrays using paths.</p>
<p>For example:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/john&quot;,
  &quot;hasShoes&quot;: [
    {
      &quot;https://example.com/name&quot;: &quot;Mr. Boot&quot;,
    },
    {
      &quot;https://example.com/name&quot;: &quot;Sunny Sandals&quot;,
    }
  ]
}
</code></pre>
<p>The Path of <code>Mr. Boot</code> is:</p>
<pre><code>https://example.com/john hasShoes 0 name
</code></pre>
<p>You can target an item in an array by using a number to indicate its position, starting with 0.</p>
<p>Notice how the Resource with the <code>name: Mr. Boot</code> does not have an explicit <code>@id</code>, but it <em>does</em> have a Path.
This means that we still have a unique, globally resolvable identifier - yay!</p>
<h2><a class="header" href="#try-for-yourself" id="try-for-yourself">Try for yourself</a></h2>
<p>Install the <a href="https://github.com/joepio/atomic/blob/master/cli/README.md"><code>atomic-cli</code></a> software and run <code>atomic-cli get https://atomicdata.dev/classes/Class description</code>.</p>
<h1><a class="header" href="#atomic-schema" id="atomic-schema">Atomic Schema</a></h1>
<p>Atomic Schema is the proposed standard for specifying classes, properties and datatypes in Atomic Data.
You can compare it to what XSD is for XML.
Atomic Schema deals with validating and constraining the shape of data - it checks if all required properties are present, and whether the values conform to the datatype requirements (e.g. <code>datetime</code>, or <code>URL</code>).</p>
<p>This section will define various Classes, Properties and Datatypes (discussed in <a href="schema/../core/concepts.html">Atomic Core: Concepts</a>).</p>
<h2><a class="header" href="#design-goals-1" id="design-goals-1">Design Goals</a></h2>
<ul>
<li><strong>Decentralized</strong>: Classes and Properties can be defined in external systems, and are resolved using web protocols such as HTTP.</li>
<li><strong>Typed</strong>: Every Atom of data has a clear datatype. Validated data should be highly predictable.</li>
<li><strong>IDE-friendly</strong>: Although Atomic Schema uses many URLs, users / developers should not have to type full URLs. The schema uses shortnames as aliases.</li>
<li><strong>Self-documenting</strong>: When seeing a piece of data, simply following links will explain you how the data model is to be understood. This removes the need for (most of) existing API documentation.</li>
<li><strong>Extensible</strong>: Anybody can create their own Datatypes, Properties and Classes.</li>
<li><strong>Accessible</strong>: Support for languages, easily translatable. Useful for humans and machines.</li>
<li><strong>Atomic</strong>: All the design goals of Atomic Data itself also apply here. Atomic Schema is defined using Atomic Data.</li>
</ul>
<h2><a class="header" href="#in-short" id="in-short">In short</a></h2>
<p>In short, Atomic Schema works like this:</p>
<p>The Property <em>field</em> in an Atom links to a <strong>Property <em>Resource</em></strong>. It is important that the URL to the Property Resource resolves.
This Property does three things:</p>
<ol>
<li>it tells something about its semantic meaning, and links to a Datatype.</li>
<li>it links to a Datatype or Class, which indicates which Value is acceptable.</li>
<li>it provides a Shortname, which is used for ORM.</li>
</ol>
<p><strong>DataTypes</strong> define the shape of the Value, e.g. a Number (<code>124</code>) or Boolean (<code>true</code>).</p>
<p><strong>Classes</strong> are a special kind of Resource that describe an abstract class of things (such as &quot;Person&quot; or &quot;Blog&quot;).
Classes can <em>recommend</em> or <em>require</em> a set of Properties.
They behave as Models, similar to <code>struts</code> in C or <code>interfaces</code> in Typescript.
A Resource <em>could</em> have one or more classes, which <em>could</em> provide information about which Properties are expected or required.</p>
<h1><a class="header" href="#atomic-schema-classes" id="atomic-schema-classes">Atomic Schema: Classes</a></h1>
<h2><a class="header" href="#how-to-read-classes" id="how-to-read-classes">How to read classes</a></h2>
<p>Example:</p>
<ul>
<li><code>description</code> - (required, AtomicURL, TranslationBox) human readable explanation of what the Class represents.</li>
</ul>
<p>Means:</p>
<p>This class has a <em>required</em> property with shortname <code>description</code>.
This Property has a Datatype of <code>AtomicURL</code>, and these should point to <code>TranslationBox</code> instances.</p>
<p><em>Note: the URLs for properties are missing and will be added at a later time.</em></p>
<h2><a class="header" href="#property" id="property">Property</a></h2>
<p><em>URL: <a href="https://atomicdata.dev/classes/Property"><code>https://atomicdata.dev/classes/Property</code></a></em></p>
<p>The Property class.
The thing that the Property field should link to.
A Property is an abstract type of Resource that describes the relation between a Subject and a Value.
A Property provides some semantic information about the relationship (in its <code>description</code>), it provides a shorthand (the <code>shortname</code>) and it links to a Datatype.</p>
<p>Properties of a Property instance:</p>
<ul>
<li><a href="https://atomicdata.dev/properties/shortname"><code>shortname</code></a> - (required, Slug) the shortname for the property, used in ORM-style dot syntax (<code>thing.property.anotherproperty</code>).</li>
<li><a href="https://atomicdata.dev/properties/description"><code>description</code></a> - (optional, AtomicURL, TranslationBox) the semantic meaning of the.</li>
<li><a href="https://atomicdata.dev/properties/datatype"><code>datatype</code></a> - (required, AtomicURL, Datatype) a URL to an Atomic Datatype, which defines what the datatype should be of the Value in an Atom where the Property is the</li>
<li><a href="https://atomicdata.dev/properties/classtype"><code>classtype</code></a> - (optional, AtomicURL, Class) if the <code>datatype</code> is an Atomic URL, the <code>classtype</code> defines which class(es?) is (are?) acceptable.</li>
</ul>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://atomicdata.dev/properties/description&quot;,
  &quot;https://atomicdata.dev/properties/datatype&quot;: &quot;https://atomicdata.dev/datatypes/markdown&quot;,
  &quot;https://atomicdata.dev/properties/description&quot;: &quot;A textual description of something. When making a description, make sure that the first few words tell the most important part. Give examples. Since the text supports markdown, you're free to use links and more.&quot;,
  &quot;https://atomicdata.dev/properties/isA&quot;: [
    &quot;https://atomicdata.dev/classes/Property&quot;
  ],
  &quot;https://atomicdata.dev/properties/shortname&quot;: &quot;description&quot;
}
</code></pre>
<p>Visit https://atomicdata.dev/collections/property for a list of example Properties.</p>
<h2><a class="header" href="#datatype" id="datatype">Datatype</a></h2>
<p><em>URL: <code>https://atomicdata.dev/classes/Datatype</code></em></p>
<p>A Datatype specifies how a <code>Value</code> value should be interpreted.
Datatypes are concepts such as <code>boolean</code>, <code>string</code>, <code>integer</code>.
Since DataTypes can be linked to, you dan define your own.
However, using non-standard datatypes limits how many applications will know what to do with the data.</p>
<p>Properties:</p>
<ul>
<li><code>description</code> - (required, AtomicURL, TranslationBox) how the datatype functions.</li>
<li><code>stringSerialization</code> - (required, AtomicURL, TranslationBox) how the datatype should be parsed / serialized as an UTF-8 string</li>
<li><code>stringExample</code> - (required, string) an example <code>stringSerialization</code> that should be parsed correctly</li>
<li><code>binarySerialization</code> - (optional, AtomicURL, TranslationBox) how the datatype should be parsed / serialized as a byte array.</li>
<li><code>binaryExample</code> - (optional, string) an example <code>binarySerialization</code> that should be parsed correctly. Should have the same contents as the stringExample. Required if binarySerialization is present on the DataType.</li>
</ul>
<p>Visit https://atomicdata.dev/collections/datatype for a list of example Datatypes.</p>
<h2><a class="header" href="#class" id="class">Class</a></h2>
<p><em>URL: <code>https://atomicdata.dev/classes/Class</code></em></p>
<p>A Class is an abstract type of Resource, such as <code>Person</code>.
It is convention to use an Uppercase in its URI.
Note that in Atomic Data, a Resource can have several Classes - not just a single one.
If you need to set more complex constraints to your Classes (e.g. maximum string length, Properties that depend on each other), check out <a href="https://www.w3.org/TR/shacl/">SHACL</a>.</p>
<p>Properties:</p>
<ul>
<li><code>shortname</code> - (required, Slug) a short string shorthand.</li>
<li><code>description</code> - (required, AtomicURL, TranslationBox) human readable explanation of what the Class represents.</li>
<li><code>requires</code> - (optional, ResourceArray, Property) a list of Properties that are required. If absent, none are required. These SHOULD have unique shortnames.</li>
<li><code>recommends</code> - (optional, ResourceArray, Property) a list of Properties that are recommended. These SHOULD have unique shortnames.</li>
</ul>
<!-- - `deprecatedProperties` - (optional, ResourceArray, Property) - a list of Properties that should no longer be used. -->
<!-- Maybe remove this next one? -->
<!-- - `disallowedProperties` - (optional, ResourceArray) a list of Properties that are not allowed.  If absent, all are allowed. -->
<!-- What are the consequences of this? How to deal with this field if there are more classes in aSSubject? -->
<!-- - `allowedProperties` - (optional, ResourceArray) a list of Properties that are allowed. If absent, none are required. -->
<p>A resource indicates it is an <em>instance</em> of that class by adding a <code>https://atomicdata.dev/properties/isA</code> Atom.</p>
<p>Example:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://atomicdata.dev/classes/Class&quot;,
  &quot;https://atomicdata.dev/properties/description&quot;: &quot;A Class describes an abstract concept, such as 'Person' or 'Blogpost'. It describes the data shape of data and explains what the thing represents. It is convention to use Uppercase in its URL. Note that in Atomic Data, a Resource can have several Classes - not just a single one.&quot;,
  &quot;https://atomicdata.dev/properties/isA&quot;: [
    &quot;https://atomicdata.dev/classes/Class&quot;
  ],
  &quot;https://atomicdata.dev/properties/recommends&quot;: [
    &quot;https://atomicdata.dev/properties/recommends&quot;,
    &quot;https://atomicdata.dev/properties/requires&quot;
  ],
  &quot;https://atomicdata.dev/properties/requires&quot;: [
    &quot;https://atomicdata.dev/properties/shortname&quot;,
    &quot;https://atomicdata.dev/properties/description&quot;
  ],
  &quot;https://atomicdata.dev/properties/shortname&quot;: &quot;class&quot;
}
</code></pre>
<p>Visit https://atomicdata.dev/collections/class for the a list of example Classes.</p>
<h1><a class="header" href="#atomic-schema-datatypes" id="atomic-schema-datatypes">Atomic Schema: Datatypes</a></h1>
<p>The Atomic Datatypes consist of some of the most commonly used <a href="schema/classes.html#Datatype">Datatypes</a>.</p>
<p>Please visit <a href="https://atomicdata.dev/collections/datatype">https://atomicdata.dev/collections/datatype</a> for the latest list of official Datatypes.</p>
<h2><a class="header" href="#slug" id="slug">Slug</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/slug</code></em></p>
<p>A string with a limited set of allowed characters, used in IDE / Text editor context.
Only letters, numbers and dashes are allowed.</p>
<p>Regex: <code>^[a-z0-9]+(?:-[a-z0-9]+)*$</code></p>
<h2><a class="header" href="#atomic-url" id="atomic-url">Atomic URL</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/atomicURL</code></em></p>
<p>A URL that should resolve to an <a href="schema/../core/concepts.html#Resource">Atomic Resource</a>.</p>
<h2><a class="header" href="#uri" id="uri">URI</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/URI</code></em></p>
<p>A Uniform Resource Identifier, preferably a URL (i.e. an URI that can be fetched).
Could be HTTP, HTTPS, or any other type of schema.</p>
<h2><a class="header" href="#string" id="string">String</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/string</code></em></p>
<p>UTF-8 String, no max character count.
Newlines use backslash escaped <code>\n</code> characters.
Should not contain language specific data, use a <a href="schema/translations.html">TranslationBox</a> instead.</p>
<p>e.g. <code>String time! \n Second line!</code></p>
<h2><a class="header" href="#markdown" id="markdown">Markdown</a></h2>
<p><em>URL: <code>https://https://atomicdata.dev/datatypes/markdown</code></em></p>
<p>A markdown string, using the <a href="https://commonmark.org/">CommonMark syntax</a>.
UTF-8 formatted, no max character count, newlines are <code>\n</code>.</p>
<p>e.g.</p>
<pre><code class="language-md"># Heading

Paragraph with [link](https://example.com).
</code></pre>
<h2><a class="header" href="#integer" id="integer">Integer</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/integer</code></em></p>
<p>Signed Integer, max 64 bit.
Max value: <a href="https://en.wikipedia.org/wiki/9,223,372,036,854,775,807"><code>9223372036854775807</code></a></p>
<p>e.g. <code>-420</code></p>
<h2><a class="header" href="#float" id="float">Float</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/float</code></em></p>
<p>Number with a comma.
Max value: <a href="https://en.wikipedia.org/wiki/9,223,372,036,854,775,807"><code>9223372036854775807</code></a></p>
<p>e.g. <code>-420</code></p>
<h2><a class="header" href="#boolean" id="boolean">Boolean</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/boolean</code></em></p>
<p>True or false, one or zero.</p>
<p><strong>String serialization</strong></p>
<p><code>true</code> or <code>false</code>.</p>
<p><strong>Binary serialization</strong></p>
<p>Use a single bit one boolean.</p>
<p>1 for <code>true</code>, or 0 for <code>false</code>.</p>
<h2><a class="header" href="#date" id="date">Date</a></h2>
<p>ISO date <em>without time</em>.
YYYY-MM-DD.</p>
<p>e.g. <code>1991-01-20</code></p>
<h2><a class="header" href="#timestamp" id="timestamp">Timestamp</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/timestamp</code></em></p>
<p>Similar to <a href="https://www.unixtimestamp.com/">Unix Timestamp</a>.
Milliseconds since midnight UTC 1970 jan 01 (aka the <a href="https://en.wikipedia.org/wiki/Unix_time">Unix Epoch</a>).
Use this for most DateTime fields.
Signed 64 bit integer (instead of 32 bit in Unix systems).</p>
<p>e.g. <code>1596798919</code> (= 07 Aug 2020 11:15:19)</p>
<h2><a class="header" href="#resourcearray" id="resourcearray">ResourceArray</a></h2>
<p><em>URL: <code>https://atomicdata.dev/datatypes/resourceArray</code></em></p>
<p>Sequential, ordered list of Atomic URIs.
Serialized as a JSON array with strings.
Note that other types of arrays are not included in this spec, but can be perfectly valid.
(<a href="schema/">discussion</a>)</p>
<ul>
<li>e.g. <code>[&quot;https://example.com/1&quot;, &quot;https://example.com/1&quot;]</code></li>
</ul>
<h1><a class="header" href="#atomic-translations" id="atomic-translations">Atomic Translations</a></h1>
<p><em>Status: design / concept stage</em></p>
<p>Dealing with translations can be hard.
(<a href="https://github.com/ontola/atomic-data/issues/6">See discussion on this subject here.</a>)</p>
<h2><a class="header" href="#translationbox" id="translationbox">TranslationBox</a></h2>
<p><em>URL: <code>https://atomicdata.dev/classes/TranslationBox</code> (does not resolve yet)</em></p>
<p>A TranslationBox is a collection of translated strings, uses to provide multiple translations.
It has a long list of optional properties, each corresponding to some language.
Each possible language Property uses the following URL template: <code>https://atomicdata.dev/languages/{langguageTag}</code>.
Use a <a href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">BCP 47</a> language tag, e.g. <code>nl</code> or <code>en-US</code>.</p>
<p>For example:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/john&quot;,
  &quot;https://example.com/properties/lifestory&quot;: {
    &quot;https://atomicdata.dev/languages/en&quot;: &quot;Well, John was born and later he died.&quot;,
    &quot;https://atomicdata.dev/languages/nl&quot;: &quot;Tsja, John werd geboren en stierf later.&quot;
  },
}
</code></pre>
<p>Every single property used for Translation strings are instances of the Translation class.</p>
<p>A translation string uses the <a href="https://atomicdata.dev/datatypes/markdown">MDString</a> datatype, which means it allows Markdown syntax.</p>
<h1><a class="header" href="#atomic-collections" id="atomic-collections">Atomic Collections</a></h1>
<p><em>URL: <a href="https://atomicdata.dev/classes/Collection">https://atomicdata.dev/classes/Collection</a></em></p>
<p>Sooner or later, developers will have to deal with (long) lists of items.
For example, a set of blog posts, activities or users.
These lists often need to be paginated, sorted, and filtered.
For dealing with these problems, we have Atomic Collections.</p>
<p>An Atomic Collection is a Resource that links to a set of resources.
Note that Collections are designed to be <em>dynamic resources</em>, often (partially) generated at runtime.
Collections have various filters (<code>subject</code>, <code>property</code>, <code>value</code>) that can help to build a useful query.</p>
<ul>
<li><code>members</code>: How many items (members) are visible per page.</li>
<li><code>subject</code>: Filter results by a property URL.</li>
<li><code>property</code>: Filter results by a property URL.</li>
<li><code>value</code>: Filter results by a Value.</li>
<li><code>sort_by</code>: A property URL by which to sort.</li>
<li><code>sort_desc</code>: Sort descending, instead of ascending. Defaults to <code>false</code>.</li>
<li><code>current_page</code>: The number of the current page.</li>
<li><code>page_size</code>: How many items (members) are visible per page.</li>
<li><code>total_pages</code>: How many pages there are for the current collection.</li>
<li><code>total_items</code>: How many items (members) are visible per page.</li>
</ul>
<!-- - `scope`: The parent resource in which to limit the query (see Atomic Hierarchy) -->
<h2><a class="header" href="#persisting-properties-vs-query-parameters" id="persisting-properties-vs-query-parameters">Persisting Properties vs Query Parameters</a></h2>
<p>Since Atomic Collections are dynamic resources, you can pass query parameters to it.
The keys of the query params match the shortnames of the properties of the Collection.</p>
<p>For example, let's take the <a href="https://atomicdata.dev/collections/property">Properties Collection on atomicdata.dev</a>.
We could limit the page size to 2 by adding the <code>page_size=2</code> query parameter: <code>https://atomicdata.dev/collections/property?page_size=2</code>.
Or we could sort the list by the description property: <code>https://atomicdata.dev/collections/property?sort_by=https%3A%2F%2Fatomicdata.dev%2Fproperties%2Fdescription</code>.
Note that URLs need to be URL encoded.</p>
<p>These properties of Collections can either be set by passing query parameters, or they can be <em>persisted</em> by the Collection creator / editor.</p>
<h1><a class="header" href="#atomic-schema-faq" id="atomic-schema-faq">Atomic Schema FAQ</a></h1>
<h2><a class="header" href="#how-do-i-create-a-property-that-supports-multiple-datatypes" id="how-do-i-create-a-property-that-supports-multiple-datatypes">How do I create a Property that supports multiple Datatypes?</a></h2>
<p>A property only has one single Datatype.
However, feel free to create a new kind of Datatype that, in turn, refers to other Datatypes.
Perhaps Generics, or Option like types should be part of the Atomic Base Datatypes.</p>
<h2><a class="header" href="#how-should-a-client-deal-with-shortname-collisions" id="how-should-a-client-deal-with-shortname-collisions">How should a client deal with Shortname collisions?</a></h2>
<p>Atomic Data guarantees Subject-Property uniqueness, which means that Valid Resources are guaranteed to have only one of each Property.
Properties offer Shortnames, which are short strings.
These strings SHOULD be unique inside Classes, but these are not guaranteed to be unique inside all Resources.
Note that Resources can have multiple Classes, and through that, they can have colliding Shortnames.
Resources are also free to include Properties from other Classes, and their Shortnames, too, might collide.</p>
<p>For example:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/people/123&quot;,
  &quot;https://example.com/name&quot;: &quot;John&quot;,
  &quot;https://another.example.com/someOtherName&quot;: &quot;Martin&quot;
}
</code></pre>
<p>Let's assume that <code>https://example.com/name</code> and <code>https://another.example.com/someOtherName</code> are Properties that have the Shortname: <code>name</code>.</p>
<p>What if a client tries something such as <code>people123.name</code>?
To consistently return a single value, we need some type of <em>precedence</em>:</p>
<ol>
<li>The earlier Class mentioned in the <a href="https://atomicdata.dev/properties/isA"><code>isA</code></a> Property of the resource. Resources can have multiple classes, but they appear in an ordered ResourceArray. Classes, internally SHOULD have no key collisions in required and recommended properties, which means that they might have. If these exist internally, sort the properties by how they are ordered in the <code>isA</code> array - first item is preferred.</li>
<li>When the Properties are not part of any of the mentioned Classes, use Alphabetical sorting of the Property URL.</li>
</ol>
<p>When shortname collisions are possible, it's recommended to not use the shortname, but use the URL of the Property:</p>
<pre><code>people123.&quot;https://example.com/name&quot;
</code></pre>
<p>It is likely that using the URL for keys is also the most <em>performant</em>, since it probably more closely mimics the internal data model.</p>
<h2><a class="header" href="#atomic-data-uses-a-lot-of-links-how-do-you-deal-with-links-that-dont-work" id="atomic-data-uses-a-lot-of-links-how-do-you-deal-with-links-that-dont-work">Atomic Data uses a lot of links. How do you deal with links that don't work?</a></h2>
<ol>
<li>Use URIs schemes that use content addressing, such as <a href="schema/../interoperability/ipfs.html">IPFS</a> URIs.</li>
</ol>
<h2><a class="header" href="#how-does-atomic-schema-relate-to-rdf--shacl--shex--owl--rdfs" id="how-does-atomic-schema-relate-to-rdf--shacl--shex--owl--rdfs">How does Atomic Schema relate to RDF / SHACL / SheX / OWL / RDFS?</a></h2>
<p>Atomic Schema is <em>the</em> schema language for atomic data, whereas RDF has a couple of competing ones, which all vary greatly.
In short, OWL is not designed for schema validation, but SHACL and SheX can maybe be compared to Atomic Schema.
An important difference is that SHACL and SheX have to deal with all the complexities of RDF, whereas Atomic Data is more constrained.</p>
<p>For more information, see <a href="schema/../interoperability/rdf.html">RDF interoperability</a>.</p>
<h1><a class="header" href="#atomic-graph-validations" id="atomic-graph-validations">Atomic Graph Validations</a></h1>
<p>An Graph is a set of Atoms.
Since Atomic Data is designed to facilitate decentralized data storage, Graphs will often lack information or contain invalid data.
In this section, we define some of these concepts.</p>
<ul>
<li>A <strong>Valid Graph</strong> contains no mismatches between Datatypes from Properties and their usage in Atoms</li>
<li>A <strong>Closed Graph</strong> contains no unfetched outgoing links</li>
<li>A <strong>Verified Graph</strong> contains only Atoms from verified Authors</li>
<li>A <strong>Schema Complete Graph</strong> contains all used linked Properties</li>
<li>A <strong>Frozen Graph</strong> contains content-addressing identifiers (e.g. IPFS), all the way down</li>
</ul>
<p>These concepts are important when creating an implementation of a Store.</p>
<p>You can validate AD3 at <a href="https://atomicdata.dev/validate">atomicdata.dev/validate</a></p>
<h2><a class="header" href="#valid-graphs" id="valid-graphs">Valid Graphs</a></h2>
<p>We refer to a Graph as Valid, if the following constraints are met:</p>
<ul>
<li><strong>The Datatypes are correctly used</strong>. The Graph does not contain Atoms where the Datatype of the Value does not match the Datatype of the Property of the Atom.</li>
<li><strong>The links work</strong>. All URLs used in the Graph (Subject, Property, Value) resolve correctly to the required Datatype.</li>
<li><strong>The Class Restrictions are met</strong>. If a Class sets required properties, these must be present in Resources that are instances of that Class.</li>
</ul>
<p>Making sure Graphs are Valid is of great importance to anyone creating, sharing or using Atomic Data.
Services should specify whether they check the validity of graphs.</p>
<h2><a class="header" href="#closed-graphs" id="closed-graphs">Closed Graphs</a></h2>
<p>A Graph is Closed, when the Resources of all URLs are present in the Graph.
In other words, if you were to fetch and download every single URL in a Graph, you would not have any more Atoms than before.
There are no more unfetched outgoing links.</p>
<p>Closed Graphs are <em>rarely</em> required in Atomic Data; it's often perfectly fine to have outgoing links that do not have been fetched.</p>
<h2><a class="header" href="#verified-graphs" id="verified-graphs">Verified Graphs</a></h2>
<p>When you are given some Atomic Graph by someone, you initially don't know for sure whether the Atoms themselves are actually created by the one controlling the subject URL.
Someone may have tempered with the data, or fabricated it.</p>
<p>The process of Verification can be done in two ways:</p>
<ol>
<li><strong>Request the subjects, and check if the atoms match</strong>.</li>
<li><strong>Verify the signatures of the Resources or Commits</strong></li>
</ol>
<p>When one of these steps is taken, we say that the Graph is Verified.</p>
<h2><a class="header" href="#schema-complete-graphs" id="schema-complete-graphs">Schema Complete Graphs</a></h2>
<p>When a Graph has a set of Atoms, it might not possess all the information that is required to determine the datatype of each Atom.
When that is the case, we say the Graph is <em>Schema Complete</em>.</p>
<p>Having a Schema Complete Graph is essential for determining what the Datatype is of a Value.
Most implementations of Atomic Data will need Schema Completeness to create fitting views, or apply functional business logic.</p>
<p>Imagine some application (perhaps an app running inside a web-browser) that has only the following data:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;,&quot;https://example.com/birthDate&quot;,&quot;1991-01-20&quot;]
</code></pre>
<p>Now, by looking at this single Atom, we might assume that the Value is an ISO date,
but this type information is not known yet to the application.
This type information should be specified in the <code>example:birthDate</code> Property.
It is the responsibility of the application to make sure it possess the required Schema data.</p>
<p>We say a Graph is <em>Schema Complete</em> when it contains <em>at least</em> all the Property Classes that are used in the Property fields.</p>
<p>So let's add the missing Property: <code>https://example.com/birthDate</code></p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;,&quot;https://example.com/birthDate&quot;,&quot;1991-01-20&quot;]
[&quot;https://example.com/birthDate&quot;,&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/dateTime&quot;]
</code></pre>
<p>Now, since we've introduced yet another Property, we need to include that one as well:</p>
<pre><code class="language-ndjson">[&quot;https://example.com/john&quot;,&quot;https://example.com/birthDate&quot;,&quot;1991-01-20&quot;]
[&quot;https://example.com/birthDate&quot;,&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/dateTime&quot;]
[&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/Datatype&quot;,&quot;https://atomicdata.dev/datatypes/atomicURI&quot;]
</code></pre>
<p>Since all valid Atomic Data requires Property fields to resolve to Atomic Properties Classes, which are required to have an associated DataType...
We can safely say that the last atom in the example above (the one describing <code>https://atomicdata.dev/datatypes/Datatype</code>) will have to be pre
sent in all Schema Complete Atomic Graphs.</p>
<h2><a class="header" href="#frozen-graphs" id="frozen-graphs">Frozen Graphs</a></h2>
<p>A Frozen Graph consists only of resources with content-addressing identifiers as Subjects.
A <a href="https://flyingzumwalt.gitbooks.io/decentralized-web-primer/avenues-for-access/lessons/power-of-content-addressing.html">content-addressable</a> URL (such as an IPFS URL) refers to specific immutable content, that is absolutely certain not to change over time.
Due to its static nature, we call it <em>Frozen</em>.
As long as a graph contains links to HTTP Resources, it is not Frozen, since responses from that HTTP address might change over time.</p>
<p>Freezing a Graph, therefore, entails converting all resources to IFPS (or another content-addressable schema) Resources, and using only IPFS URLs.</p>
<p>Freezing a Graph has performance benefits for clients, since clients can easily verify if they already have (part of) the Graph locally, simply by comparing the URLs or Resources.
It also helps to make sure the content can be shared peer to peer</p>
<p>Note that <strong>Graphs with cyclical relations cannot be frozen</strong>, since every iteration that you'd try to freeze will change its references and therefore also its contents, and therefore also its content hash.</p>
<h1><a class="header" href="#atomic-commits" id="atomic-commits">Atomic Commits</a></h1>
<p><em>Disclaimer: Work in progress, prone to change.</em></p>
<p>Atomic Commits is a proposed standard for communicating state changes (events / transactions / patches / deltas / mutations) of <a href="commits/../core/intro.html">Atomic Data</a>.
It is the part of Atomic Data that is concerned with writing, editing, removing and updating information.</p>
<h2><a class="header" href="#design-goals-2" id="design-goals-2">Design goals</a></h2>
<ul>
<li><strong>Event sourced</strong>: Store and standardize <em>changes</em>, as well as the <em>current</em> state. This enables versioning, history playback, undo, audit logs, and more.</li>
<li><strong>Traceable origin</strong>: Every change should be traceable to an actor and a point in time.</li>
<li><strong>Verifiable</strong>: Have cryptographic proof for every change. Know <em>when</em>, and <em>what</em> was changed by <em>whom</em>.</li>
<li><strong>Identifiable</strong>: A single commit has an identifier - it is a resource.</li>
<li><strong>Decentralized</strong>: Commits can be shared in P2P networks from device to device, whilst maintaining verifiability.</li>
<li><strong>Extensible</strong>: The methods inside a commit are not fixed. Use-case specific methods can be added by anyone.</li>
<li><strong>Streamable</strong>: The commits could be used in streaming context.</li>
<li><strong>Familiar</strong>: Introduces as little new stuff as possible (no new formats or language to learn)</li>
<li><strong>Pub/Sub</strong>: Subscribe to changes and get notified on changes.</li>
<li><strong>ACID-compliant</strong>: An Atomic commit will only occur if it results in a valid state.</li>
<li><strong>Atomic</strong>: All the Atomic Data design goals also apply here.</li>
</ul>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>Although it's a good idea to keep data at the source as much as possible, we'll often need to synchronize two systems.
For example when data has to be queried or indexed differently than its source can support.
Doing this synchronization can be very difficult, since most of our software is designed to only maintain and share the <em>current state</em> of a system.</p>
<p>I noticed this mainly when working on OpenBesluitvorming.nl - an open data project where we aimed to fetch and standardize meeting data (votes, meeting minutes, documents) from 150+ local governments in the Netherlands.
We wrote software that fetched data from various systems (who all had different models, serialization formats and APIs), transformed this data to a single standard and share it through an API and a fulltext search endpoint.
One of the hard parts was keeping our data in sync with the sources.
How could we now if something was changed upstream?
We queried all these systems every night for <em>all meetings from the next and previous month</em>, and made deep comparisons to our own data.</p>
<p>This approach has a couple of issues:</p>
<ul>
<li>It costs a lot of resources, both for us and for the data suppliers.</li>
<li>It's not real-time - we can only run this once every 24 ours (because of how costly it is).</li>
<li>It's very prone to errors. We've had issues during all phases of Extraction, Transformation and Loading (ETL) processing.</li>
<li>It causes privacy issues. When some data at the source is removed (because it contained faulty or privacy sensitive data), how do we learn about that?</li>
</ul>
<p>Persisting and sharing state changes could solve these issues.
In order for this to work, we need to standardize this for all data suppliers.
We need a specification that is easy to understand for most developers.</p>
<p>Keeping track of where data comes from is essential to knowing whether you can trust it - whether you consider it to be true.
When you want to persist data, that quickly becomes bothersome.
Atomic Data and Atomic Commits aim to make this easier by using cryptography for ensuring data comes from some particular source, and is therefore trustworthy.</p>
<p>If you want to know how Atomic Commits differ from other specs, see the <a href="commits/compare.html">compare section</a></p>
<h1><a class="header" href="#atomic-commits-concepts" id="atomic-commits-concepts">Atomic Commits: Concepts</a></h1>
<h2><a class="header" href="#commit" id="commit">Commit</a></h2>
<p><em>url: <a href="https://atomicdata.dev/classes/Commit">https://atomicdata.dev/classes/Commit</a></em></p>
<p>A Commit is a Resource that describes how a Resource must be updated.
It can be used for auditing, versioning and feeds.
It is cryptographically signed by an <a href="https://atomicdata.dev/classes/Agent">Agent</a>.</p>
<p>The <strong>required fields</strong> are:</p>
<ul>
<li><code>subject</code> - The thing being changed. A Resource Subject URL that the Commit is providing information about.</li>
<li><code>signer</code> - Who's making the change. The Atomic URL of the Author's profile - which in turn must contain a <code>publicKey</code>.</li>
<li><code>signature</code> - Cryptographic proof of the change. A hash of the JSON-AD serialized Commit (without the <code>signature</code> field), signed by the Agent's <code>private-key</code>. This proves that the author is indeed the one who created this exact commit. The signature of the Commit is also used as the identifier of the commit.</li>
<li><code>created-at</code> - When the change was made. A UNIX timestamp number of when the commit was created.</li>
</ul>
<p>The <strong>optional method fields</strong> describe how the data must be changed:</p>
<ul>
<li><code>destroy</code> - If true, the existing Resource will be removed.</li>
<li><code>remove</code> - an array of Properties that need to be removed (including their values).</li>
<li><code>set</code> - a Nested Resource which contains all the new or edited fields.</li>
</ul>
<p>These commands are executed in the order above.
This means that you can set <code>destroy</code> to <code>true</code> and include <code>set</code>, which empties the existing resource and sets new values.</p>
<h2><a class="header" href="#agent" id="agent">Agent</a></h2>
<p><em>url: <a href="https://atomicdata.dev/classes/Agent">https://atomicdata.dev/classes/Agent</a></em></p>
<p>The Agent is the user / individual / organization / machine that can make changes to data.</p>
<p>The <strong>required fields</strong> are:</p>
<ul>
<li><a href="https://atomicdata.dev/properties/publicKey"><code>publicKey</code></a> - The key that cryptographically verifies the authenticity of Commits. Base64 serialized Ed25519 key.</li>
</ul>
<h3><a class="header" href="#posting-commits-using-http" id="posting-commits-using-http">Posting commits using HTTP</a></h3>
<p>Since Commits contains cryptographic proof of authorship, they can be accepted at a public endpoint.
There is no need for authentication.</p>
<p>A commit should be sent (using an HTTPS POST request) to a <code>/commmit</code> endpoint of an Atomic Server.
The server then checks the signature and the author rights, and responds with a <code>2xx</code> status code if it succeeded, or an <code>5xx</code> error if something went wrong.
The error will be a JSON object.</p>
<h3><a class="header" href="#serialization-with-json-ad" id="serialization-with-json-ad">Serialization with JSON-AD</a></h3>
<p>Let's look at an example Commit:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://atomicdata.dev/commits/3n+U/3OvymF86Ha6S9MQZtRVIQAAL0rv9ZQpjViht4emjnqKxj4wByiO9RhfL+qwoxTg0FMwKQsNg6d0QU7pAw==&quot;,
  &quot;https://atomicdata.dev/properties/createdAt&quot;: 1611489929370,
  &quot;https://atomicdata.dev/properties/isA&quot;: [
    &quot;https://atomicdata.dev/classes/Commit&quot;
  ],
  &quot;https://atomicdata.dev/properties/set&quot;: {
    &quot;https://atomicdata.dev/properties/shortname&quot;: &quot;1611489928&quot;
  },
  &quot;https://atomicdata.dev/properties/signature&quot;: &quot;3n+U/3OvymF86Ha6S9MQZtRVIQAAL0rv9ZQpjViht4emjnqKxj4wByiO9RhfL+qwoxTg0FMwKQsNg6d0QU7pAw==&quot;,
  &quot;https://atomicdata.dev/properties/signer&quot;: &quot;https://surfy.ddns.net/agents/9YCs7htDdF4yBAiA4HuHgjsafg+xZIrtZNELz4msCmc=&quot;,
  &quot;https://atomicdata.dev/properties/subject&quot;: &quot;https://atomicdata.dev/test&quot;
}
</code></pre>
<p>This Commit can be sent to any Atomic Server.
This server, in turn, should verify the signature and the author's rights before the server applies the Commit.</p>
<h3><a class="header" href="#calculating-the-signature" id="calculating-the-signature">Calculating the signature</a></h3>
<p>The signature is a base64 encoded Ed25519 signature of the deterministically serialized Commit.
Calculating the signature is a delicate process that should be followed to the letter - even a single character in the wrong place will result in an incorrect signature, which makes the Commit invalid.</p>
<p>The first step is <strong>serializing the commit deterministically</strong>.
This means that the process will always end in the exact same string.</p>
<ul>
<li>Serialize the Commit as JSON-AD.</li>
<li>Do not serialize the signature field.</li>
<li>Do not include empty objects or arrays.</li>
<li>If <code>destroy</code> is false, do not include it.</li>
<li>All keys are sorted alphabetically - both in the root object, as in any nested objects.</li>
<li>The JSON-AD is minified: no newlines, no spaces.</li>
</ul>
<p>This will result in a string.
The next step is to sign this string using the Ed25519 private key from the Author.
This signature is a byte array, which should be encoded in base64 for serialization.
Make sure that the Author's URL resolves to a Resource that contains the linked public key.</p>
<p>Congratulations, you've just created a valid Commit!</p>
<p>Here are currently working implementations of this process, including serialization and signing (links are permalinks).</p>
<ul>
<li><a href="https://github.com/joepio/atomic/blob/ceb88c1ae58811f2a9e6bacb7eaa39a2a7aa1513/lib/src/commit.rs#L81">in Rust (atomic-lib)</a>.</li>
<li><a href="https://github.com/joepio/atomic-data-browser/blob/fc899bb2cf54bdff593ee6b4debf52e20a85619e/src/atomic-lib/commit.ts#L51">in Typescript / Javascript (atomic-data-browser)</a>.</li>
</ul>
<p>If you want validate your implementation, check out the tests for these two projects.</p>
<h1><a class="header" href="#atomic-commits-compared-to-other-rdf-delta-models" id="atomic-commits-compared-to-other-rdf-delta-models">Atomic Commits compared to other (RDF) delta models</a></h1>
<p>Let's compare the <a href="commits/concepts.html">Atomic Commit</a> approach with some existing protocols for communicating state changes / patches / mutations / deltas in linked data, JSON and text files.
First, I'll briefly discuss the existing examples (<a href="https://github.com/ontola/atomic-data/issues">open a PR / issue</a> if we're missing something!).
After that, we'll discuss how Atomic Data differs from the existing ones.</p>
<h2><a class="header" href="#git" id="git">Git</a></h2>
<p>This might be an odd one in this list, but it is an interesting one nonetheless.
Git is an incredibly popular version control system that is used by most software developers to manage their code.
It's a decentralized concept which allows multiple computers to share a log of <em>commits</em>, which together represent a folder with its files and its history.
It uses hashing to represent (parts of) data (which keeps the <code>.git</code> folder compact through deduplication), and uses cryptographic keys to sign commits and verify authorship.
It is designed to work in the paradigm of text files, newlines and folders.
Since most data <em>can</em> be represented as text files in a folder, Git is very flexible.
This is partly because people are familiar with Git, but also because it has a great ecosystem - platforms such as Github provide a clean UI, cloud storage, issue tracking, authorization, authentication and more <em>for free</em>, as long as you use Git to manage your versions.</p>
<p>However, Git doesn't work great for structured data - especially when it changes a lot.
Git, on its own, does not perform any validations on integrity of data.
Git also does not adhere to some standardized serialization format for storing commits, which makes sense, because it was designed as a tool to solve a problem, and not as some standard that is to be used in various other systems.
Also, git is kind of a heavyweight abstraction for many applications.
It is designed for collaborating on open source projects, which means dealing with decentralized data storage and merge conflicts - things that might not be required in other kinds of scenarios.</p>
<h2><a class="header" href="#rdf-mutation-systems" id="rdf-mutation-systems">RDF mutation systems</a></h2>
<h3><a class="header" href="#rdf-delta" id="rdf-delta">RDF-Delta</a></h3>
<p><a href="commits/">https://afs.github.io/rdf-delta/</a></p>
<p>Describes changes (RDF Patches) in a specialized turtle-like serialization format.</p>
<pre><code>TX .
PA &quot;rdf&quot; &quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot; .
PA &quot;owl&quot; &quot;http://www.w3.org/2002/07/owl#&quot; .
PA &quot;rdfs&quot; &quot;http://www.w3.org/2000/01/rdf-schema#&quot; .
A &lt;http://example/SubClass&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://www.w3.org/2002/07/owl#Class&gt; .
A &lt;http://example/SubClass&gt; &lt;http://www.w3.org/2000/01/rdf-schema#subClassOf&gt; &lt;http://example/SUPER_CLASS&gt; .
A &lt;http://example/SubClass&gt; &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; &quot;SubClass&quot; .
TC .
</code></pre>
<p>Similar to Atomic Commits, these Delta's should have identifiers (URLs), which are denoted in a header.</p>
<h3><a class="header" href="#delta-ld" id="delta-ld">Delta-LD</a></h3>
<p><a href="commits/">http://www.tara.tcd.ie/handle/2262/91407</a></p>
<p>Spec for classifying and representing state changes between two RDF resources.
I wasn't able to find a serialization or an implementation for this.</p>
<h3><a class="header" href="#patchr" id="patchr">PatchR</a></h3>
<p><a href="commits/">https://www.igi-global.com/article/patchr/135561</a></p>
<p>An ontology for RDF change <em>requests</em>.
Looks very interesting, but I'm not able to find any implementations.</p>
<pre><code class="language-turtle">prefix :      &lt;http://example.org/&gt; .
@prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix pat:  &lt;http://purl.org/hpi/patchr#&gt; .
@prefix guo:  &lt;http://webr3.org/owl/guo#&gt; .
@prefix prov: &lt;http://purl.org/net/provenance/ns#&gt; .
@prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt; .
@prefix dbp:  &lt;http://dbpedia.org/resource/&gt; .
@prefix dbo:  &lt;http://dbpedia.org/ontology/&gt; .

:Patch_15 a pat:Patch ;
  pat:appliesTo &lt;http://dbpedia.org/void.ttl#DBpedia_3.5&gt; ;
  pat:status pat:Open ;
  pat:update [
    a guo:UpdateInstruction ;
    guo:target_graph &lt;http://dbpedia.org/&gt; ;
    guo:target_subject dbp:Oregon ;
    guo:delete [dbo:language dbp:De_jure ] ;
    guo:insert [dbo:language dbp:English_language ]
  ] ;
  prov:wasGeneratedBy [a prov:Activity ;
  pat:confidence &quot;0.5&quot;^^xsd:decimal ;
  prov:wasAssociatedWith :WhoKnows ;
  prov:actedOnBehalfOf :WhoKnows#Player_25 ;
  prov:performedAt &quot;...&quot;^^xsd:dateTime ] .
</code></pre>
<h3><a class="header" href="#ld-patch" id="ld-patch">LD-Patch</a></h3>
<p><a href="commits/">https://www.w3.org/TR/ldpatch/</a></p>
<p>This offers quite a few features besides adding and deleting triples, such as updating lists.
It's a unique serialization format, inspired by turtle.
Some implementations exists, such as one in <a href="https://github.com/ruby-rdf/ld-patch">ruby</a> which is</p>
<pre><code>PATCH /timbl HTTP/1.1
Host: example.org
Content-Length: 478
Content-Type: text/ldpatch
If-Match: &quot;abc123&quot;

@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix schema: &lt;http://schema.org/&gt; .
@prefix profile: &lt;http://ogp.me/ns/profile#&gt; .
@prefix ex: &lt;http://example.org/vocab#&gt; .

Delete { &lt;#&gt; profile:first_name &quot;Tim&quot; } .
Add {
  &lt;#&gt; profile:first_name &quot;Timothy&quot; ;
    profile:image &lt;https://example.org/timbl.jpg&gt; .
} .

Bind ?workLocation &lt;#&gt; / schema:workLocation .
Cut ?workLocation .

UpdateList &lt;#&gt; ex:preferredLanguages 1..2 ( &quot;fr-CH&quot; ) .

Bind ?event &lt;#&gt; / schema:performerIn [ / schema:url = &lt;https://www.w3.org/2012/ldp/wiki/F2F5&gt; ]  .
Add { ?event rdf:type schema:Event } .

Bind ?ted &lt;http://conferences.ted.com/TED2009/&gt; / ^schema:url ! .
Delete { ?ted schema:startDate &quot;2009-02-04&quot; } .
Add {
  ?ted schema:location [
    schema:name &quot;Long Beach, California&quot; ;
    schema:geo [
      schema:latitude &quot;33.7817&quot; ;
      schema:longitude &quot;-118.2054&quot;
    ]
  ]
} .
</code></pre>
<h3><a class="header" href="#linked-delta" id="linked-delta">Linked-Delta</a></h3>
<p><a href="commits/">https://github.com/ontola/linked-delta</a></p>
<p>An N-Quads serialized delta format.
Methods are URLs, which means they are extensible.
Does not specify how to bundle lines.
Used in production of a web app that we're working on (<a href="https://argu.co">Argu.co</a>).
Designed with simplicity (no new serialization format, simple to parse) and performance in mind.</p>
<pre><code>Initial state:

&lt;http://example.org/resource&gt; &lt;http://example.org/predicate&gt; &quot;Old value &quot; .

Linked-Delta:

&lt;http://example.org/resource&gt; &lt;http://example.org/predicate&gt; &quot;New value &quot; &lt;http://purl.org/linked-delta/replace&gt; .

New state:

&lt;http://example.org/resource&gt; &lt;http://example.org/predicate&gt; &quot;New value &quot; .
</code></pre>
<h2><a class="header" href="#json-ld-patch" id="json-ld-patch">JSON-LD-PATCH</a></h2>
<p><a href="commits/">https://github.com/digibib/ls.ext/wiki/JSON-LD-PATCH</a></p>
<p>A JSON denoted patch notation for RDF.
Seems similar to the <a href="https://www.w3.org/TR/rdf-json/">RDF/JSON</a> serialization format.
Uses string literals as operators / methods.
Conceptually perhaps most similar to linked-delta.</p>
<p>Has a <a href="https://developer.aliyun.com/mirror/npm/package/jsonld-patch">JS implementation</a>.</p>
<pre><code>[
  {
    &quot;op&quot;: &quot;add&quot;,
    &quot;s&quot;: &quot;http://example.org/my/resource&quot;,
    &quot;p&quot;: &quot;http://example.org/ontology#title&quot;,
    &quot;o&quot;: {
      &quot;value&quot;: &quot;New Title&quot;,
      &quot;type&quot;: &quot;http://www.w3.org/2001/XMLSchema#string&quot;
    }
  }
]
</code></pre>
<h3><a class="header" href="#sparql-update" id="sparql-update">SPARQL UPDATE</a></h3>
<p><a href="commits/">https://www.w3.org/TR/sparql11-update/</a></p>
<p>SPARQL queries that change data.</p>
<pre><code class="language-sparql">PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
INSERT DATA
{
  &lt;http://example/book1&gt; dc:title &quot;A new book&quot; ;
                         dc:creator &quot;A.N.Other&quot; .
}
</code></pre>
<p>Allows for very powerful queries, combined with updates.
E.g. rename all persons named <code>Bill</code> to <code>William</code>:</p>
<pre><code>PREFIX foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;

WITH &lt;http://example/addresses&gt;
DELETE { ?person foaf:givenName 'Bill' }
INSERT { ?person foaf:givenName 'William' }
WHERE
  { ?person foaf:givenName 'Bill'
  }
</code></pre>
<p>SPARQL Update is the most powerful of the formats, but also perhaps the most difficult to implement and understand.</p>
<h2><a class="header" href="#json-patch" id="json-patch">JSON-PATCH</a></h2>
<p><a href="commits/">http://jsonpatch.com/</a></p>
<p>A simple way to edit JSON objects:</p>
<pre><code>The original document

{
  &quot;baz&quot;: &quot;qux&quot;,
  &quot;foo&quot;: &quot;bar&quot;
}

The patch

[
  { &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/baz&quot;, &quot;value&quot;: &quot;boo&quot; },
  { &quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/hello&quot;, &quot;value&quot;: [&quot;world&quot;] },
  { &quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/foo&quot; }
]

The result

{
  &quot;baz&quot;: &quot;boo&quot;,
  &quot;hello&quot;: [&quot;world&quot;]
}
</code></pre>
<p>It uses the <a href="http://tools.ietf.org/html/rfc6901">JSON-Pointer spec</a> for denoting <code>path</code>s.
It has quite a bunch of implementations, in various languages.</p>
<h2><a class="header" href="#atomic-commits-1" id="atomic-commits-1">Atomic Commits</a></h2>
<p>Let's talk about the differences between the concepts above and Atomic Commits.</p>
<p>For starters, Atomic Commits can only work with a <em>specific subset</em> of RDF, namely Atomic Data.
RDF allows for blank nodes, does not have subject-predicate uniqueness and offers named graphs - which all make it hard to unambiguously select a single value.
Most of the alternative patch / delta models described above had to support these concepts.
Atomic Data is more strict and constrained than RDF.
It does not support named graphs and blank nodes.
This enables a simpler approach to describing state changes, but it also means that Atomic Commits will not work with most existing RDF data.</p>
<p>Secondly, individual Atomic Commits are tightly coupled to specific Resources.
A single Commit cannot change multiple resources - and most of the models discussed above to enable this.
This is a big constraint, and it does not allow for things like compact migrations in a database.
However, this resource-bound constraint opens up some interesting possibilities:</p>
<ul>
<li>it becomes easier to combine it with <em>authorization</em> (i.e. check if the person has the correct rights to edit some resource): simply check if the Author has the rights to edit the Subject.</li>
<li>it makes it easier to find all Commits for a Resource, which is useful when constructing a history / audit log / previous version.</li>
</ul>
<p>Thirdly, Atomic Commits don't introduce a new serialization format.
It's just JSON.
This means that it will feel familiar for most developers, and will be supported by many existing environments.</p>
<p>Finally, Atomic Commits use cryptography (hashing) to determine authenticity of commits.
This concept is borrowed from git commits, which also uses signatures to prove authorship.
As is the case with git, this also allows for verifiable P2P sharing of changes.</p>
<h1><a class="header" href="#interoperability-relation-to-other-technology" id="interoperability-relation-to-other-technology">Interoperability: Relation to other technology</a></h1>
<p>Atomic data is designed to be easy to use in existing projects, and be interoperable with existing formats.</p>
<h2><a class="header" href="#data-formats" id="data-formats">Data formats</a></h2>
<ul>
<li><a href="interoperability/json.html">JSON</a>: Atomic Data is designed to be easily serializable to clean, idiomatic JSON. However, if you want to turn JSON into Atomic Data, you'll have to make sure that all keys in the JSON object are URLs that link to Atomic Properties, and the data itself also has to be available at its Subject URL.</li>
<li><a href="interoperability/rdf.html">RDF</a>: Atomic Data is a strict subset of RDF, and can therefore be trivially serialized to all RDF formats (Turtle, N-triples, RDF/XML, JSON-LD, and others). The other way around is more difficult. Turning RDF into Atomic Data requires that all predicates are Atomic Properties, the values must match its properties datatype, the atoms must be available at the subject URL, and the subject-predicate combinations must be unique.</li>
</ul>
<h2><a class="header" href="#protocols" id="protocols">Protocols</a></h2>
<ul>
<li><a href="interoperability/ipfs.html">IPFS</a>: Content-based addressing to prevent 404s and centralization</li>
</ul>
<h2><a class="header" href="#database-paradigms" id="database-paradigms">Database paradigms</a></h2>
<ul>
<li><a href="interoperability/sql.html">SQL</a>: How Atomic Data differs from and could interact with SQL databases</li>
</ul>
<h2><a class="header" href="#upgrade-guide" id="upgrade-guide">Upgrade guide</a></h2>
<ul>
<li><a href="interoperability/upgrade.html">Upgrade</a>: How to make your existing server-side application compatible with Atomic Data</li>
</ul>
<h1><a class="header" href="#how-does-atomic-data-relate-to-rdf" id="how-does-atomic-data-relate-to-rdf">How does Atomic Data relate to RDF?</a></h1>
<p>RDF (the <a href="https://www.w3.org/TR/rdf-primer/">Resource Description Framework</a>) is a W3C specification from 1999 that describes the original data model for linked data.
It is the forerunner of Atomic Data, and is therefore highly similar in its model.
Both heavily rely on using URLs, and both have a fundamentally simple and uniform model for data statements.
Both view the web as a single, connected graph database.
Because of that, Atomic Data is also highly compatible with RDF - <strong>all Atomic Data is also valid RDF</strong>.
Atomic Data can be thought of as a <strong>more constrained, type safe version of RDF</strong>.
However, it does differ in some fundamental ways.</p>
<ul>
<li>Atomic calls the three parts of a Triple <code>subject</code>, <code>property</code> and <code>value</code>, instead of <code>subject</code>, <code>predicate</code>, <code>object</code>.</li>
<li>Atomic does not support having multiple statements with the same <code>&lt;subject&gt; &lt;predicate&gt;</code>, every combination must be unique.</li>
<li>Atomic does not have <code>literals</code>, <code>named nodes</code> and <code>blank nodes</code> - these are all <code>values</code>, but with different datatypes.</li>
<li>Atomic uses <code>nested Resources</code> and <code>paths</code> instead of <code>blank nodes</code></li>
<li>Atomic requires URL (not URI) values in its <code>subjects</code> and <code>properties</code> (predicates), which means that they should be resolvable. Properties must resolve to an <code>Atomic Property</code>, which describes its datatype.</li>
<li>Atomic only allows those who control a resource's <code>subject</code> URL endpoint to edit the data. This means that you can't add triples about something that you don't control.</li>
<li>Atomic has no separate <code>datatype</code> field, but it requires that <code>Properties</code> (the resources that are shown when you follow a <code>predicate</code> value) specify a datatype. However, it is allowed to serialize the datatype explicitly, of course.</li>
<li>Atomic has no separate <code>language</code> field, but it does support <a href="interoperability/../schema/translations.html">Translation Resources</a>.</li>
<li>Atomic has a native Event (state changes) model (<a href="interoperability/../commits/intro.html">Atomic Commits</a>), which enables communication of state changes</li>
<li>Atomic has a native Schema model (<a href="interoperability/../schema/intro.html">Atomic Schema</a>), which helps developers to know what data types they can expect (string, integer, link, array)</li>
<li>Atomic does not support Named Graphs. These should not be needed, because all statements should be retrievable by fetching the Subject of a resource. However, it <em>is</em> allowed to include other resources in a response.</li>
</ul>
<h2><a class="header" href="#why-these-changes" id="why-these-changes">Why these changes?</a></h2>
<p>I love RDF, and have been working with it for quite some time now.
I started a company that specializes in Linked Data, and we use it extensively in our products and services.
Using URIs (and more-so URLs, which are URIs that can be fetched) for everything is a great idea, since it helps with interoperability and enables truly decentralized knowledge graphs.
However, some of the characteristics of RDF might have contributed to its relative lack of adoption.</p>
<h3><a class="header" href="#its-too-hard-to-select-a-specific-value-object-in-rdf" id="its-too-hard-to-select-a-specific-value-object-in-rdf">It's too hard to select a specific value (object) in RDF</a></h3>
<p>For example, let's say I want to render someone's birthday:</p>
<pre><code class="language-ttl">&lt;example:joep&gt; &lt;schema:birthDate&gt; &quot;1991-01-20&quot;^^xsd:date
</code></pre>
<p>Rendering this item might be as simple as fetching the subject URL, filtering by predicate URL, and parsing the <code>object</code> as a date.</p>
<p>However, this is also valid RDF:</p>
<pre><code class="language-ttl">&lt;example:joep&gt; &lt;schema:birthDate&gt; &quot;1991-01-20&quot;^^xsd:date &lt;example:someNamedGraph&gt;
&lt;example:joep&gt; &lt;schema:birthDate&gt; &lt;example:birthDateObject&gt; &lt;example:someOtherNamedGraph&gt;
&lt;example:joep&gt; &lt;schema:birthDate&gt; &quot;20th of januari 1991&quot;@en &lt;example:someNamedGraph&gt;
&lt;example:joep&gt; &lt;schema:birthDate&gt; &quot;20 januari 1991&quot;@nl &lt;example:someNamedGraph&gt;
&lt;example:joep&gt; &lt;schema:birthDate&gt; &quot;2000-02-30&quot;^^xsd:date &lt;example:someNamedGraph&gt;
</code></pre>
<p>Now things get more complicated if you just want to select the original birthdate value:</p>
<ol>
<li><strong>Select the named graph</strong>. The triple containing that birthday may exist in some named graph different from the <code>subject</code> URL, which means that I first need to identify and fetch that graph.</li>
<li><strong>Select the subject</strong>.</li>
<li><strong>Select the predicate</strong>.</li>
<li><strong>Select the datatype</strong>. You probably need a specific datatype (in this case, a Date), so you need to filter the triples to match that specific datatype.</li>
<li><strong>Select the language</strong>. Same could be true for language, too, but that is not necessary in this birthdate example.</li>
<li><strong>Select the specific triple</strong>. Even after all our previous selectors, we <em>still</em> might have multiple values. How do I know which is the triple I'm supposed to use?</li>
</ol>
<p>To be fair, with a lot of RDF data, only steps 2 and 3 are needed, since there are often no <code>subject-predicate</code> collisions.
And if you <em>control</em> the data of the source, you can set any constraints that you like, inlcluding <code>subject-predicate</code> uniqueness.
But if you're building a system that uses arbitrary RDF, that system also needs to deal with steps 1,4,5 and 6.
That often means writing a lot of conditionals and other client-side logic to get the value that you need.
It also means that serializing to a format like JSON becomes complicated - you can't just map predicates to keys - you might get collisions.
And you can't use key-value stores for storing RDF, at least not in a trivial way.
Every single <em>selected value</em> should be treated as an array of unknown datatypes, and that makes it really difficult to build software.
All this complexity is the direct result of the lack of <code>subject-predicate</code> uniqueness.</p>
<p>As a developer who uses RDF data, I want to be able to do something like this:</p>
<pre><code class="language-js">// Fetches the resource
const joep = get(&quot;https://example.com/person/joep&quot;)
// Returns the value of the birthDate atom
console.log(joep.birthDate()) // =&gt; Date(1991-01-20)
// Fetches the employer relation at possibly some other domain, checks that resource for a property with the 'name' shortkey
console.log(joep.employer().name()) // =&gt; &quot;Ontola.io&quot;
</code></pre>
<p>Basically, I'd like to use all knowledge of the world as if it were a big JSON object.
Being able to do that, requires using some things that are present in JSON, and using some things that are present in RDF.</p>
<ul>
<li>Traverse data on various domains (which is already possible with RDF)</li>
<li>Have <a href="interoperability/rdf.html#subject-predicate-uniqueness">unique <code>subject-predicate</code> combinations</a> (which is default in JSON)</li>
<li>Map properties URLs to keys (which often requires local mapping with RDF, e.g. in JSON-LD)</li>
<li>Link properties to datatypes (which is possible with ontologies like SHACL / SHEX)</li>
</ul>
<h3><a class="header" href="#less-focus-on-semantics-more-on-usability" id="less-focus-on-semantics-more-on-usability">Less focus on semantics, more on usability</a></h3>
<p>One of the core ideas of the semantic web, is that anyone should be able to say anything about anything, using semantic triples.
This is one of the reasons why it can be so hard to select a specific value in RDF.
When you want to make all graphs mergeable (which is a great idea), but also want to allow anyone to create any triples about any subject, you get <code>subject-predicate</code> non-uniqueness.
For the Semantic Web, having <em>semantic</em> triples is great.
For linked data, and connecting datasets, having atomic triples (with unique <code>subject-predicate</code> combinations) seems preferable.
Atomic Data chooses a more constrained approach, which makes it easier to use the data, but at the cost of some expressiveness.</p>
<h3><a class="header" href="#changing-the-names" id="changing-the-names">Changing the names</a></h3>
<p>RDF's <code>subject</code>, <code>predicate</code> and <code>object</code> terminology can be confusing to newcomers, so Atomic Data uses <code>subject</code>, <code>property</code>, <code>value</code>.
This more closely resembles common CS terminology. (<a href="https://github.com/ontola/atomic-data/issues/3">discussion</a>)</p>
<h3><a class="header" href="#subject--predicate-uniqueness" id="subject--predicate-uniqueness">Subject + Predicate uniqueness</a></h3>
<p>In RDF, it's very much possible for a graph to contain multiple statements that share both a <code>subject</code> and a <code>predicate</code>.
One of the reasons this is possible, is because RDF graphs should always be mergeable.
However, this introduces some extra complexity for data users.
Whereas most languages and datatypes have <code>key-value</code> uniqueness that allow for unambiguous value selection, RDF clients have to deal with the possibility that multiple triples with the same <code>subject-predicate</code> combination might exist.</p>
<p>Atomic Data requires <code>subject-property</code> uniqueness, which means that this is no longer an issue for clients.
However, in order to guarantee this, and still retain <em>graph merge-ability</em> we also need to limit who creates statements about a subject:</p>
<h3><a class="header" href="#limiting-subject-usage" id="limiting-subject-usage">Limiting subject usage</a></h3>
<p>RDF allows that <code>anne.com</code> creates and hosts statements about the subject <code>john.com</code>.
In other words, domain A creates statements about domain B.
It allows anyone to say anything about any subject, thus allowing for extending data that is not under your control.</p>
<p>For example, developers at both Ontola and Inrupt (two companies that work a lot with RDF) use this feature to extend the Schema.org ontology with translations.
This means they can still use standards from Schema.org, and have their own translations of these concepts.</p>
<p>However, I think this is a flawed approach.
In the example above, two companies are adding statements about a subject.
In this case, both are adding translations.
They're doing the same work twice.
And as more and more people will use that same resource, they will be forced to add the same translations, again and again.</p>
<p>I think one of the core perks of linked data, is being able to make your information highly re-usable.
When you've created statements about an external thing, these statements are hard to re-use.</p>
<p>This means that someone using RDF data about domain B cannot know that domain B is actually the source of the data.
Knowing <em>where data comes from</em> is one of the great things about URIs, but RDF does not require that you can think of subjects as the source of data.
Many subjects in RDF don't actually resolve to all the known triples of the statement.
It would make the conceptual model way simpler if statements about a subject could only be made from the source of the domain owner of the subject.
When triples are created about a resource in a place other than where the subject is hosted, these triples are hard to share.</p>
<p>The way RDF projects deal with this, is by using <em>named graphs</em>.
As a consequence, all systems that use these triples should keep track of another field for every atom.
To make things worse, it makes <code>subject-predicate</code> <em>impossible</em> to guarantee.
That's a high price to pay.</p>
<p>I've asked two RDF developers (who did not know each other) working on RDF about limiting subject usage, and both were critical.
Interestingly, they provided the same usecase for using named graphs that would conflict with the limiting subject usage constraint.
They both wanted to extend the schema.org ontology by adding properties to these items in a local graph.
I don't think even this usecase is appropriate for named graphs. They were actually using an external resource that did not provide them with the things they needed. The things that they would add (the translations) are not re-usable, so in the end they will just keep spreading a URL that doesn't provide people with the things that they will come to expect. The schema.org URL still won't provide the translations that they wrote!
I believe a better solution is to copy the resource (in this case a part of the schema.org ontology), and extend it, and host it somewhere else, and use that URL.
Or even better: have a system for <a href="https://github.com/ontola/atomic-data/issues/21">sharing your change suggestions</a> with the source of the data, and allow for easy collaboration on ontologies.</p>
<h3><a class="header" href="#no-more-literals--named-nodes" id="no-more-literals--named-nodes">No more literals / named nodes</a></h3>
<p>In RDF, an <code>object</code> can either be a <code>named node</code>, <code>blank node</code> or <code>literal</code>. A <code>literal</code> has a <code>value</code>, a <code>datatype</code> and an optional <code>language</code> (if the <code>literal</code> is a string).
Although RDF statements are often called <code>triples</code>, a single statement can consist of five fields: <code>subject</code>, <code>predicate</code>, <code>object</code>, <code>language</code>, <code>datatype</code>.
Having five fields is way more than most information systems. Usually we have just <code>key</code> and <code>value</code>.
This difference leads to compatibility issues when using RDF in applications.
In practice, clients have to run a lot of checks before they can use the data - which makes RDF in most contexts harder to use than something such as JSON.</p>
<p>Atomic Data drops the <code>named node</code> / <code>literal</code> distinction.
We just have <code>values</code>, and they are interpreted by looking at the <code>datatype</code>, which is defined in the <code>property</code>.
When a value is a URL, we don't call it a named node, but we simply use a URL datatype.</p>
<h3><a class="header" href="#requiring-urls" id="requiring-urls">Requiring URLs</a></h3>
<p>RDF allows any type of URIs for <code>subject</code> and <code>predicate</code> value, which means they can be URLs, but don't have to be. This means they don't always resolve, or even function as locators. The links don't work, and that restricts how useful the links are. Atomic Data takes a different approach: these links MUST Resolve. Requiring Properties to resolve is part of what enables the type system of Atomic Schema - they provide the <code>shortname</code> and <code>datatype</code>.</p>
<p>Requiring URLs makes things easier for data users, at the cost of the data producer.
With Atomic Data, the data producer MUST offer the triples at the URL of the subject.
This is a challenge - especially with the current (lack of) tooling.</p>
<p>However - making sure that links <em>actually work</em> offer tremendous benefits for data consumers, and that advantage is often worth the extra trouble.</p>
<h3><a class="header" href="#replace-blank-nodes-with-paths" id="replace-blank-nodes-with-paths">Replace blank nodes with paths</a></h3>
<p>Blank (or anonymous) nodes are RDF resources with identifiers that exist only locally.
In other words, their identifiers are not URLs.
They are sometimes also called <code>anonymous nodes</code>.
They make life easier for data producers, who can easily create (nested) resources without having to mint all the URLs.
In most non-RDF data models, blank nodes are the default.
For example, we nest JSON object without thinking twice.</p>
<p>Unfortunately, blank nodes tend to make things harder for clients.
These clients will now need to keep track of where these blank nodes came from, and they need to create internal identifiers that will not collide.
Cache invalidation with blank nodes also becomes a challenge.
To make this a bit easier, Atomic Data introduces a new way of dealing with names of things that you have not given a URL yet: <a href="interoperability/../core/paths.html">Atomic Paths</a>.</p>
<p>Since Atomic Data has <code>subject-predicate</code> uniqueness (like JSON does, too), we can use the <em>path</em> of triples as a unique identifier:</p>
<pre><code>https://example.com/john https://schema.org/employer
</code></pre>
<p>This prevents collisions and still makes it easy to point to a specific value.</p>
<p>Serialization formats are free to use nesting to denote paths - which means that it is not necessary to include these path strings explicitly in most serialization formats, such as in JSON-AD.</p>
<h3><a class="header" href="#combining-datatype-and-predicate" id="combining-datatype-and-predicate">Combining datatype and predicate</a></h3>
<p>Having both a <code>datatype</code> and a <code>predicate</code> value can lead to confusing situations.
For example, the <a href="https://schema.org/dateCreated"><code>schema:dateCreated</code></a> Property requires an ISO DateTime string (according to the schema.org definition), but using a value <code>true</code> with an <code>xsd:boolean</code> datatype results in perfectly valid RDF.
This means that client software using triples with a <code>schema:dateCreated</code> predicate cannot safely assume that its value will be a DateTime.
So if the client wants to use <code>schema:dateCreated</code> values, the client must also specify which type of data it expects, check the datatype field of every Atom and provide logic for when these don't match.
Also important combining <code>datatype</code> and <code>predicate</code> fits the model of most programmers and languages better - just look at how every single struct / model / class / shape is defined in programming languages: <code>key: datatype</code>.
This is why Atomic Data requires that a <code>predicate</code> links to a Property which must have a <code>Datatype</code>.</p>
<h3><a class="header" href="#adding-shortnames-slugs--keys-in-properties" id="adding-shortnames-slugs--keys-in-properties">Adding shortnames (slugs / keys) in Properties</a></h3>
<p>Using full URI strings as keys (in RDF <code>predicates</code>) results in a relatively clunky Developer Experience.
Consider the short strings that developers are used to in pretty much all languages and data formats (<code>object.attribute</code>).
Adding a <em>required</em> / tightly integrated key mapping (from long URLs to short, simple strings) in Atomic Properties solves this issue, and provides developers a way to write code like this: <code>someAtomicPerson.bestFriend.name =&gt; &quot;Britta&quot;</code>.
Although the RDF ecosystem does have some solutions for this (@context objects in JSON-LD, @prefix mappings, the @ontologies library), these prefixes are not defined in Properties themselves and therefore are often defined locally or separate from the ontology, which means that developers have to manually map them most of the time.
This is why Atomic Data introduces a <code>shortname</code> field in Properties, which forces modelers to choose a 'key' that can be used in ORM contexts.</p>
<h3><a class="header" href="#adding-native-arrays" id="adding-native-arrays">Adding native arrays</a></h3>
<p>RDF lacks a clear solution for dealing with <a href="https://ontola.io/blog/ordered-data-in-rdf/">ordered data</a>, resulting in confusion when developers have to create lists of content.
Adding an Array data type as a base data type helps solve this. (<a href="https://github.com/ontola/atomic-data/issues/4">discussion</a>)</p>
<h3><a class="header" href="#adding-a-native-state-changes-standard" id="adding-a-native-state-changes-standard">Adding a native state changes standard</a></h3>
<p>There is no integrated standard for communicating state changes.
Although <a href="https://github.com/ontola/linked-delta">linked-delta</a> and <a href="https://afs.github.io/rdf-delta/">rdf-delta</a> do exist, they aren't referred to by the RDF spec.
I think developers need guidance when learning a new system such as RDF, and that's why <a href="interoperability/../commits/intro.html">Atomic Commits</a> is included in this book.</p>
<h3><a class="header" href="#adding-a-schema-language" id="adding-a-schema-language">Adding a schema language</a></h3>
<p>A schema language is necessary to constrain and validate instances of data.
This is very useful when creating domain-specific standards, which can in turn be used to generate forms or language-specific types / interfaces.
Shape validations are already possible in RDF using both <a href="https://www.w3.org/TR/shacl/">SHACL</a> and <a href="https://shex.io/">SHEX</a>, and these are both very powerful and well designed.</p>
<p>However, with Atomic Data, I'm going for simplicity.
This also means providing an all-inclusive documentation.
I want people who read this book to have a decent grasp of creating, modeling, sharing, versioning and querying data.
It should provide all information that most developers (new to linked data) will need to get started quickly.
Simply linking to SHACL / SHEX documentation could be intimidating for new developers, who simply want to define a simple shape with a few keys and datatypes.</p>
<p>Also, SHACL requires named graphs (which are not specified in Atomic Data) and SHEX requires a new serialization format, which might limit adoption.
Atomic Data has some unique constrains (such as subject-predicate uniqueness) which also might make things more complicated when using SHEX / SHACL.</p>
<p><em>However</em>, it is not the intention of Atomic Data to create a modeling abstraction that is just as powerful as the ones mentioned above, so perhaps it is better to include a SHACL / SHEX tutorial and come up with a nice integration of both worlds.</p>
<h3><a class="header" href="#a-new-name-with-new-docs" id="a-new-name-with-new-docs">A new name, with new docs</a></h3>
<p>Besides the technical reasons described above, I think that there are social reasons to start with a new concept and give it a new name:</p>
<ul>
<li>The RDF vocabulary is intimidating. When trying to understand RDF, you're likely to traverse many pages with new concepts: <code>literal</code>, <code>named node</code>, <code>graph</code>, <code>predicate</code>, <code>named graph</code>, <code>blank node</code>... The core specification provides a formal description of these concepts, but fails to do this in a way that results in quick understanding and workable intuitions. Even experienced RDF developers tend to be confused about the nuances of the core model.</li>
<li>There is a lack of learning resources that provide a clear, complete answer to the lifecycle of RDF data: modeling data, making data, hosting it, fetching it, updating it. Atomic Data aims to provide an opinionated answer to all of these steps. It feels more like a one-stop-shop for questions that developers are likely to encounter, whilst keeping the extendability.</li>
<li>All Core / Schema URLs should resolve to simple, clear explanations with both examples and machine readable definitions. Especially the Property and Class concepts.</li>
<li>The Semantic Web community has had a lot of academic attention from formal logic departments, resulting in a highly developed standard for knowledge modeling: the Web Ontology Language (OWL). While this is mostly great, its open-world philosophy and focus on reasoning abilities can confuse developers who are simply looking for a simple way to share models in RDF.</li>
</ul>
<h2><a class="header" href="#convert-rdf-to-atomic-data" id="convert-rdf-to-atomic-data">Convert RDF to Atomic Data</a></h2>
<ul>
<li><strong>All the <code>subject</code> URLs MUST actually resolve, and return all triples about that subject</strong>. All <code>blank nodes</code> should be converted into URLs. Atomic Data tools might help to achieve this, for example by hosting the data.</li>
<li><strong>All <code>predicates</code> SHOULD resolve to Atomic Properties, and these SHOULD have a <code>datatype</code></strong>. You will probably need to change predicate URLs to Atomic Property URLs, or update the things that the predicate points to to include the required Atomic Property items (e.g. having a Datatype and a Shortname). This also means that the <code>datatype</code> in the original RDF statement can be dropped.</li>
<li>Literals with a <code>language</code> tag are converted to TranslationBox resources, which also means their identifiers must be created. Keep in mind that Atomic Data does not allow for blank nodes, so the TranslationBox identifiers must be URLs.</li>
</ul>
<p>Step by step, it entails:</p>
<ol>
<li>Set up some server to make sure the URLs will resolve.</li>
<li>Create (or find and refer to) Atomic Properties for all the <code>predicates</code>. Make sure they have a DataType and a Shortname.</li>
<li>If you have triples about a subject that you don't control, change the URL to some that you <em>can</em> control, and refer to that external resource.</li>
</ol>
<p>Atomic Data will need <a href="interoperability/../tooling.html">tooling</a> to facilitate in this process.
This tooling should help to create URLs, Properties, and host everything on an easy to use server.</p>
<h2><a class="header" href="#convert-atomic-data-to-rdf" id="convert-atomic-data-to-rdf">Convert Atomic data to RDF</a></h2>
<p>Since all Atomic Data is also valid RDF, it's trivial to convert / serialize Atoms to RDF.
This is why <a href="https://github.com/joepio/atomic">atomic</a> can serialize Atomic Data to RDF. (For example, try <code>atomic-cli get https://atomicdata.dev/properties/description --as n3</code>)</p>
<p>However, contrary to Atomic Data, RDF has optional Language and Datatype elements in every statement.
It is good practice to use these RDF concepts when serializing Atomic Data into Turtle / RDF/XML, or other <a href="https://ontola.io/blog/rdf-serialization-formats/">RDF serialization formats</a>.</p>
<ul>
<li>Convert Atoms with linked <code>TranslationBox</code> Resources to Literals with an <code>xsd:string</code> datatype and the corresponding language in the tag.</li>
<li>Convert Atoms with ResourceArrays to <a href="https://ontola.io/blog/ordered-data-in-rdf/">Collections</a> that are native to that serialization format.</li>
<li>Dereference the Property and Datatype from Atomic Properties, and add the URLs in <code>datatypes</code> in RDF statements.</li>
</ul>
<h1><a class="header" href="#atomic-data-and-solid" id="atomic-data-and-solid">Atomic Data and Solid</a></h1>
<p>The <a href="https://solidproject.org/">Solid project</a> is an initiative by the inventor of linked data and the world wide web: sir Tim Berners-Lee.
In many ways, it has similar goals to Atomic Data:</p>
<ul>
<li>Decentralize the web</li>
<li>Make things more interoperable</li>
<li>Give people more control over their data</li>
</ul>
<p>Technically, both are also similar:</p>
<ul>
<li>Usage of personal servers, or PODs (Personal Online Datastores). Both Atomic Data and Solid aim to provide users with a highly personal server where all sorts of data can be stored.</li>
<li>Usage of <strong>linked data</strong>. All Atomic Data is valid RDF, which means that <strong>all Atomic Data is compatible with Solid</strong>. However, the other way around is more difficult. In other words, if you choose to use Atomic Data, you can always put it in your Solid Pod.</li>
</ul>
<p>But there are some important differences, too:</p>
<ul>
<li>Atomic Data uses a strict built-in schema to ensure type safety.</li>
<li>Atomic Data standardizes state changes (which also provides version control / history, audit trails)</li>
<li>Atomic Data is more easily serializable to other formats (like JSON)</li>
<li>Atomic Data is less mature, and currently lacks things like authentication and hierarchy</li>
</ul>
<p>Disclaimer: I've been quite involved in the development of Solid, and have a lot of respect for all the people who are working on it.
The following is not meant as a critique on Solid, let alone the individuals working on it.</p>
<h2><a class="header" href="#atomic-data-is-type-safe-because-of-its-built-in-schema" id="atomic-data-is-type-safe-because-of-its-built-in-schema">Atomic Data is type-safe, because of its built-in schema</a></h2>
<p>Atomic Data is more strict than Solid - which means that it only accepts data that conforms to a specific shape.
In a Solid Pod, you're free to add any shape of data that you like - it is not <em>validated</em> by some schema.
Yes, there are some efforts of using SHACL or SHEX to <em>constrain</em> data before putting it in, but as of now it is not part of the spec or any implementation that I know of.
A lack of schema strictness can be helpful during prototyping and rapid development, especially if you write data by hand, but it also limits how easy it is to build reliable apps with that data.
Atomic Data aims to be very friendly for developers that re-use data, and that's why we take a different approach: all data <em>must be</em> validated by Atomic Schema before it's stored on a server.
This means that all Atomic Properties will have to exist on a publicly accessible URL, before the property can be used somewhere.</p>
<p>You can think of Atomic Data more like a (dynamic) SQL database that offers guarantees about its content type, and a Solid Pod more like a document store that takes in all kinds of content.
Most of the differences have to do with how Atomic Schema aims to make linked data easier to work with, but that is covered in the previous <a href="interoperability/./rdf.html">RDF chapter</a>.</p>
<h2><a class="header" href="#atomic-data-standardizes-state-changes-event-sourcing" id="atomic-data-standardizes-state-changes-event-sourcing">Atomic Data standardizes state changes (event sourcing)</a></h2>
<p>With Solid, you change a Resource by sending a POST request to the URL that you want to change.
With Atomic, you change a Resource by sending a signed Commit that contains the requested changes to a Server.</p>
<p>Event sourcing means that all changes are stored (persisted) and used to calculate the current state of things.
In practice, this means that users get a couple of nice features for free:</p>
<ul>
<li><strong>Versioning for all items by default</strong>. Storing events means that these events can be <em>replayed</em>, which means you get to traverse time / undo / redo.</li>
<li><strong>Edit / audit log for everything</strong>. Events contain information about who made which change at which point in time. Can be useful for finding out why things are the way they are.</li>
<li><strong>Easier to add query options / indexes</strong>. Any system can play-back the events, which means that the events can be used as an API to add new query options / fill new indexes. This is especially useful if you want to add things like full-text search, or some geolocation index.</li>
</ul>
<p>It also means that, compared to Solid, there is a relatively simple and strict API for changing data.
Atomic Data has a <strong>uniform write API</strong>.
All changes to data are done by posting Commits to the <code>/commits</code> endpoint of a Server.
This removes the need to think about differences between all sorts of HTTP methods like POST / PUT / PATCH, and how servers should reply to that.</p>
<h2><a class="header" href="#atomic-data-is-more-easily-serializable-to-other-formats-like-json" id="atomic-data-is-more-easily-serializable-to-other-formats-like-json">Atomic Data is more easily serializable to other formats (like JSON)</a></h2>
<p>Atomic Data is designed with the modern developer in mind.
One of the things that developers expect, is to be able to traverse (JSON) objects easily.
Doing this with RDF is not easily possible, because doing this requires <em>subject-predicate uniqueness</em>.
Atomic Data does not have this problem (properties <em>must</em> be unique), which means that traversing objects becomes easy.</p>
<p>Another problem that Atomic Data solves, is dealing with long URLs as property keys.
Atomic Data uses <code>shortnames</code> to map properties to short, human-readable strings.</p>
<p>For more information about these differences, see the previous <a href="interoperability/./rdf.html">RDF chapter</a>.</p>
<h2><a class="header" href="#solid-is-more-mature" id="solid-is-more-mature">Solid is more mature</a></h2>
<p>Atomic Data has significant gaps at this moment - not just in the implementations, but also in the spec.
This makes it not yet usable for most applications.
Here's a list of things missing in Atomic Data, with links to their open issues and links to their existing Solid counterpart.</p>
<ul>
<li>No way to restrict access to reading content. Only for writing content with Commits. <a href="https://github.com/solid/web-access-control-spec">WAC</a> in Solid. Also, <a href="https://github.com/ontola/atomic-data/issues/18">No hierarchy model</a>. <a href="https://shapetrees.org/TR/specification/index.html#ecosystem">ShapeTrees in Solid</a>. (We're working on an implementation of a hierarchy with authorization, see <a href="https://github.com/ontola/atomic-data/issues/18">issue</a>)</li>
<li>No inbox or <a href="https://www.w3.org/TR/ldn/">notifications</a> (<a href="https://github.com/ontola/atomic-data/issues/28">issue</a>)</li>
<li>No way to discover content from user ID.</li>
<li>No support from a big community, a well-funded business or the inventor of the world wide web.</li>
</ul>
<h1><a class="header" href="#how-does-atomic-data-relate-to-json" id="how-does-atomic-data-relate-to-json">How does Atomic Data relate to JSON?</a></h1>
<p>Because JSON is so popular, Atomic Data is designed with JSON in mind.</p>
<p>Atomic Data is often (by default) serialized to <a href="interoperability/../core/json-ad.html">JSON-AD</a>, which itself uses JSON.
JSON-AD uses URLs as keys, which is what gives Atomic Data many of its perks, but using these long strings as keys is not very easy to use in many contexts.
That's why you can serialize Atomic Data to simple, clean JSON.</p>
<h2><a class="header" href="#atomic-data-as-plain-json" id="atomic-data-as-plain-json">Atomic Data as plain JSON</a></h2>
<p>The JSON keys are then derived from the <code>shortnames</code> of properties.
For example, we could convert this JSON-AD:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://atomicdata.dev/properties/description&quot;,
  &quot;https://atomicdata.dev/properties/datatype&quot;: &quot;https://atomicdata.dev/datatypes/markdown&quot;,
  &quot;https://atomicdata.dev/properties/description&quot;: &quot;A textual description of something. When making a description, make sure that the first few words tell the most important part. Give examples. Since the text supports markdown, you're free to use links and more.&quot;,
  &quot;https://atomicdata.dev/properties/isA&quot;: [
    &quot;https://atomicdata.dev/classes/Property&quot;
  ],
  &quot;https://atomicdata.dev/properties/shortname&quot;: &quot;description&quot;
}
</code></pre>
<p>... into this plain JSON:</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://atomicdata.dev/properties/description&quot;,
  &quot;datatype&quot;: &quot;https://atomicdata.dev/datatypes/markdown&quot;,
  &quot;description&quot;: &quot;A textual description of something. When making a description, make sure that the first few words tell the most important part. Give examples. Since the text supports markdown, you're free to use links and more.&quot;,
  &quot;is-a&quot;: [
    &quot;https://atomicdata.dev/classes/Property&quot;
  ],
  &quot;shortname&quot;: &quot;description&quot;
}
</code></pre>
<p>Note that when you serialize Atomic Data to plain JSON, some information is lost: the URLs are no longer there.
This means that it is no longer possible to find out what the datatype of a single value is - we now only know if it's a <code>string</code>, but not if it actually represents a markdown string or something else.
Most Atomic Data systems will therefore <em>not</em> use this plain JSON serialization, but for some clients (e.g. a front-end app), it might be easier to use the plain JSON, as the keys are easier to write than the long URLs that JSON-AD uses.</p>
<h2><a class="header" href="#from-json-to-json-ad" id="from-json-to-json-ad">From JSON to JSON-AD</a></h2>
<p>Atomic Data requires a bit more information about pieces of data than JSON tends to contain. Let's take a look at a regular JSON example:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;John&quot;,
  &quot;birthDate&quot;: &quot;1991-01-20&quot;
}
</code></pre>
<p>We need more information to convert this JSON into Atomic Data.
The following things are missing:</p>
<ul>
<li>What is the <strong>Subject</strong> URL of the resource being described?</li>
<li>What is the <strong>Property</strong> URL of the keys being used? (<code>name</code> and <code>birthDate</code>), and consequentially, how should the values be parsed? What are their DataTypes?</li>
</ul>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/people/john&quot;,
  &quot;https://example.com/properties/name&quot;: &quot;John&quot;,
  &quot;https://example.com/properties/birthDate&quot;: &quot;1991-01-20&quot;
}
</code></pre>
<h2><a class="header" href="#from-atomic-data-to-json-ld" id="from-atomic-data-to-json-ld">From Atomic Data to JSON-LD</a></h2>
<p>Atomic Data is a strict subset of RDF, and the most popular serialization of RDF for JSON data is <a href="https://json-ld.org/">JSON-LD</a>.</p>
<p>Since Atomic Schema requires the presence of a <code>key</code> slug in Properties, converting Atomic Data to JSON results in dev-friendly objects with nice shorthands.</p>
<pre><code class="language-json">{
  &quot;@id&quot;: &quot;https://example.com/people/John&quot;,
  &quot;https://example.com/properties/lastname&quot;: &quot;John&quot;,
  &quot;https://example.com/properties/bestFriend&quot;: &quot;https://example.com/sarah&quot;,
}
</code></pre>
<p>Can be automatically converted to:</p>
<pre><code class="language-json">{
  &quot;@context&quot;: {
    &quot;@id&quot;: &quot;https://example.com/people/John&quot;,
    &quot;name&quot;: &quot;https://example.com/properties/lastname&quot;,
    &quot;bestFriend&quot;: &quot;https://example.com/properties/bestFriend&quot;,
  },
  &quot;name&quot;: &quot;John&quot;,
  &quot;bestFriend&quot;: {
    &quot;@id&quot;: &quot;https://example.com/sarah&quot;
  },
}
</code></pre>
<p>The <code>@context</code> object provides a <em>mapping</em> to the original URLs.</p>
<p>JSON-AD and JSON-LD are very similar by design, but there are some important differences:</p>
<ul>
<li>JSON-AD is designed just for atomic data, and is therefore easier and more performant to parse / serialize.</li>
<li>JSON-LD uses <code>@context</code> to map keys to URLs. Any type of mapping is valid. JSON-AD, on the other hand, doesn't map anything - all keys are URLs.</li>
<li>JSON-LD uses nested objects for links and sequences, such as <code>@list</code>. JSON-AD does not.</li>
<li>Arrays in JSON-LD do not indicate ordered data - they indicate that for some subject-predicate combination, multiple values exist. This is a result of how RDF works.</li>
</ul>
<h2><a class="header" href="#json-ld-requirements-for-valid-atomic-data" id="json-ld-requirements-for-valid-atomic-data">JSON-LD Requirements for valid Atomic Data</a></h2>
<ul>
<li>Make sure the URLs used in the <code>@context</code> resolve to Atomic Properties.</li>
</ul>
<!-- Not sure about this.. maybe use RDF collections or some other model? -->
<ul>
<li>Convert JSON-LD arrays into ResourceArrays</li>
<li>Creating nested JSON objects is possible (by resolving the identifiers from <code>@id</code> relations), but it is up to the serializer to decide how deep this object nesting should happen.</li>
</ul>
<p>Note that as of now, there are no JSON-LD parsers for Atomic Data.</p>
<h1><a class="header" href="#atomic-data-and-ipfs" id="atomic-data-and-ipfs">Atomic Data and IPFS</a></h1>
<h2><a class="header" href="#what-is-ipfs" id="what-is-ipfs">What is IPFS</a></h2>
<p>IPFS (the InterPlanetary File System) is a standard that enables decentralized file storage and retrieval using content-based identifiers.
Instead of using an HTTP URL like <code>http://example.com/helloworld</code>, it uses the IPFS scheme, such as <code>ipfs:QmX6j9DHcPhgBcBtZsuRkfmk2v7G5mzb11vU9ve9i8vDsL</code>.
IPFS identifies things based on their unique content hash (the long, seemingly random string) using a thing called a Merkle DAG (<a href="https://medium.com/textileio/whats-really-happening-when-you-add-a-file-to-ipfs-ae3b8b5e4b0f#:%7E:text=In%20practice%2C%20content%20addressing%20systems,function%2C%20to%20produce%20a%20digest.&amp;text=From%20raw%20image%20to%20cryptographic%20digest%20to%20content%20id%20(multihash).">this great article</a> explains it nicely).
This is called a <a href="https://github.com/multiformats/cid">CID</a>, or Content ID.
This simple idea (plus some not so simple network protocols) allows for decentralized, temper-proof storage of data.
This fixes some issues with HTTP that are related to its centralized philosophy: no more 404s!</p>
<h2><a class="header" href="#why-is-ipfs-especially-interesting-for-atomic-data" id="why-is-ipfs-especially-interesting-for-atomic-data">Why is IPFS especially interesting for Atomic Data</a></h2>
<p>Atomic Data is highly dependent on the availability of Resources, especially Properties and Datatypes.
These resources are meant to be re-used a lot, and that would make everything expensive.</p>
<h2><a class="header" href="#considerations-using-ipfs-urls" id="considerations-using-ipfs-urls">Considerations using IPFS URLs</a></h2>
<p>They are static, their contents can never change.
This is great for some types of data, but horrible for others.
If you're describing a time-dependent thing (such as a person's job),
If you're describing personal, private information, its also a bad idea to use IPFS, because it's designed to be permanent.
Also, IPFS is not as fast as HTTP - at least for now.</p>
<h2><a class="header" href="#atomic-data-and-ipld" id="atomic-data-and-ipld">Atomic Data and IPLD</a></h2>
<p>IPLD (not IPFS) stands for InterPlanetary Linked Data, but is not related to RDF.
The scope seems fundamentally different from RDF, too, but I have to read more about this.</p>
<h1><a class="header" href="#atomic-data-and-sql" id="atomic-data-and-sql">Atomic Data and SQL</a></h1>
<p>Atomic Data has some characteristics that make it similar and different from SQL.</p>
<ul>
<li>Atomic Data has a <em>dynamic</em> schema. Any Resource could have different properties. However, the properties themselves are validated (contrary to most NOSQL solutions)</li>
<li>Atomic Data separates <em>reading</em> and <em>writing</em>, whereas SQL has one language for both.</li>
<li>Atomic Data has a standardized way of storing changes (<a href="interoperability/../commits/intro.html">Commits</a>)</li>
</ul>
<h2><a class="header" href="#dynamic-vs-static-schema" id="dynamic-vs-static-schema">Dynamic vs static schema</a></h2>
<p>At its core, SQL is a query language based around <em>tables</em> and <em>rows</em>.
The <em>tables</em> in SQL are similar to <em>classes</em> in Atomic Data: they both define a set of <em>properties</em> which an item could have.
In SQL, the schema of the database defines which shape the data can have, which properties are required, what datatypes they have.
In Atomic Data, the schema exists as a Resource on the web, which means that they can be retrieved using HTTP.
SQL is a centralized, closed system.
Atomic Data is a decentralized, open system.</p>
<h2><a class="header" href="#querying" id="querying">Querying</a></h2>
<p>The SQL query language is for both <em>reading</em> and <em>writing</em> data.
In Atomic Data a distinction is made between Query and Command - getting and setting (Command Query Responsibility Segregation, <a href="https://martinfowler.com/bliki/CQRS.html">CQRS</a>).
The <a href="interoperability/../core/querying.html">Query side</a> is handled using Subject Fetching (sending a GET request to a URL, to get a single resource) and <a href="interoperability/../schema/collections.html">Collections</a> (filtering and sorting data).
The Command side is typically done using <a href="interoperability/../commits/intro.html">Atomic Commits</a>, although you're free not to use it.</p>
<p>SQL is way more powerful, as a query language.
In SQL, the one creating the query basically defines the shape of a table that is requested, and the database returns that shape.
Atomic Data does not offer such functionality.
So if you need to create custom tables at runtime, you might be better off using SQL, or move your Atomic Data to a query system.</p>
<h2><a class="header" href="#faq" id="faq">FAQ</a></h2>
<h3><a class="header" href="#is-atomic-data-nosql-or-sql" id="is-atomic-data-nosql-or-sql">Is Atomic Data NOSQL or SQL?</a></h3>
<p>Generally, Atomic Data apps do not use SQL - so they are NOSQL.
Atomic-server, for example, internally uses a key-value store (sled) for persistence.</p>
<p>Like most NOSQL systems, Atomic Data does not limit data entries to a specific table shape, so you can add any property that you like to a resource.
However, unlike most NOSQL systems, Atomic Data <em>does</em> perform validations on each value.
So in a way, Atomic Data tries to combine best of both worlds: the extendibility and flexibility of NOSQL, with the type safety of SQL.</p>
<h3><a class="header" href="#is-atomic-data-transactional--acid" id="is-atomic-data-transactional--acid">Is Atomic Data transactional / ACID?</a></h3>
<p>Well, if you use Atomic-Server, then you can only write to the server by using Atomic Commits, which are in fact transactions.
This means that if part of the transaction fails, it is reverted - transactions are only applied when they are 100% OK.
This prevents inconsistent DB states.</p>
<p>ACID refers to Atomicity,</p>
<h3><a class="header" href="#can-i-use-a-sql-database-with-atomic-data" id="can-i-use-a-sql-database-with-atomic-data">Can I use a SQL database with Atomic Data?</a></h3>
<p>Yes, if you want to make your existing project serve Atomic Data, you can keep your existing SQL database, see <a href="interoperability/upgrade.html">the upgrade guide</a>.
When you want to <em>import arbitrary Atomic Data</em>, it might be easier to use <code>atomic-server</code>.
If you want to store arbitrary Atomic Data in a SQL database, you might be best off by creating a <code>Resources</code> table with a <code>subject</code> and a <code>propertyValues</code> column, or create both a <code>properties</code> table and a <code>resources</code> one.</p>
<h1><a class="header" href="#upgrade-your-existing-application-to-atomic-data" id="upgrade-your-existing-application-to-atomic-data">Upgrade your existing application to Atomic Data</a></h1>
<p>If you want to make your existing project compatible with Atomic Data, you probably don't have to get rid of your existing storage / DB implementation.
The only thing that matters, is how you make the data accessible to others: the serialization.
You can keep your existing software and logic, but simply change the last little part of your API.
In short, this is what you'll have to do:</p>
<ul>
<li>Map all properties of resources to Atomic Properties. Either use existing ones, or create new ones and make them accessible (using any Atomic Server, as long as the URLs of the properties resolve).</li>
<li>Make sure that when the user requests some URL, that you return that resource as a JSON-AD object (at the very least if the user requests it using an HTTP <code>Accept</code> header).</li>
</ul>
<p>Don't feel obliged to implement all parts of the Atomic Data spec, such as Collections and Commits.</p>
<h1><a class="header" href="#tooling-for-atomic-data" id="tooling-for-atomic-data">Tooling for Atomic Data</a></h1>
<ul>
<li>Server: <a href="https://github.com/joepio/atomic">atomic-server</a></li>
<li>Front-end browser + typescript client library: <a href="https://github.com/joepio/atomic-data-browser">atomic-data-browser</a></li>
<li>CLI (atomic-cli): <a href="https://github.com/joepio/atomic">atomic-cli</a></li>
<li>Rust library: <a href="https://github.com/joepio/atomic">atomic-lib</a></li>
</ul>
<h2><a class="header" href="#atomic-server" id="atomic-server"><code>atomic-server</code></a></h2>
<p>Server for hosting Atomic Data. Uses <code>atomic-lib</code>.</p>
<ul>
<li>Responds to requests for created Atomic Resources, makes atomic data available at their URL.</li>
<li>Manages data on disk.</li>
<li>Useful query options (e.g. Triple Pattern Fragments)</li>
<li>Browser-friendly HTML presentation, JSON serialization, AD3 serialization.</li>
</ul>
<p>One liner: <code>$ docker run -p 80:80 -p 443:443 -v atomic-storage:/atomic-storage joepmeneer/atomic-server</code></p>
<p><a href="https://atomicdata.dev/">demo</a></p>
<p><a href="https://github.com/joepio/atomic">MIT licensed repository + issue tracker</a>.</p>
<h2><a class="header" href="#atomic-data-browser" id="atomic-data-browser"><code>atomic-data-browser</code></a></h2>
<p>Data browser + react typescript / javascript front-end library.</p>
<ul>
<li>View &amp; edit atomic data, using dynamic forms</li>
<li>Collections with pagination and sorting</li>
<li>Client-side full-text search</li>
</ul>
<p><a href="https://atomicdata.dev/">demo</a> (same as <code>atomic-server</code>)</p>
<p><a href="https://github.com/joepio/atomic-data-browser">MIT licensed repository + issue tracker</a>.</p>
<h2><a class="header" href="#atomic-cli" id="atomic-cli"><code>atomic-cli</code></a></h2>
<p>A tool for generating / querying Atomic Data from the command line. Install with <code>cargo install atomic-cli</code>.</p>
<pre><code>atomic 0.20.0
Joep Meindertsma &lt;joep@ontola.io&gt;
Create, share, fetch and model linked atomic data!

USAGE:
    atomic-cli [SUBCOMMAND]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    destroy    Permanently removes a Resource. Uses Commits.
    edit       Edit a single Atom from a Resource using your text editor. Uses Commits.
    get        Traverses a Path and prints the resulting Resource or Value.
    help       Prints this message or the help of the given subcommand(s)
    list       List all bookmarks
    new        Create a Resource
    remove     Remove a single Atom from a Resource. Uses Commits.
    set        Update an Atom's value. Uses Commits.
    tpf        Finds Atoms using Triple Pattern Fragments.

Visit https://github.com/joepio/atomic for more info
</code></pre>
<p><a href="https://github.com/joepio/atomic">MIT licensed repository + issue tracker</a>.</p>
<h2><a class="header" href="#atomic-lib-rust" id="atomic-lib-rust"><code>atomic-lib</code> (Rust)</a></h2>
<p>Library that powers <code>atomic-server</code> and <code>atomic-cli</code>. Features:</p>
<ul>
<li>An in-memory store</li>
<li>Parsing (JSON-AD, AD3) / Serialization (JSON-AD, AD3, JSON-LD, TTL, N-Triples)</li>
<li>Commit validation and processing</li>
<li>TPF queries</li>
<li>Constructing Collections</li>
<li>Path traversal</li>
<li>Basic validation</li>
</ul>
<p><a href="https://github.com/joepio/atomic">MIT licensed repository + issue tracker</a>.</p>
<h2><a class="header" href="#want-to-add-to-this-list-some-ideas-for-tooling" id="want-to-add-to-this-list-some-ideas-for-tooling">Want to add to this list? Some ideas for tooling</a></h2>
<p>This document contains a set of ideas that would help achieve that success.</p>
<h3><a class="header" href="#atomizer-data-importer-and-conversion-kit" id="atomizer-data-importer-and-conversion-kit">Atomizer (data importer and conversion kit)</a></h3>
<ul>
<li>Import data from some data source (CSV / SQL / JSON / RDF), fill in the gaps (mapping / IRI creation / datatypes) an create new Atoms</li>
<li>Perhaps a CLI, library, GUI or a combination of all of these</li>
</ul>
<h3><a class="header" href="#atomic-preview" id="atomic-preview">Atomic Preview</a></h3>
<ul>
<li>A simple (JS) widget that can be embedded anywhere, which converts an Atomic Graph into an HTML view.</li>
<li>Would be useful for documentation, and as a default view for Atomic Data.</li>
</ul>
<h3><a class="header" href="#atomic-dart--flutter" id="atomic-dart--flutter">Atomic-Dart + Flutter</a></h3>
<p>Library + front-end app for browsing / manipulating Atomic Data on mobile devices.</p>
<h1><a class="header" href="#get-involved" id="get-involved">Get involved</a></h1>
<p>Atomic Data is an open specification, and that means that you're very welcome to share your thoughts and help make this standard as good as possible.</p>
<p>Things you can do:</p>
<ul>
<li>Start playing with / contributing to the <a href="https://github.com/joepio/atomic"><code>atomic-server / atomic-cli</code></a> implementation written in Rust.</li>
<li>Join the <a href="https://discord.gg/a72Rv2P">Discord server</a> for voice / text chat</li>
<li>Clone the <a href="https://github.com/ontola/atomic-data/">Book Repo</a> and read some of the inline comments, which might help start some discussions</li>
<li>Drop an <a href="https://github.com/ontola/atomic-data/issues">issue on Github</a> to share your suggestions or criticism</li>
<li>Join our <a href="https://www.w3.org/community/atomic-data/">W3C Community Group</a></li>
</ul>
<h2><a class="header" href="#authors" id="authors">Authors:</a></h2>
<ul>
<li>Joep Meindertsma (<a href="https://github.com/joepio/">joepio</a> from <a href="https://ontola.io/">Ontola.io</a>)</li>
</ul>
<h2><a class="header" href="#special-thanks-to" id="special-thanks-to">Special thanks to:</a></h2>
<ul>
<li>Thom van Kalkeren (who came up with many great ideas on how to work with RDF, such as <a href="https://github.com/ontola/hextuples">HexTuples</a> and <a href="https://github.com/ontola/linked-delta">linked-delta</a>)</li>
<li>Tim Berners-Lee (for everything he did for linked data and the web)</li>
<li>Ruben Verborgh (for doing great work with RDF, such as the TPF spec)</li>
<li>Pat McBennett (lots of valuable feedback on initial Atomic Data docs)</li>
<li>Manu Sporny (for his work on JSON-LD)</li>
<li>All the other people who contributed to linked data related standards</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-121994595-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
